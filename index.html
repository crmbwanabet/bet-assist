<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BetAssist AI - Personalized Sports Betting Assistant</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes typing-dot {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.5; }
      30% { transform: translateY(-4px); opacity: 1; }
    }
    .typing-dot { animation: typing-dot 1.4s infinite ease-in-out; }
    .typing-dot:nth-child(1) { animation-delay: 0s; }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes message-appear {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .message-appear { animation: message-appear 0.3s ease-out; }
    
    .chat-scroll::-webkit-scrollbar { width: 6px; }
    .chat-scroll::-webkit-scrollbar-track { background: transparent; }
    .chat-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }

    .game-card {
      background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
    }
    
    /* Clickable recommendation buttons */
    .quick-action {
      display: inline-block;
      padding: 8px 16px;
      margin: 4px;
      background: linear-gradient(135deg, #1e3a5f 0%, #0f172a 100%);
      border: 1px solid #3b82f6;
      border-radius: 20px;
      color: #60a5fa;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .quick-action:hover {
      background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
      color: white;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }
    .quick-action:active {
      transform: translateY(0);
    }
    .quick-actions-container {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #334155;
    }
  </style>
</head>
<body class="bg-slate-900 min-h-screen">

  <!-- Main App -->
  <div id="mainApp">
    <!-- Header -->
    <div class="fixed top-0 left-0 right-0 bg-slate-800 border-b border-slate-700 px-4 py-3 z-40">
      <div class="max-w-2xl mx-auto flex items-center justify-between">
        <div class="flex items-center gap-3">
          <div class="w-10 h-10 rounded-xl bg-gradient-to-br from-amber-400 to-orange-500 flex items-center justify-center">
            <span class="text-xl"></span>
          </div>
          <div>
            <h1 class="font-bold text-white">BetAssist AI</h1>
            <div class="flex items-center gap-1">
              <div class="w-2 h-2 rounded-full bg-emerald-400 animate-pulse"></div>
              <span class="text-xs text-slate-400">Personalized Sports Betting AI</span>
            </div>
          </div>
        </div>
        <div class="flex gap-2">
          <button onclick="clearChat()" class="text-slate-400 hover:text-white p-2 rounded-lg hover:bg-slate-700" title="Clear chat">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <!-- Chat Container -->
    <div class="max-w-2xl mx-auto pt-20 pb-40 px-4">
      <div id="messages" class="space-y-4"></div>
      
      <!-- Typing Indicator -->
      <div id="typingIndicator" class="hidden flex items-center gap-2 p-4">
        <div class="w-8 h-8 rounded-full bg-gradient-to-r from-amber-400 to-orange-500 flex items-center justify-center">
          <span class="text-sm"></span>
        </div>
        <div class="flex gap-1">
          <div class="w-2 h-2 bg-slate-400 rounded-full typing-dot"></div>
          <div class="w-2 h-2 bg-slate-400 rounded-full typing-dot"></div>
          <div class="w-2 h-2 bg-slate-400 rounded-full typing-dot"></div>
        </div>
        <span id="typingStatus" class="text-xs text-slate-400 ml-2"></span>
      </div>
    </div>

    <!-- Input Area -->
    <div class="fixed bottom-0 left-0 right-0 bg-slate-900 border-t border-slate-700 p-4">
      <div class="max-w-2xl mx-auto">
        <!-- Input -->
        <div class="flex gap-3">
          <input 
            type="text" 
            id="messageInput" 
            placeholder="Ask about matches, tips, betting, casino..." 
            class="flex-1 bg-slate-800 text-white placeholder-slate-400 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-amber-500 border border-slate-700"
            onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); }"
          >
          <button 
            onclick="sendMessage()" 
            id="sendButton"
            class="px-6 py-3 bg-gradient-to-r from-amber-500 to-orange-500 hover:from-amber-600 hover:to-orange-600 text-white font-semibold rounded-xl transition-all disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Send
          </button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // ============================================
    //  CONFIGURATION - ADD YOUR API KEYS HERE
    // ============================================
    // Version: 2.1 - Quick Actions Update
    
    //  CLAUDE API KEY - Now stored in Supabase Edge Function (more secure!)
    // You'll set this in Supabase secrets, not here
    const HARDCODED_API_KEY = 'not-needed-using-proxy';
    
    // ============================================
    //  SUPABASE DATABASE (OPTIONAL - for testing)
    // ============================================
    
    const SUPABASE_CONFIG = {
      url: 'https://dumjacmxefrxzcccsyxj.supabase.co',
      anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImR1bWphY214ZWZyeHpjY2NzeXhqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg0NjgwNTgsImV4cCI6MjA4NDA0NDA1OH0.lpzyMwI9Vds91FXm2oxK9Q8OpOYy-uSs3pWKdcx3Rd8',
      enabled: true,
      // Edge Function URL for Claude API proxy
      claudeProxyUrl: 'https://dumjacmxefrxzcccsyxj.supabase.co/functions/v1/claude-proxy',
    };

    // Supabase client instance
    let supabaseClient = null;
    let currentPlayerId = null;

    // ============================================
    //  BUG FIXES - Caching, Rate Limiting, etc.
    // ============================================
    
    // API Response Cache (prevents redundant API calls)
    const apiCache = new Map();
    const CACHE_TTL = 60000; // 1 minute cache
    
    // Rate limiting for messages
    let lastMessageTime = 0;
    const MESSAGE_COOLDOWN = 1500; // 1.5 seconds between messages
    
    // Debounced save
    let saveTimeout = null;
    const SAVE_DEBOUNCE = 5000; // 5 seconds
    
    // Session tracking
    const sessionStart = Date.now();
    let sessionWarningShown = false;

    // Cache helper functions
    function getCachedData(key) {
      const cached = apiCache.get(key);
      if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
        console.log(` Cache hit: ${key}`);
        return cached.data;
      }
      return null;
    }

    function setCachedData(key, data) {
      apiCache.set(key, { data, timestamp: Date.now() });
      // Clean old cache entries (keep max 50)
      if (apiCache.size > 50) {
        const oldestKey = apiCache.keys().next().value;
        apiCache.delete(oldestKey);
      }
    }

    // Retry helper for API calls
    async function fetchWithRetry(url, options = {}, maxRetries = 3) {
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          const response = await fetch(url, options);
          if (response.ok) return response;
          if (response.status >= 500 && attempt < maxRetries) {
            console.log(` Retry ${attempt}/${maxRetries} for ${url}`);
            await new Promise(r => setTimeout(r, 1000 * attempt));
            continue;
          }
          return response; // Return non-ok response for caller to handle
        } catch (error) {
          if (attempt === maxRetries) throw error;
          console.log(` Network error, retry ${attempt}/${maxRetries}`);
          await new Promise(r => setTimeout(r, 1000 * attempt));
        }
      }
    }

    // Truncate large results for Claude API
    function truncateForClaude(result, maxItems = 10) {
      if (result.allGames && result.allGames.length > maxItems) {
        const total = result.allGames.length;
        result.allGames = result.allGames.slice(0, maxItems);
        result.liveGames = result.liveGames?.slice(0, 5) || [];
        result.upcomingGames = result.upcomingGames?.slice(0, maxItems) || [];
        result.completedGames = result.completedGames?.slice(0, 3) || [];
        result._truncated = true;
        result._note = `Showing ${maxItems} of ${total} games. Ask for more details if needed.`;
      }
      if (result.teams && result.teams.length > 20) {
        result.teams = result.teams.slice(0, 20);
        result._truncated = true;
      }
      return result;
    }

    // Check if user is online
    function isOnline() {
      return navigator.onLine;
    }

    // Initialize Supabase connection
    async function initSupabase() {
      if (SUPABASE_CONFIG.enabled && SUPABASE_CONFIG.url && SUPABASE_CONFIG.anonKey) {
        try {
          supabaseClient = window.supabase.createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);
          console.log(' Supabase client created');
          
          // Try to get or create test player
          await ensureTestPlayer();
          return true;
        } catch (e) {
          console.error(' Supabase connection failed:', e);
          console.log(' Falling back to localStorage');
          supabaseClient = null;
        }
      } else {
        console.log(' Supabase not configured - using localStorage');
      }
      return false;
    }

    // Ensure we have a test player in Supabase
    async function ensureTestPlayer() {
      if (!supabaseClient) return;
      
      // Check for existing player in localStorage
      const savedPlayerId = localStorage.getItem('betassist_player_id');
      
      if (savedPlayerId) {
        // Verify player exists in Supabase
        try {
          const { data, error } = await supabaseClient
            .from('players')
            .select('id')
            .eq('id', savedPlayerId)
            .single();
          
          if (data && !error) {
            currentPlayerId = savedPlayerId;
            console.log(' Loaded existing player:', currentPlayerId);
            return;
          }
        } catch (e) {
          console.log('Could not verify player, will create new one');
        }
      }
      
      // Create new player using RPC function
      try {
        const { data, error } = await supabaseClient.rpc('create_player_with_defaults', {
          p_username: 'player_' + Date.now(),
          p_country: 'Kenya',
          p_currency: 'ZMW'
        });
        
        if (error) {
          console.error(' Supabase RPC error:', error);
          console.log(' Make sure you ran the SQL schema in Supabase!');
          console.log(' Falling back to localStorage');
          supabaseClient = null;
          return;
        }
        
        if (data) {
          currentPlayerId = data;
          localStorage.setItem('betassist_player_id', data);
          console.log(' Created new player:', currentPlayerId);
        }
      } catch (e) {
        console.error(' Failed to create player:', e);
        console.log(' Falling back to localStorage');
        supabaseClient = null;
      }
    }
    
    // ============================================
    //  COMPREHENSIVE SPORTS COVERAGE - ALL LEAGUES
    // ============================================
    
    const ALL_SPORTS = {
      // ========== SOCCER / FOOTBALL - 60+ LEAGUES ==========
      soccer: {
        name: 'Soccer/Football',
        leagues: {
          // ENGLAND
          'eng.1': 'Premier League', 'eng.2': 'Championship', 'eng.3': 'League One', 'eng.4': 'League Two', 'eng.fa': 'FA Cup', 'eng.league_cup': 'EFL Cup',
          // SPAIN
          'esp.1': 'La Liga', 'esp.2': 'La Liga 2', 'esp.copa_del_rey': 'Copa del Rey',
          // GERMANY
          'ger.1': 'Bundesliga', 'ger.2': '2. Bundesliga', 'ger.dfb_pokal': 'DFB Pokal',
          // ITALY
          'ita.1': 'Serie A', 'ita.2': 'Serie B', 'ita.coppa_italia': 'Coppa Italia',
          // FRANCE
          'fra.1': 'Ligue 1', 'fra.2': 'Ligue 2', 'fra.coupe_de_france': 'Coupe de France',
          // OTHER EUROPE
          'ned.1': 'Eredivisie', 'por.1': 'Primeira Liga', 'bel.1': 'Belgian Pro League', 'sco.1': 'Scottish Premiership',
          'tur.1': 'Süper Lig', 'rus.1': 'Russian Premier League', 'ukr.1': 'Ukrainian Premier League',
          'gre.1': 'Super League Greece', 'sui.1': 'Swiss Super League', 'aut.1': 'Austrian Bundesliga',
          'den.1': 'Danish Superliga', 'nor.1': 'Eliteserien', 'swe.1': 'Allsvenskan', 'pol.1': 'Ekstraklasa',
          'cze.1': 'Czech First League', 'cro.1': 'HNL', 'ser.1': 'Serbian SuperLiga', 'rom.1': 'Liga I',
          // SOUTH AMERICA
          'arg.1': 'Liga Profesional', 'bra.1': 'Brasileirão', 'bra.2': 'Série B', 'col.1': 'Liga BetPlay',
          'chi.1': 'Primera División Chile', 'ecu.1': 'Liga Pro', 'per.1': 'Liga 1 Peru', 'uru.1': 'Primera División Uruguay',
          'par.1': 'Primera División Paraguay', 'ven.1': 'Primera División Venezuela', 'bol.1': 'División Profesional',
          // NORTH/CENTRAL AMERICA
          'usa.1': 'MLS', 'usa.nwsl': 'NWSL', 'mex.1': 'Liga MX', 'mex.2': 'Liga de Expansión',
          'crc.1': 'Primera División Costa Rica', 'hon.1': 'Liga Nacional Honduras',
          // ASIA
          'jpn.1': 'J1 League', 'jpn.2': 'J2 League', 'kor.1': 'K League 1', 'chn.1': 'Chinese Super League',
          'ind.1': 'Indian Super League', 'tha.1': 'Thai League', 'idn.1': 'Liga 1 Indonesia', 'mys.1': 'Malaysia Super League',
          'sau.1': 'Saudi Pro League', 'uae.1': 'UAE Pro League', 'qat.1': 'Qatar Stars League', 'irn.1': 'Persian Gulf Pro League',
          // OCEANIA
          'aus.1': 'A-League', 'nzl.1': 'New Zealand Football Championship',
          // AFRICA
          'rsa.1': 'PSL South Africa', 'egy.1': 'Egyptian Premier League', 'mar.1': 'Botola Pro', 
          'tun.1': 'Tunisian Ligue 1', 'nga.1': 'NPFL Nigeria', 'gha.1': 'Ghana Premier League', 'ken.1': 'Kenyan Premier League',
          // INTERNATIONAL COMPETITIONS
          'uefa.champions': 'UEFA Champions League', 'uefa.europa': 'UEFA Europa League', 'uefa.europa.conf': 'Conference League',
          'conmebol.libertadores': 'Copa Libertadores', 'conmebol.sudamericana': 'Copa Sudamericana',
          'concacaf.champions': 'CONCACAF Champions Cup', 'afc.champions': 'AFC Champions League', 'caf.champions': 'CAF Champions League',
          // INTERNATIONAL TEAMS
          'fifa.world': 'FIFA World Cup', 'fifa.worldq.uefa': 'World Cup Qual - UEFA', 'fifa.worldq.conmebol': 'World Cup Qual - CONMEBOL',
          'fifa.worldq.concacaf': 'World Cup Qual - CONCACAF', 'fifa.worldq.afc': 'World Cup Qual - AFC', 'fifa.worldq.caf': 'World Cup Qual - CAF',
          'uefa.euro': 'UEFA Euro', 'uefa.euro_qual': 'Euro Qualifiers', 'uefa.nations': 'UEFA Nations League',
          'conmebol.america': 'Copa America', 'concacaf.gold': 'CONCACAF Gold Cup', 'concacaf.nations': 'CONCACAF Nations League',
          'caf.nations': 'Africa Cup of Nations', 'afc.asian_cup': 'AFC Asian Cup',
          'fifa.friendly': 'International Friendlies', 'fifa.cwc': 'FIFA Club World Cup',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/soccer',
      },

      // ========== BASKETBALL ==========
      basketball: {
        name: 'Basketball',
        leagues: {
          'nba': 'NBA', 'wnba': 'WNBA', 'nba-g-league': 'NBA G League',
          'mens-college-basketball': 'NCAA Men\'s Basketball', 'womens-college-basketball': 'NCAA Women\'s Basketball',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/basketball',
      },

      // ========== AMERICAN FOOTBALL ==========
      football: {
        name: 'American Football',
        leagues: {
          'nfl': 'NFL', 'college-football': 'NCAA Football', 'xfl': 'XFL', 'cfl': 'CFL', 'ufl': 'UFL',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/football',
      },

      // ========== BASEBALL ==========
      baseball: {
        name: 'Baseball',
        leagues: {
          'mlb': 'MLB', 'college-baseball': 'NCAA Baseball',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/baseball',
      },

      // ========== ICE HOCKEY ==========
      hockey: {
        name: 'Ice Hockey',
        leagues: {
          'nhl': 'NHL', 'mens-college-hockey': 'NCAA Hockey',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/hockey',
      },

      // ========== TENNIS ==========
      tennis: {
        name: 'Tennis',
        leagues: {
          'atp': 'ATP Tour', 'wta': 'WTA Tour',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/tennis',
      },

      // ========== GOLF ==========
      golf: {
        name: 'Golf',
        leagues: {
          'pga': 'PGA Tour', 'lpga': 'LPGA Tour', 'euro': 'DP World Tour', 'liv': 'LIV Golf',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/golf',
      },

      // ========== MMA / COMBAT SPORTS ==========
      mma: {
        name: 'MMA',
        leagues: {
          'ufc': 'UFC', 'pfl': 'PFL', 'bellator': 'Bellator', 'one': 'ONE Championship',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/mma',
      },

      // ========== BOXING ==========
      boxing: {
        name: 'Boxing',
        leagues: {
          'boxing': 'Professional Boxing',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/boxing',
      },

      // ========== RUGBY ==========
      rugby: {
        name: 'Rugby',
        leagues: {
          'super-rugby': 'Super Rugby', 'six-nations': 'Six Nations', 'premiership': 'English Premiership',
          'top14': 'Top 14', 'urc': 'United Rugby Championship', 'mlr': 'Major League Rugby',
          'world-cup': 'Rugby World Cup',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/rugby',
      },

      // ========== CRICKET ==========
      cricket: {
        name: 'Cricket',
        leagues: {
          'ipl': 'IPL', 'bbl': 'Big Bash League', 'psl': 'Pakistan Super League', 'cpl': 'Caribbean Premier League',
          'hundred': 'The Hundred', 'sa20': 'SA20', 'ilt20': 'ILT20',
          't20-world-cup': 'T20 World Cup', 'odi-world-cup': 'ODI World Cup', 'wtc': 'World Test Championship',
          'the-ashes': 'The Ashes', 'icc-test': 'ICC Test Matches', 'icc-odi': 'ICC ODI Matches', 'icc-t20': 'ICC T20 Matches',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/cricket',
      },

      // ========== RACING ==========
      racing: {
        name: 'Racing',
        leagues: {
          'f1': 'Formula 1', 'nascar-cup': 'NASCAR Cup Series', 'nascar-xfinity': 'NASCAR Xfinity', 
          'indycar': 'IndyCar', 'motogp': 'MotoGP', 'wrc': 'World Rally Championship',
          'formula-e': 'Formula E', 'v8-supercars': 'V8 Supercars',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/racing',
      },

      // ========== ESPORTS ==========
      esports: {
        name: 'Esports',
        leagues: {
          'lol': 'League of Legends', 'csgo': 'Counter-Strike', 'dota2': 'Dota 2', 
          'valorant': 'Valorant', 'overwatch': 'Overwatch', 'rocket-league': 'Rocket League',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/esports',
      },

      // ========== AUSTRALIAN RULES ==========
      afl: {
        name: 'Australian Rules Football',
        leagues: {
          'afl': 'AFL',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/australian-football',
      },

      // ========== LACROSSE ==========
      lacrosse: {
        name: 'Lacrosse',
        leagues: {
          'pll': 'Premier Lacrosse League', 'nll': 'National Lacrosse League',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/lacrosse',
      },
    };

    // ============================================
    // DYNAMIC URL BUILDERS
    // ============================================
    
    function buildUrl(sport, league, endpoint = 'scoreboard') {
      const sportConfig = ALL_SPORTS[sport];
      if (!sportConfig) return null;
      return `${sportConfig.baseUrl}/${league}/${endpoint}`;
    }

    function buildTeamsUrl(sport, league) {
      return buildUrl(sport, league, 'teams');
    }

    function buildStandingsUrl(sport, league) {
      const sportConfig = ALL_SPORTS[sport];
      if (!sportConfig) return null;
      return `https://site.api.espn.com/apis/v2/sports/${sport}/${league}/standings`;
    }

    // ============================================
    // LEAGUE ALIASES FOR NATURAL LANGUAGE
    // ============================================
    
    const LEAGUE_ALIASES = {
      // Soccer
      'premier league': { sport: 'soccer', league: 'eng.1' },
      'epl': { sport: 'soccer', league: 'eng.1' },
      'la liga': { sport: 'soccer', league: 'esp.1' },
      'serie a': { sport: 'soccer', league: 'ita.1' },
      'bundesliga': { sport: 'soccer', league: 'ger.1' },
      'ligue 1': { sport: 'soccer', league: 'fra.1' },
      'champions league': { sport: 'soccer', league: 'uefa.champions' },
      'europa league': { sport: 'soccer', league: 'uefa.europa' },
      'mls': { sport: 'soccer', league: 'usa.1' },
      'liga mx': { sport: 'soccer', league: 'mex.1' },
      'brasileirao': { sport: 'soccer', league: 'bra.1' },
      'j league': { sport: 'soccer', league: 'jpn.1' },
      'saudi league': { sport: 'soccer', league: 'sau.1' },
      'eredivisie': { sport: 'soccer', league: 'ned.1' },
      'world cup': { sport: 'soccer', league: 'fifa.world' },
      'copa america': { sport: 'soccer', league: 'conmebol.america' },
      'euros': { sport: 'soccer', league: 'uefa.euro' },
      'afcon': { sport: 'soccer', league: 'caf.nations' },
      // Basketball
      'nba': { sport: 'basketball', league: 'nba' },
      'wnba': { sport: 'basketball', league: 'wnba' },
      'ncaa basketball': { sport: 'basketball', league: 'mens-college-basketball' },
      'march madness': { sport: 'basketball', league: 'mens-college-basketball' },
      // Football
      'nfl': { sport: 'football', league: 'nfl' },
      'college football': { sport: 'football', league: 'college-football' },
      'ncaa football': { sport: 'football', league: 'college-football' },
      // Baseball
      'mlb': { sport: 'baseball', league: 'mlb' },
      // Hockey
      'nhl': { sport: 'hockey', league: 'nhl' },
      // Tennis
      'atp': { sport: 'tennis', league: 'atp' },
      'wta': { sport: 'tennis', league: 'wta' },
      // Golf
      'pga': { sport: 'golf', league: 'pga' },
      'lpga': { sport: 'golf', league: 'lpga' },
      // MMA
      'ufc': { sport: 'mma', league: 'ufc' },
      // Racing
      'f1': { sport: 'racing', league: 'f1' },
      'formula 1': { sport: 'racing', league: 'f1' },
      'nascar': { sport: 'racing', league: 'nascar-cup' },
      'motogp': { sport: 'racing', league: 'motogp' },
      'indycar': { sport: 'racing', league: 'indycar' },
      // Cricket
      'ipl': { sport: 'cricket', league: 'ipl' },
      'big bash': { sport: 'cricket', league: 'bbl' },
      't20 world cup': { sport: 'cricket', league: 't20-world-cup' },
      // Rugby
      'six nations': { sport: 'rugby', league: 'six-nations' },
      'super rugby': { sport: 'rugby', league: 'super-rugby' },
      // AFL
      'afl': { sport: 'afl', league: 'afl' },
    };

    // Resolve league from user input
    function resolveLeague(input) {
      const lower = input.toLowerCase().trim();
      
      // Check direct alias
      if (LEAGUE_ALIASES[lower]) {
        return LEAGUE_ALIASES[lower];
      }
      
      // Check partial matches
      for (const [alias, config] of Object.entries(LEAGUE_ALIASES)) {
        if (lower.includes(alias) || alias.includes(lower)) {
          return config;
        }
      }
      
      // Check ALL_SPORTS leagues
      for (const [sport, config] of Object.entries(ALL_SPORTS)) {
        for (const [leagueId, leagueName] of Object.entries(config.leagues)) {
          if (leagueName.toLowerCase().includes(lower) || lower.includes(leagueName.toLowerCase())) {
            return { sport, league: leagueId };
          }
        }
      }
      
      return null;
    }

    // ============================================
    //  BWANABET.COM CONFIGURATION
    // ============================================
    //  CONFIGURE YOUR BWANABET API ENDPOINTS BELOW 
    
    const BWANABET_CONFIG = {
      // Base URL for bwanabet API
      baseUrl: 'https://bwanabet.com',
      
      // API endpoints - UPDATE THESE with actual bwanabet endpoints
      endpoints: {
        // Odds endpoints
        odds: {
          soccer: '/api/odds/soccer',      // Example: Update with real endpoint
          basketball: '/api/odds/basketball',
          football: '/api/odds/football',
          tennis: '/api/odds/tennis',
          all: '/api/odds/all',
        },
        // Casino endpoints
        casino: {
          games: '/api/casino/games',
          slots: '/api/casino/slots',
          liveDealer: '/api/casino/live-dealer',
          tableGames: '/api/casino/table-games',
          jackpots: '/api/casino/jackpots',
        },
        // Live betting
        liveBetting: '/api/live/events',
      },
      
      // Authentication (if required)
      auth: {
        apiKey: '',           // Add API key if needed
        authHeader: '',       // e.g., 'Authorization' or 'X-API-Key'
      },
      
      // Request headers
      headers: {
        'Content-Type': 'application/json',
        // Add any required headers here
      },
    };

    // ============================================
    // DYNAMIC GAMES FETCHER - ANY SPORT, ANY LEAGUE
    // ============================================

    async function fetchGames(sportOrLeague, leagueId = null) {
      let sport, league;
      
      // Try to resolve from alias first
      const resolved = resolveLeague(sportOrLeague);
      if (resolved) {
        sport = resolved.sport;
        league = resolved.league;
      } else if (leagueId) {
        sport = sportOrLeague;
        league = leagueId;
      } else {
        // Try direct sport lookup with default league
        if (ALL_SPORTS[sportOrLeague]) {
          sport = sportOrLeague;
          league = Object.keys(ALL_SPORTS[sportOrLeague].leagues)[0];
        } else {
          return { 
            error: `Unknown sport/league: ${sportOrLeague}`,
            hint: 'Try "Premier League", "NBA", "La Liga", "UFC", "Champions League", etc.',
            availableSports: Object.keys(ALL_SPORTS),
          };
        }
      }

      // Check cache first
      const cacheKey = `games_${sport}_${league}`;
      const cached = getCachedData(cacheKey);
      if (cached) return cached;

      const url = buildUrl(sport, league, 'scoreboard');
      if (!url) {
        return { error: `Could not build URL for ${sport}/${league}` };
      }

      console.log(` Fetching games from: ${url}`);

      try {
        const response = await fetchWithRetry(url);
        if (!response.ok) throw new Error(`ESPN API error: ${response.status}`);
        
        const data = await response.json();
        const leagueName = ALL_SPORTS[sport]?.leagues[league] || league;
        
        // Transform ESPN data
        const games = (data.events || []).map(event => {
          const competition = event.competitions?.[0];
          const homeTeam = competition?.competitors?.find(c => c.homeAway === 'home');
          const awayTeam = competition?.competitors?.find(c => c.homeAway === 'away');
          
          return {
            id: event.id,
            name: event.name,
            shortName: event.shortName,
            status: {
              state: event.status?.type?.state,
              detail: event.status?.type?.detail,
              clock: event.status?.displayClock,
            },
            homeTeam: homeTeam ? {
              name: homeTeam.team?.displayName,
              abbreviation: homeTeam.team?.abbreviation,
              score: homeTeam.score || '0',
              logo: homeTeam.team?.logo,
            } : null,
            awayTeam: awayTeam ? {
              name: awayTeam.team?.displayName,
              abbreviation: awayTeam.team?.abbreviation,
              score: awayTeam.score || '0',
              logo: awayTeam.team?.logo,
            } : null,
            venue: competition?.venue?.fullName,
            broadcast: competition?.broadcasts?.[0]?.names?.[0],
            startTime: event.date,
          };
        });

        const liveGames = games.filter(g => g.status.state === 'in');
        const upcomingGames = games.filter(g => g.status.state === 'pre');
        const completedGames = games.filter(g => g.status.state === 'post');

        const result = {
          sport: sport,
          league: league,
          leagueName: leagueName,
          totalGames: games.length,
          liveGames,
          upcomingGames,
          completedGames,
          allGames: games,
          fetchedAt: new Date().toISOString(),
        };

        // Cache the result
        setCachedData(cacheKey, result);
        return result;

      } catch (error) {
        console.error('Fetch error:', error);
        return { error: error.message, sport, league };
      }
    }

    // Fetch all teams in a league
    async function fetchLeagueTeams(sportOrLeague, leagueId = null) {
      let sport, league;
      
      const resolved = resolveLeague(sportOrLeague);
      if (resolved) {
        sport = resolved.sport;
        league = resolved.league;
      } else if (leagueId) {
        sport = sportOrLeague;
        league = leagueId;
      } else {
        return { error: `Unknown league: ${sportOrLeague}` };
      }

      // Check cache first
      const cacheKey = `teams_${sport}_${league}`;
      const cached = getCachedData(cacheKey);
      if (cached) return cached;

      const url = buildTeamsUrl(sport, league);
      if (!url) return { error: `Could not build teams URL` };

      try {
        const response = await fetchWithRetry(url);
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        
        const data = await response.json();
        const teams = (data.sports?.[0]?.leagues?.[0]?.teams || []).map(t => ({
          id: t.team.id,
          name: t.team.displayName,
          abbreviation: t.team.abbreviation,
          logo: t.team.logos?.[0]?.href,
        }));

        const result = {
          sport,
          league,
          leagueName: ALL_SPORTS[sport]?.leagues[league],
          teams,
          totalTeams: teams.length,
          fetchedAt: new Date().toISOString(),
        };

        // Cache for longer (5 min) since teams don't change often
        apiCache.set(cacheKey, { data: result, timestamp: Date.now() });
        return result;

      } catch (error) {
        return { error: error.message, sport, league };
      }
    }

    // Search for a team by name across all leagues
    async function searchTeam(teamName) {
      const searchLower = teamName.toLowerCase();
      const results = [];
      
      // Search common leagues
      const searchLeagues = [
        { sport: 'basketball', league: 'nba' },
        { sport: 'football', league: 'nfl' },
        { sport: 'baseball', league: 'mlb' },
        { sport: 'hockey', league: 'nhl' },
        { sport: 'soccer', league: 'eng.1' },
        { sport: 'soccer', league: 'esp.1' },
        { sport: 'soccer', league: 'ger.1' },
        { sport: 'soccer', league: 'ita.1' },
        { sport: 'soccer', league: 'fra.1' },
        { sport: 'soccer', league: 'usa.1' },
      ];

      for (const { sport, league } of searchLeagues) {
        try {
          const url = buildTeamsUrl(sport, league);
          const response = await fetch(url);
          if (!response.ok) continue;
          
          const data = await response.json();
          const teams = data.sports?.[0]?.leagues?.[0]?.teams || [];
          
          for (const t of teams) {
            const name = t.team.displayName?.toLowerCase() || '';
            const abbr = t.team.abbreviation?.toLowerCase() || '';
            if (name.includes(searchLower) || abbr === searchLower || searchLower.includes(name.split(' ').pop())) {
              results.push({
                id: t.team.id,
                name: t.team.displayName,
                abbreviation: t.team.abbreviation,
                sport,
                league,
                leagueName: ALL_SPORTS[sport]?.leagues[league],
                logo: t.team.logos?.[0]?.href,
              });
            }
          }
        } catch (e) {
          continue;
        }
        
        // Limit search to avoid too many requests
        if (results.length >= 5) break;
      }

      return {
        query: teamName,
        results,
        totalFound: results.length,
      };
    }

    // List all available leagues
    function listAvailableLeagues(sportFilter = null) {
      const leagues = [];
      
      for (const [sport, config] of Object.entries(ALL_SPORTS)) {
        if (sportFilter && sport !== sportFilter) continue;
        
        for (const [leagueId, leagueName] of Object.entries(config.leagues)) {
          leagues.push({
            sport,
            sportName: config.name,
            leagueId,
            leagueName,
          });
        }
      }

      return {
        totalLeagues: leagues.length,
        totalSports: sportFilter ? 1 : Object.keys(ALL_SPORTS).length,
        leagues: sportFilter ? leagues : leagues.slice(0, 50), // Limit for readability
        allSports: Object.entries(ALL_SPORTS).map(([id, c]) => ({ id, name: c.name, leagueCount: Object.keys(c.leagues).length })),
      };
    }

    // ============================================
    // STATE
    // ============================================
    
    let conversationHistory = [];
    let isProcessing = false;

    // ============================================
    //  PLAYER DATABASE SCHEMA & PROFILE SYSTEM
    // ============================================

    // Comprehensive player data model (simulates database)
    const DEFAULT_PLAYER_DATA = {
      // === BASIC PROFILE ===
      profile: {
        id: 'player_' + Date.now(),
        username: '',
        country: '',
        city: '',
        language: 'en',
        currency: 'ZMW',
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        createdAt: new Date().toISOString(),
        lastLogin: new Date().toISOString(),
        accountStatus: 'active',
      },

      // === BETTING PREFERENCES ===
      preferences: {
        favoriteSports: [],
        favoriteLeagues: [],
        favoriteTeams: [],
        preferredBetTypes: [],
        preferredOddsFormat: 'decimal',
        preferredStakeRange: { min: 100, max: 5000, average: 500 },
        riskTolerance: 'medium',
        preferredOddsRange: { min: 1.30, max: 5.00 },
        notifications: { matchReminders: true, betSuggestions: true, results: true },
      },

      // === BETTING HISTORY ===
      bettingHistory: {
        lifetime: {
          totalBets: 0,
          totalStaked: 0,
          totalWinnings: 0,
          netProfit: 0,
          winRate: 0,
          averageOdds: 0,
          averageStake: 0,
          biggestWin: 0,
          biggestLoss: 0,
          currentStreak: { type: null, count: 0 },
        },
        bySport: {},
        byBetType: {},
        byLeague: {},
        byTeam: {},
        recentBets: [],
        pendingBets: [],
      },

      // === BEHAVIORAL DATA ===
      behavior: {
        activity: {
          loginFrequency: 'new',
          sessionsThisWeek: 0,
          averageSessionDuration: 0,
          peakActivityTimes: [],
          peakActivityDays: [],
          preferredDevice: 'unknown',
        },
        browsing: {
          leagueViews: {},
          teamViews: {},
          recentSearches: [],
          viewedMatches: [],
        },
        engagement: {
          suggestionsViewed: 0,
          suggestionsAccepted: 0,
          suggestionsDismissed: 0,
        },
      },

      // === FINANCIAL DATA ===
      financial: {
        balance: { available: 0, bonus: 0, pending: 0 },
        limits: {
          dailyDeposit: { set: null, used: 0 },
          dailyLoss: { set: null, used: 0 },
          singleBetMax: null,
        },
        averageDeposit: 0,
      },

      // === RESPONSIBLE GAMBLING ===
      responsibleGambling: {
        riskScore: 1,
        riskFactors: [],
        selfControls: {
          depositLimits: false,
          lossLimits: false,
          sessionTimeLimit: null,
        },
        flags: {
          chasingLosses: false,
          increasingStakes: false,
          lateNightBetting: false,
        },
      },

      // === AI PERSONALIZATION ===
      aiPersonalization: {
        learnedPreferences: {
          profitableTeams: [],
          unprofitableTeams: [],
          profitableBetTypes: [],
          unprofitableBetTypes: [],
          profitableLeagues: [],
          optimalOddsRange: { min: 1.50, max: 3.00 },
        },
        recommendations: {
          accepted: [],
          rejected: [],
          dismissed: [],
          acceptanceRate: 0,
        },
        bestTimeToEngage: null,
        preferredMessageStyle: 'detailed',
      },
    };

    // Load player data from Supabase or localStorage
    async function loadPlayerData() {
      // If Supabase is configured and connected
      if (supabaseClient && currentPlayerId) {
        try {
          console.log(' Fetching player data from Supabase...');
          const { data, error } = await supabaseClient.rpc('get_player_ai_profile', {
            p_player_id: currentPlayerId
          });
          
          if (error) {
            console.error(' Supabase RPC error:', error);
            console.log(' The get_player_ai_profile function may not exist in your database.');
            console.log(' Falling back to localStorage');
          } else if (data) {
            console.log(' Loaded player data from Supabase');
            return transformSupabaseData(data);
          }
        } catch (e) {
          console.error(' Supabase load error:', e);
          console.log(' Falling back to localStorage');
        }
      }
      
      // Fallback to localStorage
      try {
        const saved = localStorage.getItem('betassist_player_data');
        if (saved) {
          console.log(' Loaded player data from localStorage');
          const data = JSON.parse(saved);
          return deepMerge(DEFAULT_PLAYER_DATA, data);
        }
      } catch (e) {
        console.log('Could not load player data from localStorage');
      }
      
      console.log(' Using default player data');
      return JSON.parse(JSON.stringify(DEFAULT_PLAYER_DATA));
    }

    // Transform Supabase data to match our schema
    function transformSupabaseData(supabaseData) {
      return {
        profile: {
          id: supabaseData.profile?.id || '',
          username: supabaseData.profile?.username || '',
          country: supabaseData.profile?.country || '',
          city: supabaseData.profile?.city || '',
          language: supabaseData.profile?.language || 'en',
          currency: supabaseData.profile?.currency || 'ZMW',
          timezone: supabaseData.profile?.timezone || '',
          createdAt: supabaseData.profile?.created_at || new Date().toISOString(),
          lastLogin: supabaseData.profile?.last_login || new Date().toISOString(),
          accountStatus: supabaseData.profile?.account_status || 'active',
        },
        preferences: {
          favoriteSports: supabaseData.preferences?.favorite_sports || [],
          favoriteLeagues: supabaseData.preferences?.favorite_leagues || [],
          favoriteTeams: supabaseData.preferences?.favorite_teams || [],
          preferredBetTypes: supabaseData.preferences?.preferred_bet_types || [],
          preferredOddsFormat: supabaseData.preferences?.odds_format || 'decimal',
          preferredStakeRange: {
            min: supabaseData.preferences?.preferred_stake_min || 100,
            max: supabaseData.preferences?.preferred_stake_max || 5000,
            average: supabaseData.preferences?.preferred_stake_avg || 500,
          },
          riskTolerance: supabaseData.preferences?.risk_tolerance || 'medium',
          preferredOddsRange: {
            min: supabaseData.preferences?.preferred_odds_min || 1.30,
            max: supabaseData.preferences?.preferred_odds_max || 5.00,
          },
        },
        bettingHistory: {
          lifetime: {
            totalBets: supabaseData.stats?.total_bets || 0,
            totalStaked: supabaseData.stats?.total_staked || 0,
            totalWinnings: supabaseData.stats?.total_winnings || 0,
            netProfit: supabaseData.stats?.net_profit || 0,
            winRate: supabaseData.stats?.win_rate || 0,
            averageOdds: supabaseData.stats?.average_odds || 0,
            averageStake: supabaseData.stats?.average_stake || 0,
            biggestWin: supabaseData.stats?.biggest_win || 0,
            biggestLoss: supabaseData.stats?.biggest_loss || 0,
            currentStreak: {
              type: supabaseData.stats?.current_streak_type || null,
              count: supabaseData.stats?.current_streak_count || 0,
            },
          },
          recentBets: supabaseData.recentBets || [],
          bySport: {},
          byLeague: {},
        },
        behavior: {
          activity: {
            loginFrequency: supabaseData.behavior?.login_frequency || 'new',
            sessionsThisWeek: supabaseData.behavior?.sessions_this_week || 0,
          },
          browsing: {
            leagueViews: supabaseData.behavior?.league_views || {},
            teamViews: supabaseData.behavior?.team_views || {},
            recentSearches: supabaseData.behavior?.recent_searches || [],
          },
          engagement: {
            suggestionsViewed: supabaseData.behavior?.suggestions_viewed || 0,
            suggestionsAccepted: supabaseData.behavior?.suggestions_accepted || 0,
            suggestionsDismissed: supabaseData.behavior?.suggestions_dismissed || 0,
          },
        },
        financial: {
          balance: {
            available: supabaseData.financial?.balance_available || 0,
            bonus: supabaseData.financial?.balance_bonus || 0,
            pending: supabaseData.financial?.balance_pending || 0,
          },
          limits: {
            dailyDeposit: { 
              set: supabaseData.financial?.daily_deposit_limit, 
              used: supabaseData.financial?.daily_deposit_used || 0 
            },
            dailyLoss: { 
              set: supabaseData.financial?.daily_loss_limit, 
              used: supabaseData.financial?.daily_loss_used || 0 
            },
          },
        },
        responsibleGambling: {
          riskScore: supabaseData.responsibleGambling?.risk_score || 1,
          riskFactors: supabaseData.responsibleGambling?.risk_factors || [],
          selfControls: {
            depositLimits: supabaseData.responsibleGambling?.deposit_limits_enabled || false,
            lossLimits: supabaseData.responsibleGambling?.loss_limits_enabled || false,
            sessionTimeLimit: supabaseData.responsibleGambling?.session_time_limit,
          },
          flags: {
            chasingLosses: supabaseData.responsibleGambling?.chasing_losses_flag || false,
            increasingStakes: supabaseData.responsibleGambling?.increasing_stakes_flag || false,
            lateNightBetting: supabaseData.responsibleGambling?.late_night_betting_flag || false,
          },
        },
        aiPersonalization: {
          learnedPreferences: {
            profitableTeams: supabaseData.aiData?.profitable_teams || [],
            unprofitableTeams: supabaseData.aiData?.unprofitable_teams || [],
            profitableBetTypes: supabaseData.aiData?.profitable_bet_types || [],
            unprofitableBetTypes: supabaseData.aiData?.unprofitable_bet_types || [],
            profitableLeagues: supabaseData.aiData?.profitable_leagues || [],
            optimalOddsRange: {
              min: supabaseData.aiData?.optimal_odds_min || 1.50,
              max: supabaseData.aiData?.optimal_odds_max || 3.00,
            },
          },
          recommendations: {
            accepted: supabaseData.aiData?.accepted_recommendations || [],
            rejected: supabaseData.aiData?.rejected_recommendations || [],
            dismissed: supabaseData.aiData?.dismissed_recommendations || [],
            acceptanceRate: supabaseData.aiData?.acceptance_rate || 0,
          },
        },
      };
    }

    // Save player data to Supabase or localStorage
    async function savePlayerData() {
      // If Supabase is configured
      if (supabaseClient && currentPlayerId) {
        try {
          // Update preferences
          await supabaseClient.from('player_preferences').update({
            favorite_sports: playerData.preferences.favoriteSports,
            favorite_leagues: playerData.preferences.favoriteLeagues,
            favorite_teams: playerData.preferences.favoriteTeams,
            risk_tolerance: playerData.preferences.riskTolerance,
            preferred_stake_avg: playerData.preferences.preferredStakeRange.average,
            updated_at: new Date().toISOString(),
          }).eq('player_id', currentPlayerId);
          
          // Update behavior
          await supabaseClient.from('player_behavior').update({
            league_views: playerData.behavior.browsing.leagueViews,
            team_views: playerData.behavior.browsing.teamViews,
            suggestions_viewed: playerData.behavior.engagement.suggestionsViewed,
            suggestions_accepted: playerData.behavior.engagement.suggestionsAccepted,
            suggestions_dismissed: playerData.behavior.engagement.suggestionsDismissed,
            updated_at: new Date().toISOString(),
          }).eq('player_id', currentPlayerId);
          
          // Update AI data
          await supabaseClient.from('player_ai_data').update({
            profitable_teams: playerData.aiPersonalization.learnedPreferences.profitableTeams,
            unprofitable_teams: playerData.aiPersonalization.learnedPreferences.unprofitableTeams,
            accepted_recommendations: playerData.aiPersonalization.recommendations.accepted,
            rejected_recommendations: playerData.aiPersonalization.recommendations.rejected,
            dismissed_recommendations: playerData.aiPersonalization.recommendations.dismissed,
            acceptance_rate: playerData.aiPersonalization.recommendations.acceptanceRate,
            updated_at: new Date().toISOString(),
          }).eq('player_id', currentPlayerId);
          
          console.log(' Saved to Supabase');
          return;
        } catch (e) {
          console.error('Supabase save error:', e);
        }
      }
      
      // Fallback to localStorage
      try {
        playerData.profile.lastLogin = new Date().toISOString();
        localStorage.setItem('betassist_player_data', JSON.stringify(playerData));
      } catch (e) {
        console.log('Could not save player data');
      }
    }

    // Debounced version of savePlayerData - prevents too many saves
    function debouncedSavePlayerData() {
      if (saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        savePlayerData();
      }, SAVE_DEBOUNCE);
    }

    // Record a bet to Supabase
    async function recordBetToSupabase(betData) {
      if (!supabaseClient || !currentPlayerId) return;
      
      try {
        await supabaseClient.from('bets').insert({
          player_id: currentPlayerId,
          sport: betData.sport,
          league: betData.league,
          league_name: betData.leagueName,
          match_name: betData.matchName,
          bet_type: betData.betType,
          selection: betData.selection,
          odds: betData.odds,
          stake: betData.stake,
          status: betData.status || 'pending',
        });
        console.log(' Bet recorded to Supabase');
      } catch (e) {
        console.error('Error recording bet:', e);
      }
    }

    // Deep merge helper
    function deepMerge(target, source) {
      const result = { ...target };
      for (const key in source) {
        if (source[key] instanceof Object && key in target) {
          result[key] = deepMerge(target[key], source[key]);
        } else {
          result[key] = source[key];
        }
      }
      return result;
    }

    // Current player data (loaded during initialization)
    let playerData = JSON.parse(JSON.stringify(DEFAULT_PLAYER_DATA));

    // ============================================
    //  PLAYER DATA TRACKING FUNCTIONS
    // ============================================

    // Track league view
    function trackLeagueView(leagueId, leagueName) {
      if (!playerData.behavior.browsing.leagueViews[leagueId]) {
        playerData.behavior.browsing.leagueViews[leagueId] = { name: leagueName, views: 0, lastViewed: null };
      }
      playerData.behavior.browsing.leagueViews[leagueId].views++;
      playerData.behavior.browsing.leagueViews[leagueId].lastViewed = new Date().toISOString();

      // Auto-add to favorites after 3 views
      if (playerData.behavior.browsing.leagueViews[leagueId].views >= 3) {
        const exists = playerData.preferences.favoriteLeagues.find(l => l.id === leagueId);
        if (!exists) {
          playerData.preferences.favoriteLeagues.push({ id: leagueId, name: leagueName, addedAt: new Date().toISOString() });
        }
      }
      debouncedSavePlayerData();
    }

    // Track team view
    function trackTeamView(teamName, leagueId) {
      const key = `${teamName}|${leagueId}`;
      if (!playerData.behavior.browsing.teamViews[key]) {
        playerData.behavior.browsing.teamViews[key] = { team: teamName, league: leagueId, views: 0, lastViewed: null };
      }
      playerData.behavior.browsing.teamViews[key].views++;
      playerData.behavior.browsing.teamViews[key].lastViewed = new Date().toISOString();

      // Auto-add to favorites after 3 views
      if (playerData.behavior.browsing.teamViews[key].views >= 3) {
        const exists = playerData.preferences.favoriteTeams.find(t => t.name === teamName);
        if (!exists) {
          playerData.preferences.favoriteTeams.push({ name: teamName, league: leagueId, addedAt: new Date().toISOString() });
        }
      }
      debouncedSavePlayerData();
    }

    // Record a bet (for history tracking)
    function recordBet(betData) {
      playerData.bettingHistory.recentBets.unshift({
        ...betData,
        id: 'bet_' + Date.now(),
        date: new Date().toISOString(),
      });
      
      // Keep only last 100 bets
      playerData.bettingHistory.recentBets = playerData.bettingHistory.recentBets.slice(0, 100);
      
      // Update lifetime stats
      const lifetime = playerData.bettingHistory.lifetime;
      lifetime.totalBets++;
      lifetime.totalStaked += betData.stake;
      
      if (betData.status === 'won') {
        lifetime.totalWinnings += betData.payout;
        lifetime.netProfit += betData.profit;
        if (betData.profit > lifetime.biggestWin) lifetime.biggestWin = betData.profit;
      } else if (betData.status === 'lost') {
        lifetime.netProfit -= betData.stake;
        if (betData.stake > lifetime.biggestLoss) lifetime.biggestLoss = betData.stake;
      }
      
      lifetime.winRate = playerData.bettingHistory.recentBets.filter(b => b.status === 'won').length / 
                         playerData.bettingHistory.recentBets.filter(b => b.status !== 'pending').length || 0;
      
      savePlayerData();
    }

    // Track suggestion interaction
    function trackSuggestionInteraction(suggestionId, action) {
      playerData.behavior.engagement.suggestionsViewed++;
      
      if (action === 'accepted') {
        playerData.behavior.engagement.suggestionsAccepted++;
        playerData.aiPersonalization.recommendations.accepted.push(suggestionId);
      } else if (action === 'rejected') {
        playerData.aiPersonalization.recommendations.rejected.push(suggestionId);
      } else if (action === 'dismissed') {
        playerData.behavior.engagement.suggestionsDismissed++;
        playerData.aiPersonalization.recommendations.dismissed.push(suggestionId);
      }
      
      // Calculate acceptance rate
      const total = playerData.behavior.engagement.suggestionsViewed;
      const accepted = playerData.behavior.engagement.suggestionsAccepted;
      playerData.aiPersonalization.recommendations.acceptanceRate = total > 0 ? accepted / total : 0;
      
      debouncedSavePlayerData();
    }

    // Update player preferences
    function updatePlayerPreferences(updates) {
      playerData.preferences = deepMerge(playerData.preferences, updates);
      debouncedSavePlayerData();
      return playerData.preferences;
    }

    // Update player profile
    function updatePlayerProfile(updates) {
      playerData.profile = { ...playerData.profile, ...updates };
      debouncedSavePlayerData();
      return playerData.profile;
    }

    // ============================================
    //  AI ANALYSIS FUNCTIONS
    // ============================================

    // Get comprehensive player summary for AI
    function getPlayerSummaryForAI() {
      const topLeagues = Object.entries(playerData.behavior.browsing.leagueViews)
        .sort((a, b) => b[1].views - a[1].views)
        .slice(0, 5)
        .map(([id, data]) => ({ id, name: data.name, views: data.views }));

      const topTeams = Object.entries(playerData.behavior.browsing.teamViews)
        .sort((a, b) => b[1].views - a[1].views)
        .slice(0, 5)
        .map(([key, data]) => ({ name: data.team, league: data.league, views: data.views }));

      return {
        // Profile
        profile: {
          username: playerData.profile.username || 'Player',
          country: playerData.profile.country,
          accountAge: playerData.profile.createdAt,
          lastLogin: playerData.profile.lastLogin,
        },
        
        // Preferences
        preferences: {
          favoriteLeagues: playerData.preferences.favoriteLeagues,
          favoriteTeams: playerData.preferences.favoriteTeams,
          favoriteSports: playerData.preferences.favoriteSports,
          riskTolerance: playerData.preferences.riskTolerance,
          preferredBetTypes: playerData.preferences.preferredBetTypes,
          preferredOddsRange: playerData.preferences.preferredOddsRange,
          preferredStake: playerData.preferences.preferredStakeRange,
        },
        
        // Betting Performance
        performance: {
          totalBets: playerData.bettingHistory.lifetime.totalBets,
          winRate: (playerData.bettingHistory.lifetime.winRate * 100).toFixed(1) + '%',
          netProfit: playerData.bettingHistory.lifetime.netProfit,
          averageStake: playerData.bettingHistory.lifetime.averageStake || playerData.preferences.preferredStakeRange.average,
          currentStreak: playerData.bettingHistory.lifetime.currentStreak,
          biggestWin: playerData.bettingHistory.lifetime.biggestWin,
        },
        
        // Learned Patterns
        patterns: {
          profitableTeams: playerData.aiPersonalization.learnedPreferences.profitableTeams,
          unprofitableTeams: playerData.aiPersonalization.learnedPreferences.unprofitableTeams,
          profitableBetTypes: playerData.aiPersonalization.learnedPreferences.profitableBetTypes,
          profitableLeagues: playerData.aiPersonalization.learnedPreferences.profitableLeagues,
          optimalOddsRange: playerData.aiPersonalization.learnedPreferences.optimalOddsRange,
        },
        
        // Behavior
        behavior: {
          mostViewedLeagues: topLeagues,
          mostViewedTeams: topTeams,
          suggestionAcceptanceRate: (playerData.aiPersonalization.recommendations.acceptanceRate * 100).toFixed(0) + '%',
          totalInteractions: Object.values(playerData.behavior.browsing.leagueViews).reduce((a, b) => a + b.views, 0),
        },
        
        // Responsible Gambling Status
        responsibleGambling: {
          riskScore: playerData.responsibleGambling.riskScore,
          hasLimits: playerData.responsibleGambling.selfControls.depositLimits || playerData.responsibleGambling.selfControls.lossLimits,
          flags: playerData.responsibleGambling.flags,
        },
        
        // Financial Context
        financial: {
          balance: playerData.financial.balance.available,
          dailyLimitRemaining: playerData.financial.limits.dailyDeposit.set 
            ? playerData.financial.limits.dailyDeposit.set - playerData.financial.limits.dailyDeposit.used 
            : 'No limit set',
        },
      };
    }

    // Check if we should show responsible gambling warning
    function checkResponsibleGamblingStatus() {
      const rg = playerData.responsibleGambling;
      const warnings = [];
      
      // Check loss limit
      if (playerData.financial.limits.dailyLoss.set) {
        const remaining = playerData.financial.limits.dailyLoss.set - playerData.financial.limits.dailyLoss.used;
        if (remaining <= 0) {
          warnings.push({ type: 'limit_reached', message: 'You have reached your daily loss limit.' });
        } else if (remaining < playerData.financial.limits.dailyLoss.set * 0.2) {
          warnings.push({ type: 'limit_close', message: `Only ${remaining} remaining of your daily loss limit.` });
        }
      }
      
      // Check for concerning patterns
      if (rg.flags.chasingLosses) {
        warnings.push({ type: 'pattern', message: 'We noticed you may be chasing losses. Consider taking a break.' });
      }
      
      if (rg.riskScore >= 7) {
        warnings.push({ type: 'risk', message: 'Please gamble responsibly. Support: 1-800-522-4700' });
      }
      
      return warnings;
    }

    // Find league name from ID
    function findLeagueName(leagueId) {
      for (const [sport, config] of Object.entries(ALL_SPORTS)) {
        if (config.leagues[leagueId]) {
          return config.leagues[leagueId];
        }
      }
      return leagueId;
    }

    // ============================================
    //  SMART RECOMMENDATIONS ENGINE
    // ============================================

    async function generateRecommendations() {
      const playerSummary = getPlayerSummaryForAI();
      const rgWarnings = checkResponsibleGamblingStatus();
      const recommendations = [];

      // Check responsible gambling first
      if (rgWarnings.some(w => w.type === 'limit_reached')) {
        return {
          playerProfile: playerSummary,
          recommendations: [],
          warning: rgWarnings[0].message,
          message: 'No suggestions available - daily limit reached. Please gamble responsibly.',
        };
      }

      // Get leagues to analyze (favorites first, then most viewed)
      let leaguesToAnalyze = playerData.preferences.favoriteLeagues.map(l => l.id);
      
      // Add most viewed leagues not already in favorites
      const topViewed = Object.entries(playerData.behavior.browsing.leagueViews)
        .sort((a, b) => b[1].views - a[1].views)
        .slice(0, 3)
        .map(([league]) => league);
      
      for (const league of topViewed) {
        if (!leaguesToAnalyze.includes(league)) {
          leaguesToAnalyze.push(league);
        }
      }

      // Default to popular leagues if no history
      if (leaguesToAnalyze.length === 0) {
        leaguesToAnalyze = ['eng.1', 'esp.1', 'nba', 'nfl'];
      }

      // Analyze each league for good betting opportunities
      for (const leagueId of leaguesToAnalyze.slice(0, 4)) {
        try {
          const resolved = resolveLeague(leagueId) || { sport: 'soccer', league: leagueId };
          const gamesData = await fetchGames(leagueId);
          
          if (gamesData.error || !gamesData.upcomingGames) continue;

          // Analyze upcoming games
          for (const game of gamesData.upcomingGames.slice(0, 5)) {
            if (!game.homeTeam || !game.awayTeam) continue;

            // Check if dismissed
            const recId = `rec_${game.id}`;
            if (playerData.aiPersonalization.recommendations.dismissed.includes(recId)) continue;

            // Get team stats for analysis
            const analysis = await analyzeMatchup(game.homeTeam.name, game.awayTeam.name, resolved.league);
            
            if (analysis && analysis.confidence !== 'Low') {
              // Check if favorite team involved
              const favoriteTeamInvolved = playerData.preferences.favoriteTeams.some(
                t => t.name === game.homeTeam.name || t.name === game.awayTeam.name
              );

              // Check if in player's profitable patterns
              const isProfitableTeam = playerData.aiPersonalization.learnedPreferences.profitableTeams.some(
                t => t.team === analysis.favorite
              );

              recommendations.push({
                id: recId,
                type: 'match_recommendation',
                league: leagueId,
                leagueName: gamesData.leagueName,
                match: {
                  home: game.homeTeam.name,
                  away: game.awayTeam.name,
                  startTime: game.startTime,
                  venue: game.venue,
                },
                analysis: analysis,
                personalization: {
                  favoriteTeamInvolved,
                  isProfitableTeam,
                  matchesRiskTolerance: checkRiskTolerance(analysis.favoriteOdds),
                  matchesOddsPreference: checkOddsPreference(parseFloat(analysis.favoriteOdds)),
                },
                reason: generateRecommendationReason(analysis, playerSummary, favoriteTeamInvolved, isProfitableTeam),
                suggestedStake: calculateSuggestedStake(analysis.confidence, parseFloat(analysis.favoriteProb)),
              });
            }
          }
        } catch (e) {
          console.log(`Could not analyze league ${leagueId}:`, e);
        }
      }

      // Sort by personalization score and confidence
      recommendations.sort((a, b) => {
        // Prioritize favorite teams
        if (a.personalization.favoriteTeamInvolved && !b.personalization.favoriteTeamInvolved) return -1;
        if (b.personalization.favoriteTeamInvolved && !a.personalization.favoriteTeamInvolved) return 1;
        
        // Then by confidence
        if (a.analysis.confidence === 'High' && b.analysis.confidence !== 'High') return -1;
        if (b.analysis.confidence === 'High' && a.analysis.confidence !== 'High') return 1;
        
        // Then by probability
        return parseFloat(b.analysis.favoriteProb) - parseFloat(a.analysis.favoriteProb);
      });

      return {
        playerProfile: playerSummary,
        recommendations: recommendations.slice(0, 10),
        warnings: rgWarnings,
        generatedAt: new Date().toISOString(),
        basedOn: leaguesToAnalyze.map(l => findLeagueName(l)),
      };
    }

    // Check if odds match player's risk tolerance
    function checkRiskTolerance(odds) {
      const decimalOdds = parseFloat(odds);
      const tolerance = playerData.preferences.riskTolerance;
      
      switch (tolerance) {
        case 'low': return decimalOdds <= 1.80;
        case 'medium': return decimalOdds >= 1.40 && decimalOdds <= 3.00;
        case 'high': return decimalOdds >= 2.00;
        default: return true;
      }
    }

    // Check if odds are in player's preferred range
    function checkOddsPreference(odds) {
      const range = playerData.preferences.preferredOddsRange;
      return odds >= range.min && odds <= range.max;
    }

    // Calculate suggested stake based on confidence and probability
    function calculateSuggestedStake(confidence, probability) {
      const baseStake = playerData.preferences.preferredStakeRange.average || 500;
      
      let multiplier = 1;
      if (confidence === 'High' && probability > 65) multiplier = 1.2;
      if (confidence === 'Low') multiplier = 0.5;
      
      const suggested = Math.round(baseStake * multiplier / 100) * 100;
      return Math.min(suggested, playerData.preferences.preferredStakeRange.max);
    }

    // Quick matchup analysis for recommendations
    async function analyzeMatchup(homeTeam, awayTeam, league) {
      try {
        // Search for teams
        const homeSearch = await searchTeam(homeTeam);
        const awaySearch = await searchTeam(awayTeam);

        if (homeSearch.totalFound === 0 || awaySearch.totalFound === 0) {
          return null;
        }

        const home = homeSearch.results[0];
        const away = awaySearch.results[0];

        // Get basic stats
        const homeUrl = buildUrl(home.sport, home.league, `teams/${home.id}`);
        const awayUrl = buildUrl(away.sport, away.league, `teams/${away.id}`);

        const [homeRes, awayRes] = await Promise.all([
          fetch(homeUrl).then(r => r.json()).catch(() => null),
          fetch(awayUrl).then(r => r.json()).catch(() => null),
        ]);

        if (!homeRes?.team || !awayRes?.team) return null;

        // Extract records
        const homeRecord = homeRes.team.record?.items?.[0];
        const awayRecord = awayRes.team.record?.items?.[0];

        const homeStats = {};
        const awayStats = {};
        (homeRecord?.stats || []).forEach(s => { homeStats[s.name] = s.value; });
        (awayRecord?.stats || []).forEach(s => { awayStats[s.name] = s.value; });

        const homeWinPct = homeStats.winPercent || 0.5;
        const awayWinPct = awayStats.winPercent || 0.5;

        // Calculate probabilities (home advantage factor)
        const homeAdvantage = 0.05;
        let homeProb = (homeWinPct + homeAdvantage) / (homeWinPct + awayWinPct + homeAdvantage);
        let awayProb = 1 - homeProb;

        // Determine favorite
        const favorite = homeProb > awayProb ? 'home' : 'away';
        const favoriteProb = Math.max(homeProb, awayProb) * 100;
        const favoriteTeam = favorite === 'home' ? homeTeam : awayTeam;
        const favoriteOdds = probabilityToDecimalOdds(Math.max(homeProb, awayProb));

        // Confidence based on data quality and probability difference
        let confidence = 'Medium';
        if (favoriteProb > 65 && homeRecord && awayRecord) confidence = 'High';
        if (favoriteProb < 55 || !homeRecord || !awayRecord) confidence = 'Low';

        return {
          homeTeam,
          awayTeam,
          homeWinPct: (homeWinPct * 100).toFixed(1) + '%',
          awayWinPct: (awayWinPct * 100).toFixed(1) + '%',
          homeProb: (homeProb * 100).toFixed(1) + '%',
          awayProb: (awayProb * 100).toFixed(1) + '%',
          favorite: favoriteTeam,
          favoriteProb: favoriteProb.toFixed(1),
          favoriteOdds,
          confidence,
          homeRecord: homeRecord?.summary || 'N/A',
          awayRecord: awayRecord?.summary || 'N/A',
        };

      } catch (e) {
        console.log('Matchup analysis error:', e);
        return null;
      }
    }

    function probabilityToDecimalOdds(prob) {
      return (1 / prob).toFixed(2);
    }

    function generateRecommendationReason(analysis, profile, favoriteTeamInvolved, isProfitableTeam) {
      const reasons = [];
      
      if (favoriteTeamInvolved) {
        reasons.push(` Your favorite team is playing!`);
      }

      if (isProfitableTeam) {
        reasons.push(` You have a good track record betting on ${analysis.favorite}`);
      }
      
      if (parseFloat(analysis.favoriteProb) > 65) {
        reasons.push(`${analysis.favorite} has a strong ${analysis.favoriteProb}% win probability`);
      }
      
      if (analysis.confidence === 'High') {
        reasons.push('High confidence based on season data');
      }

      if (analysis.homeRecord && analysis.homeRecord !== 'N/A') {
        reasons.push(`Form: ${analysis.homeTeam} (${analysis.homeRecord}) vs ${analysis.awayTeam} (${analysis.awayRecord})`);
      }

      if (reasons.length === 0) {
        reasons.push('Based on current team statistics');
      }

      return reasons.join('. ');
    }

    // Get personalized suggestions for a specific league
    async function getLeagueSuggestions(leagueInput) {
      const resolved = resolveLeague(leagueInput);
      if (!resolved) {
        return { error: `Unknown league: ${leagueInput}` };
      }

      // Track this league view
      const leagueName = ALL_SPORTS[resolved.sport]?.leagues[resolved.league] || leagueInput;
      trackLeagueView(resolved.league, leagueName);

      const gamesData = await fetchGames(leagueInput);
      if (gamesData.error) return gamesData;

      const suggestions = [];
      const rgWarnings = checkResponsibleGamblingStatus();

      // Analyze upcoming games for best opportunities
      for (const game of (gamesData.upcomingGames || []).slice(0, 8)) {
        if (!game.homeTeam || !game.awayTeam) continue;

        const analysis = await analyzeMatchup(game.homeTeam.name, game.awayTeam.name, resolved.league);
        
        if (analysis) {
          // Track team views
          trackTeamView(game.homeTeam.name, resolved.league);
          trackTeamView(game.awayTeam.name, resolved.league);

          // Check personalization factors
          const favoriteTeamInvolved = playerData.preferences.favoriteTeams.some(
            t => t.name === game.homeTeam.name || t.name === game.awayTeam.name
          );

          suggestions.push({
            match: `${game.awayTeam.name} @ ${game.homeTeam.name}`,
            startTime: game.startTime,
            venue: game.venue,
            analysis,
            suggestedBet: analysis.favorite,
            odds: analysis.favoriteOdds,
            confidence: analysis.confidence,
            winProbability: analysis.favoriteProb + '%',
            favoriteTeamInvolved,
            suggestedStake: calculateSuggestedStake(analysis.confidence, parseFloat(analysis.favoriteProb)),
          });
        }
      }

      // Sort by confidence, then favorite team, then probability
      suggestions.sort((a, b) => {
        if (a.favoriteTeamInvolved && !b.favoriteTeamInvolved) return -1;
        if (b.favoriteTeamInvolved && !a.favoriteTeamInvolved) return 1;
        if (a.confidence === 'High' && b.confidence !== 'High') return -1;
        if (b.confidence === 'High' && a.confidence !== 'High') return 1;
        return parseFloat(b.winProbability) - parseFloat(a.winProbability);
      });

      return {
        league: leagueInput,
        leagueName: gamesData.leagueName,
        totalUpcoming: gamesData.upcomingGames?.length || 0,
        suggestions: suggestions.slice(0, 6),
        playerFavorite: playerData.preferences.favoriteLeagues.some(l => l.id === resolved.league),
        warnings: rgWarnings,
        playerContext: {
          riskTolerance: playerData.preferences.riskTolerance,
          preferredStake: playerData.preferences.preferredStakeRange.average,
          favoriteTeamsInLeague: playerData.preferences.favoriteTeams.filter(t => t.league === resolved.league),
        },
        disclaimer: ' These are statistical suggestions based on team performance. Gambling involves risk - never bet more than you can afford to lose.',
      };
    }

    // ============================================
    // TEAM ANALYTICS FUNCTIONS
    // ============================================

    async function fetchTeamStats(teamName, leagueInput = null) {
      // First, search for the team
      const searchResults = await searchTeam(teamName);
      
      if (searchResults.totalFound === 0) {
        return { 
          error: `Team "${teamName}" not found`,
          hint: 'Try the full team name like "Manchester United" or "Los Angeles Lakers"',
        };
      }

      // Use first result or filter by league
      let team = searchResults.results[0];
      if (leagueInput) {
        const resolved = resolveLeague(leagueInput);
        if (resolved) {
          const match = searchResults.results.find(t => t.sport === resolved.sport && t.league === resolved.league);
          if (match) team = match;
        }
      }

      const url = buildUrl(team.sport, team.league, `teams/${team.id}`);
      
      try {
        const response = await fetchWithRetry(url);
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        
        const data = await response.json();
        const teamData = data.team;
        
        // Get record and stats
        const record = teamData.record?.items?.[0];
        const stats = {};
        (record?.stats || []).forEach(s => { stats[s.name] = s.value; });

        // Calculate form from recent results if available, otherwise use season record
        const wins = stats.wins || 0;
        const losses = stats.losses || 0;
        const totalGames = wins + losses;
        const last10Wins = Math.min(wins, 10);
        const last10Losses = Math.min(losses, 10 - last10Wins);

        return {
          team: {
            name: teamData.displayName,
            abbreviation: teamData.abbreviation,
            logo: teamData.logos?.[0]?.href,
            sport: team.sport,
            league: team.league,
            leagueName: ALL_SPORTS[team.sport]?.leagues[team.league],
          },
          record: {
            overall: record?.summary || 'N/A',
            wins: wins,
            losses: losses,
            winPercentage: stats.winPercent ? (stats.winPercent * 100).toFixed(1) + '%' : (totalGames > 0 ? ((wins/totalGames)*100).toFixed(1) + '%' : 'N/A'),
            pointsFor: stats.pointsFor || stats.avgPointsFor || 'N/A',
            pointsAgainst: stats.pointsAgainst || stats.avgPointsAgainst || 'N/A',
          },
          form: {
            last10: totalGames > 0 ? `${last10Wins}-${last10Losses}` : 'N/A',
            streak: stats.streak || 'N/A',
          },
          standings: teamData.standingSummary || 'N/A',
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        return { error: error.message, team: teamName };
      }
    }

    async function fetchHeadToHead(team1Name, team2Name, leagueInput = null) {
      const team1Stats = await fetchTeamStats(team1Name, leagueInput);
      const team2Stats = await fetchTeamStats(team2Name, leagueInput);

      if (team1Stats.error) return { error: `Team 1: ${team1Stats.error}` };
      if (team2Stats.error) return { error: `Team 2: ${team2Stats.error}` };

      const probability = calculateMatchProbability(team1Stats, team2Stats);

      return {
        team1: {
          name: team1Stats?.team?.name || team1Name,
          record: team1Stats?.record?.overall || 'N/A',
          winPct: team1Stats?.record?.winPercentage || 'N/A',
        },
        team2: {
          name: team2Stats?.team?.name || team2Name,
          record: team2Stats?.record?.overall || 'N/A',
          winPct: team2Stats?.record?.winPercentage || 'N/A',
        },
        analysis: probability,
        fetchedAt: new Date().toISOString(),
      };
    }

    async function fetchLeagueStandings(leagueInput) {
      const resolved = resolveLeague(leagueInput);
      if (!resolved) {
        return { error: `Unknown league: ${leagueInput}` };
      }

      const url = buildStandingsUrl(resolved.sport, resolved.league);
      if (!url) return { error: `Standings not available for ${leagueInput}` };

      try {
        const response = await fetchWithRetry(url);
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        
        const data = await response.json();
        const standings = [];

        // Parse standings - structure varies by sport
        const groups = data.children || [data];
        for (const group of groups) {
          const groupName = group.name || '';
          const entries = group.standings?.entries || [];
          
          for (const entry of entries) {
            const team = entry.team;
            const stats = {};
            (entry.stats || []).forEach(s => { stats[s.name] = s.value; });
            
            standings.push({
              group: groupName,
              rank: stats.playoffSeed || stats.rank || 'N/A',
              team: team.displayName,
              played: stats.gamesPlayed || stats.played || 'N/A',
              wins: stats.wins || 0,
              draws: stats.ties || stats.draws || 0,
              losses: stats.losses || 0,
              points: stats.points || 'N/A',
              winPct: stats.winPercent ? (stats.winPercent * 100).toFixed(1) + '%' : 'N/A',
              goalsFor: stats.pointsFor || stats.goalsFor || 'N/A',
              goalsAgainst: stats.pointsAgainst || stats.goalsAgainst || 'N/A',
            });
          }
        }

        return {
          league: leagueInput,
          leagueName: ALL_SPORTS[resolved.sport]?.leagues[resolved.league],
          standings: standings.slice(0, 25),
          totalTeams: standings.length,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        return { error: error.message, league: leagueInput };
      }
    }

    // ============================================
    // PROBABILITY CALCULATION ENGINE
    // ============================================

    function calculateMatchProbability(team1Stats, team2Stats) {
      // Extra safety: if either stats object is null/undefined, return default values
      if (!team1Stats || !team2Stats) {
        return {
          team1Probability: '50.0%',
          team2Probability: '50.0%',
          impliedOdds: {
            team1: { american: '-100', decimal: '2.00' },
            team2: { american: '-100', decimal: '2.00' },
          },
          factors: {
            seasonRecord: { team1: 'N/A', team2: 'N/A', weight: '40%' },
            recentForm: { team1: 'N/A', team2: 'N/A', weight: '30%' },
            efficiency: { team1: 'N/A', team2: 'N/A', weight: '30%' },
          },
          confidence: 'Low',
          disclaimer: ' Insufficient data for probability calculation.',
        };
      }

      try {
        // Safely access nested properties with defaults
        const getFormLast10 = (stats) => stats?.form?.last10 || 'N/A';
        const getWinPct = (stats) => {
          const pct = stats?.record?.winPercentage;
          if (!pct || pct === 'N/A') return 0.5;
          return parseFloat(pct) / 100 || 0.5;
        };
        const getPoints = (stats, type) => {
          const val = stats?.record?.[type];
          if (!val || val === 'N/A') return 100;
          return parseFloat(val) || 100;
        };

        // Extract key metrics with safe defaults
        const t1 = {
          winPct: getWinPct(team1Stats),
          form: parseFormPercentage(getFormLast10(team1Stats)),
          ppg: getPoints(team1Stats, 'pointsFor'),
          papg: getPoints(team1Stats, 'pointsAgainst'),
        };
        
        const t2 = {
          winPct: getWinPct(team2Stats),
          form: parseFormPercentage(getFormLast10(team2Stats)),
          ppg: getPoints(team2Stats, 'pointsFor'),
          papg: getPoints(team2Stats, 'pointsAgainst'),
        };

      // Calculate various probability factors
      
      // 1. Win percentage factor (40% weight)
      const winPctFactor = t1.winPct / (t1.winPct + t2.winPct);
      
      // 2. Recent form factor (30% weight)
      const formFactor = t1.form / (t1.form + t2.form + 0.001);
      
      // 3. Offensive/Defensive efficiency (30% weight)
      const t1Efficiency = t1.ppg / (t1.papg + 0.001);
      const t2Efficiency = t2.ppg / (t2.papg + 0.001);
      const efficiencyFactor = t1Efficiency / (t1Efficiency + t2Efficiency);

      // Weighted probability
      const team1Prob = (winPctFactor * 0.4) + (formFactor * 0.3) + (efficiencyFactor * 0.3);
      const team2Prob = 1 - team1Prob;

      // Convert to odds
      const team1Odds = probabilityToAmericanOdds(team1Prob);
      const team2Odds = probabilityToAmericanOdds(team2Prob);
      const team1Decimal = (1 / team1Prob).toFixed(2);
      const team2Decimal = (1 / team2Prob).toFixed(2);

      // Confidence level based on data quality
      const confidence = calculateConfidence(team1Stats, team2Stats);

      return {
        team1Probability: (team1Prob * 100).toFixed(1) + '%',
        team2Probability: (team2Prob * 100).toFixed(1) + '%',
        impliedOdds: {
          team1: {
            american: team1Odds,
            decimal: team1Decimal,
          },
          team2: {
            american: team2Odds,
            decimal: team2Decimal,
          },
        },
        factors: {
          seasonRecord: {
            team1: team1Stats?.record?.winPercentage || 'N/A',
            team2: team2Stats?.record?.winPercentage || 'N/A',
            weight: '40%',
          },
          recentForm: {
            team1: team1Stats?.form?.last10 || 'N/A',
            team2: team2Stats?.form?.last10 || 'N/A',
            weight: '30%',
          },
          efficiency: {
            team1: `${t1.ppg.toFixed(1)} PPG / ${t1.papg.toFixed(1)} PAPG`,
            team2: `${t2.ppg.toFixed(1)} PPG / ${t2.papg.toFixed(1)} PAPG`,
            weight: '30%',
          },
        },
        confidence: confidence,
        disclaimer: ' These probabilities are estimates based on available statistics. Gambling involves risk and past performance does not guarantee future results.',
      };
      } catch (e) {
        console.error('Error in calculateMatchProbability:', e);
        return {
          team1Probability: '50.0%',
          team2Probability: '50.0%',
          impliedOdds: {
            team1: { american: '-100', decimal: '2.00' },
            team2: { american: '-100', decimal: '2.00' },
          },
          factors: {
            seasonRecord: { team1: 'N/A', team2: 'N/A', weight: '40%' },
            recentForm: { team1: 'N/A', team2: 'N/A', weight: '30%' },
            efficiency: { team1: 'N/A', team2: 'N/A', weight: '30%' },
          },
          confidence: 'Low',
          disclaimer: ' Error calculating probabilities.',
        };
      }
    }

    function parseFormPercentage(form) {
      if (!form || form === 'N/A') return 0.5;
      const parts = form.split('-');
      if (parts.length !== 2) return 0.5;
      const wins = parseInt(parts[0]) || 0;
      const total = wins + (parseInt(parts[1]) || 0);
      return total > 0 ? wins / total : 0.5;
    }

    function probabilityToAmericanOdds(prob) {
      if (prob >= 0.5) {
        const odds = Math.round(-(prob / (1 - prob)) * 100);
        return odds;
      } else {
        const odds = Math.round(((1 - prob) / prob) * 100);
        return '+' + odds;
      }
    }

    function calculateConfidence(team1Stats, team2Stats) {
      // Safety check
      if (!team1Stats || !team2Stats) return 'Low';
      
      let score = 0;
      
      try {
        // Check data availability with safe access
        if (team1Stats?.record?.winPercentage && team1Stats.record.winPercentage !== 'N/A') score += 25;
        if (team2Stats?.record?.winPercentage && team2Stats.record.winPercentage !== 'N/A') score += 25;
        if (team1Stats?.form?.last10 && team1Stats.form.last10 !== 'N/A') score += 15;
        if (team2Stats?.form?.last10 && team2Stats.form.last10 !== 'N/A') score += 15;
        if (team1Stats?.record?.pointsFor && team1Stats.record.pointsFor !== 'N/A') score += 10;
        if (team2Stats?.record?.pointsFor && team2Stats.record.pointsFor !== 'N/A') score += 10;
      } catch (e) {
        console.error('Error in calculateConfidence:', e);
        return 'Low';
      }

      if (score >= 80) return 'High';
      if (score >= 50) return 'Medium';
      return 'Low';
    }

    // Calculate payout
    function calculatePayout(odds, stake) {
      let profit;
      if (odds > 0) {
        profit = (stake * odds) / 100;
      } else {
        profit = (stake * 100) / Math.abs(odds);
      }
      
      const impliedProb = odds > 0 
        ? 100 / (odds + 100) 
        : Math.abs(odds) / (Math.abs(odds) + 100);

      return {
        odds: odds,
        stake: stake,
        profit: profit.toFixed(2),
        totalReturn: (stake + profit).toFixed(2),
        impliedProbability: (impliedProb * 100).toFixed(1) + '%',
      };
    }

    // ============================================
    // BWANABET API FUNCTIONS
    // ============================================

    async function fetchBwanabetOdds(sport = 'all') {
      const endpoint = BWANABET_CONFIG.endpoints.odds[sport] || BWANABET_CONFIG.endpoints.odds.all;
      const url = BWANABET_CONFIG.baseUrl + endpoint;
      
      console.log(` Fetching odds from bwanabet: ${url}`);
      
      try {
        const headers = { ...BWANABET_CONFIG.headers };
        
        // Add auth header if configured
        if (BWANABET_CONFIG.auth.apiKey && BWANABET_CONFIG.auth.authHeader) {
          headers[BWANABET_CONFIG.auth.authHeader] = BWANABET_CONFIG.auth.apiKey;
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: headers,
          mode: 'cors', // May need to adjust based on bwanabet's CORS policy
        });

        if (!response.ok) {
          throw new Error(`Bwanabet API error: ${response.status}`);
        }

        const data = await response.json();
        
        return {
          source: 'bwanabet.com',
          sport: sport,
          data: data,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        console.error('Bwanabet odds fetch error:', error);
        
        // Return mock/fallback data for demo purposes
        return {
          source: 'bwanabet.com',
          sport: sport,
          error: error.message,
          note: 'Could not fetch from bwanabet.com. Check CORS settings or API endpoint configuration.',
          // Fallback demo data
          fallbackData: {
            message: 'Configure BWANABET_CONFIG with correct API endpoints to fetch live odds.',
            exampleOdds: [
              { match: 'Team A vs Team B', homeOdds: 1.85, drawOdds: 3.40, awayOdds: 4.20 },
              { match: 'Team C vs Team D', homeOdds: 2.10, drawOdds: 3.25, awayOdds: 3.50 },
            ]
          },
          fetchedAt: new Date().toISOString(),
        };
      }
    }

    async function fetchBwanabetCasinoGames(category = 'all') {
      let endpoint;
      switch(category) {
        case 'slots': endpoint = BWANABET_CONFIG.endpoints.casino.slots; break;
        case 'live': endpoint = BWANABET_CONFIG.endpoints.casino.liveDealer; break;
        case 'table': endpoint = BWANABET_CONFIG.endpoints.casino.tableGames; break;
        case 'jackpots': endpoint = BWANABET_CONFIG.endpoints.casino.jackpots; break;
        default: endpoint = BWANABET_CONFIG.endpoints.casino.games;
      }
      
      const url = BWANABET_CONFIG.baseUrl + endpoint;
      console.log(` Fetching casino games from bwanabet: ${url}`);
      
      try {
        const headers = { ...BWANABET_CONFIG.headers };
        
        if (BWANABET_CONFIG.auth.apiKey && BWANABET_CONFIG.auth.authHeader) {
          headers[BWANABET_CONFIG.auth.authHeader] = BWANABET_CONFIG.auth.apiKey;
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: headers,
          mode: 'cors',
        });

        if (!response.ok) {
          throw new Error(`Bwanabet Casino API error: ${response.status}`);
        }

        const data = await response.json();
        
        return {
          source: 'bwanabet.com',
          category: category,
          games: data,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        console.error('Bwanabet casino fetch error:', error);
        
        // Return fallback casino data
        return {
          source: 'bwanabet.com',
          category: category,
          error: error.message,
          note: 'Could not fetch from bwanabet.com. Check API endpoint configuration.',
          // Fallback demo data showing what structure we expect
          fallbackData: {
            message: 'Configure BWANABET_CONFIG with correct API endpoints to fetch live casino games.',
            exampleGames: [
              { name: 'Blackjack Classic', category: 'table', rtp: '99.5%', provider: 'Evolution' },
              { name: 'European Roulette', category: 'table', rtp: '97.3%', provider: 'Pragmatic' },
              { name: 'Mega Fortune', category: 'slots', rtp: '96.6%', jackpot: true },
              { name: 'Live Baccarat', category: 'live', rtp: '98.9%', provider: 'Evolution' },
            ]
          },
          fetchedAt: new Date().toISOString(),
        };
      }
    }

    async function fetchBwanabetLiveBetting() {
      const url = BWANABET_CONFIG.baseUrl + BWANABET_CONFIG.endpoints.liveBetting;
      console.log(` Fetching live betting from bwanabet: ${url}`);
      
      try {
        const headers = { ...BWANABET_CONFIG.headers };
        
        if (BWANABET_CONFIG.auth.apiKey && BWANABET_CONFIG.auth.authHeader) {
          headers[BWANABET_CONFIG.auth.authHeader] = BWANABET_CONFIG.auth.apiKey;
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: headers,
          mode: 'cors',
        });

        if (!response.ok) {
          throw new Error(`Bwanabet Live API error: ${response.status}`);
        }

        const data = await response.json();
        
        return {
          source: 'bwanabet.com',
          type: 'live_betting',
          events: data,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        console.error('Bwanabet live betting fetch error:', error);
        
        return {
          source: 'bwanabet.com',
          type: 'live_betting',
          error: error.message,
          note: 'Could not fetch live betting data. Check API configuration.',
          fallbackData: {
            message: 'Configure BWANABET_CONFIG to fetch live betting events.',
          },
          fetchedAt: new Date().toISOString(),
        };
      }
    }

    // ============================================
    // TOOL DEFINITIONS FOR CLAUDE
    // ============================================

    const tools = [
      {
        name: 'get_player_profile',
        description: 'Get the current player\'s profile including their favorite leagues, teams, viewing history, and preferences. Use this to personalize recommendations.',
        input_schema: {
          type: 'object',
          properties: {},
          required: [],
        },
      },
      {
        name: 'update_player_preferences',
        description: 'Update the player\'s preferences like favorite leagues, teams, risk tolerance, etc.',
        input_schema: {
          type: 'object',
          properties: {
            favoriteLeagues: {
              type: 'array',
              items: { type: 'string' },
              description: 'List of favorite league IDs (e.g., ["eng.1", "esp.1"])',
            },
            favoriteTeams: {
              type: 'array',
              items: { type: 'object' },
              description: 'List of favorite teams [{name, league}]',
            },
            riskTolerance: {
              type: 'string',
              enum: ['low', 'medium', 'high'],
              description: 'Player\'s risk tolerance for betting suggestions',
            },
          },
          required: [],
        },
      },
      {
        name: 'get_recommendations',
        description: 'Generate personalized betting recommendations based on the player\'s favorite leagues and viewing history. Returns matches with high win probability.',
        input_schema: {
          type: 'object',
          properties: {},
          required: [],
        },
      },
      {
        name: 'get_league_suggestions',
        description: 'Get smart betting suggestions for a specific league. Analyzes upcoming matches and identifies games where one team has a statistical advantage.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league to get suggestions for (e.g., "Premier League", "La Liga")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'get_games',
        description: 'Fetch live, upcoming, and completed games for ANY sport or league worldwide. Supports 100+ leagues including Premier League, La Liga, Serie A, Bundesliga, Champions League, NBA, NFL, MLB, NHL, UFC, F1, Cricket IPL, and many more.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league name (e.g., "Premier League", "NBA", "La Liga", "Champions League", "UFC", "F1", "IPL")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'list_leagues',
        description: 'List all available sports and leagues. Use this when users ask what sports/leagues are available or want to browse options.',
        input_schema: {
          type: 'object',
          properties: {
            sport: {
              type: 'string',
              description: 'Optional: filter by sport (soccer, basketball, football, baseball, hockey, tennis, golf, mma, boxing, rugby, cricket, racing, esports)',
            }
          },
          required: [],
        },
      },
      {
        name: 'search_team',
        description: 'Search for a team by name across all leagues. Use this to find team information when the user mentions a team name.',
        input_schema: {
          type: 'object',
          properties: {
            team_name: {
              type: 'string',
              description: 'The team name to search for (e.g., "Manchester United", "Lakers", "Real Madrid")',
            }
          },
          required: ['team_name'],
        },
      },
      {
        name: 'get_league_teams',
        description: 'Get all teams in a specific league. Use this when users want to see all teams in a competition.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league name (e.g., "Premier League", "NBA", "Serie A")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'get_team_stats',
        description: 'Fetch detailed statistics for a specific team including record, win percentage, recent form, and roster.',
        input_schema: {
          type: 'object',
          properties: {
            team_name: {
              type: 'string',
              description: 'The team name',
            },
            league: {
              type: 'string',
              description: 'Optional: specify the league if team name is ambiguous',
            }
          },
          required: ['team_name'],
        },
      },
      {
        name: 'get_head_to_head',
        description: 'Compare two teams and calculate win probabilities based on their statistics.',
        input_schema: {
          type: 'object',
          properties: {
            team1: {
              type: 'string',
              description: 'First team name',
            },
            team2: {
              type: 'string',
              description: 'Second team name',
            },
            league: {
              type: 'string',
              description: 'Optional: specify league',
            }
          },
          required: ['team1', 'team2'],
        },
      },
      {
        name: 'get_standings',
        description: 'Fetch current league standings/table with team rankings.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league name (e.g., "Premier League", "NBA", "La Liga")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'get_bwanabet_odds',
        description: 'Fetch betting odds from bwanabet.com for any sport.',
        input_schema: {
          type: 'object',
          properties: {
            sport: {
              type: 'string',
              description: 'The sport to get odds for',
            }
          },
          required: ['sport'],
        },
      },
      {
        name: 'get_bwanabet_casino_games',
        description: 'Fetch casino games from bwanabet.com.',
        input_schema: {
          type: 'object',
          properties: {
            category: {
              type: 'string',
              description: 'Category: all, slots, table, live, jackpots',
            }
          },
          required: ['category'],
        },
      },
      {
        name: 'calculate_bet_payout',
        description: 'Calculate potential payout for a bet.',
        input_schema: {
          type: 'object',
          properties: {
            odds: {
              type: 'number',
              description: 'The odds (American or Decimal)',
            },
            stake: {
              type: 'number',
              description: 'Bet amount',
            },
          },
          required: ['odds', 'stake'],
        },
      },
    ];

    // Execute tool calls
    async function executeTool(toolName, toolInput) {
      console.log(` Executing tool: ${toolName}`, toolInput);
      
      let result;
      
      switch (toolName) {
        case 'get_player_profile':
          result = getPlayerSummaryForAI();
          break;
        case 'update_player_preferences':
          result = updatePlayerPreferences(toolInput);
          break;
        case 'get_recommendations':
          result = await generateRecommendations();
          break;
        case 'get_league_suggestions':
          result = await getLeagueSuggestions(toolInput.league);
          break;
        case 'get_games':
          result = await fetchGames(toolInput.league);
          break;
        case 'list_leagues':
          result = listAvailableLeagues(toolInput.sport);
          break;
        case 'search_team':
          result = await searchTeam(toolInput.team_name);
          break;
        case 'get_league_teams':
          result = await fetchLeagueTeams(toolInput.league);
          break;
        case 'get_team_stats':
          result = await fetchTeamStats(toolInput.team_name, toolInput.league);
          break;
        case 'get_head_to_head':
          result = await fetchHeadToHead(toolInput.team1, toolInput.team2, toolInput.league);
          break;
        case 'get_standings':
          result = await fetchLeagueStandings(toolInput.league);
          break;
        case 'get_bwanabet_odds':
          result = await fetchBwanabetOdds(toolInput.sport);
          break;
        case 'get_bwanabet_casino_games':
          result = await fetchBwanabetCasinoGames(toolInput.category);
          break;
        case 'calculate_bet_payout':
          result = calculatePayout(toolInput.odds, toolInput.stake);
          break;
        default:
          result = { error: `Unknown tool: ${toolName}` };
      }
      
      // Truncate large results to save tokens and improve response time
      return truncateForClaude(result);
    }

    // ============================================
    // SYSTEM PROMPT
    // ============================================

    const SYSTEM_PROMPT = `You are BetAssist, an expert AI sports betting and casino analyst for Bwanabet. You provide data-driven analysis and recommendations.

## PERSONALITY

- **Address the user as "Bwana"** (e.g., "Bwana, my analysis indicates...", "Recommendation for Bwana:")
- **Be professional, analytical, and precise** - like an expert robot analyst
- **NO emojis** - never use any emojis in responses
- **Keep responses concise** - deliver data efficiently, 2-4 sentences max
- **Never ask questions at the end** - instead, provide actionable recommendations
- **Never say** "I'm an AI" or "As an AI assistant"
- **Sound confident and data-driven** - use phrases like "Analysis complete", "Data indicates", "Recommendation:", "Probability assessment:"

## SIMPLE LANGUAGE

Many users don't speak English well. Use simple, clear language:

**DON'T use abbreviations:**
- EPL = "Premier League"
- UCL = "Champions League"  
- BTTS = "Both Teams Score"
- RTP = "payout rate"

**Betting terms are OK** - Double Chance, Over/Under, Handicap, Clean Sheet

## CURRENCY

- **ONLY use Zambian Kwacha (ZMW)** for all amounts
- Format: ZMW 500, ZMW 1,000, etc.

## PLAYER DATA ACCESS

You have access to player data via \`get_player_profile\`:
- Favorite leagues & teams
- Betting history & win rate
- Risk tolerance
- Bonuses available
- Daily limits

## BONUSES

When relevant, note available bonuses:
- "Note: Bonus balance available for this bet."
- "Reminder: Free bet can be applied here."

## STRATEGIES

Provide betting strategies when asked:
- **Sports**: Value betting, bankroll management, form analysis, in-play tips
- **Casino**: Martingale, Paroli, bankroll limits, game-specific tips

**ALWAYS add disclaimer**: "Reminder: No strategy guarantees wins. Gamble responsibly."

## RESPONSE FORMAT

**Be direct and analytical:**

WRONG (too casual):
"Hey Bwana! Got a hot pick for you - Liverpool looking strong today!"

CORRECT (analytical):
"Bwana, analysis complete. Liverpool shows 75% win probability based on current form. Recommendation: Match Result - Liverpool to win."

## MATCH RECOMMENDATIONS - ALWAYS SHOW 5 BET OPTIONS

**CRITICAL: When recommending bets for a match, ALWAYS provide 5 DIFFERENT bet types.**

**IMPORTANT RULES:**
- Do NOT mention odds unless Bwana asks about odds
- Do NOT mention stake amounts unless Bwana asks about stakes
- Use "betslip" instead of "parlay"
- Use percentages for confidence levels
- NO follow-up questions - provide recommendations instead

**Format for match recommendations:**

"Analysis: **[Home] vs [Away]**

1. **Match Result**: [Team] to win - [confidence]% probability
2. **Double Chance**: [Team] or Draw - [confidence]% probability
3. **Over/Under 2.5 Goals**: Over 2.5 - [confidence]% probability
4. **Both Teams Score**: Yes - [confidence]% probability
5. **Corners**: Over 9.5 - [confidence]% probability

**Primary Recommendation**: [Best option with data-driven reason]"

**Available bet types:**
- Match Result (1X2)
- Double Chance
- Over/Under Goals (1.5, 2.5, 3.5)
- Both Teams to Score
- Corners (Over/Under)
- Cards (Over/Under)
- First Half Result
- Handicap
- Clean Sheet

**Confidence levels:**
- 70%+ = High probability
- 55-69% = Moderate probability
- Below 55% = Lower probability, higher risk

## CASINO GAMES

Also help with casino games:
- Slots, Roulette, Blackjack, Poker
- Explain game mechanics clearly
- Provide strategies WITH disclaimers
- Note available bonuses

## RESPONSIBLE GAMBLING

- If player is on a losing streak, recommend caution
- If limits reached, inform them
- Never push bets
- Support line: 1-800-522-4700

##  COVERAGE

100+ leagues: Premier League, La Liga, Serie A, Bundesliga, Champions League, NBA, NFL, MLB, NHL, UFC, F1, Cricket & more!

##  SPEED - RESPOND FAST!

**IMPORTANT: Only use tools when absolutely necessary!**

Answer these WITHOUT tools (instant response):
- Greetings: "Hey Bwana!" "How are you?"
- Strategy questions: "What's the best betting strategy?"
- Casino explanations: "How do I play blackjack?"
- General questions: "What sports do you cover?"
- Encouragement: "I lost my bet" → Be supportive
- Bonuses: "What bonuses do I have?" → Check profile memory

Only use tools for:
- Specific live game data: "What's the score of the Liverpool game?"
- Today's matches: "What games are on today?"
- Specific recommendations: "Give me Premier League picks"
- Team stats: "How is Manchester United doing?"

Remember: Be Bwana's helpful friend, always show 5 bet options, sound human! `;

    // ============================================
    // CLAUDE API WITH TOOL CALLING
    // ============================================

    // Helper function to call Claude via Supabase proxy
    async function callClaudeProxy(messages, system, tools) {
      const response = await fetch(SUPABASE_CONFIG.claudeProxyUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${SUPABASE_CONFIG.anonKey}`,
        },
        body: JSON.stringify({ messages, system, tools })
      });

      if (!response.ok) {
        const error = await response.json();
        console.error(' Proxy Error:', error);
        throw new Error(error.error?.message || `Proxy request failed with status ${response.status}`);
      }

      return await response.json();
    }

    async function callClaudeWithTools(userMessage) {
      conversationHistory.push({
        role: 'user',
        content: userMessage
      });

      console.log(' Sending message via Supabase proxy...');
      console.log(' Message:', userMessage);

      try {
        let data = await callClaudeProxy(conversationHistory, SYSTEM_PROMPT, tools);
        console.log(' Response received:', data.stop_reason);
        
        // Handle tool use loop
        while (data.stop_reason === 'tool_use') {
          const toolUseBlocks = data.content.filter(block => block.type === 'tool_use');
          
          // Add assistant's response (with tool calls) to history
          conversationHistory.push({
            role: 'assistant',
            content: data.content
          });

          //  SPEED: Execute ALL tools in PARALLEL instead of sequentially
          updateTypingStatus('Typing...');
          console.log(` Executing ${toolUseBlocks.length} tools in parallel...`);
          
          const toolPromises = toolUseBlocks.map(async (toolUse) => {
            const result = await executeTool(toolUse.name, toolUse.input);
            console.log(` Tool ${toolUse.name} complete`);
            return {
              type: 'tool_result',
              tool_use_id: toolUse.id,
              content: JSON.stringify(result, null, 2)
            };
          });

          // Wait for ALL tools to complete at once
          const toolResults = await Promise.all(toolPromises);

          // Add tool results to history
          conversationHistory.push({
            role: 'user',
            content: toolResults
          });

          updateTypingStatus('Typing...');

          // Continue conversation with tool results
          data = await callClaudeProxy(conversationHistory, SYSTEM_PROMPT, tools);
        }

        // Extract final text response
        const textContent = data.content
          .filter(block => block.type === 'text')
          .map(block => block.text)
          .join('\n');

        // Add final response to history
        conversationHistory.push({
          role: 'assistant',
          content: textContent
        });

        // Keep history manageable
        if (conversationHistory.length > 30) {
          conversationHistory = conversationHistory.slice(-30);
        }

        return textContent;

      } catch (error) {
        console.error('Claude API error:', error);
        conversationHistory.pop(); // Remove failed message
        
        if (error.message.includes('Invalid API Key') || error.message.includes('authentication')) {
          return '**Authentication Error**\n\nBwana, API key validation failed. Verify configuration.';
        }
        
        return `**System Error**\n\nBwana, processing failed: ${error.message}`;
      }
    }

    // ============================================
    // UI FUNCTIONS
    // ============================================

    function updateTypingStatus(status) {
      document.getElementById('typingStatus').textContent = status;
    }

    function clearChat() {
      conversationHistory = [];
      document.getElementById('messages').innerHTML = '';
      addMessage(`**System Reset**\n\nBwana, chat history cleared. System ready for new analysis requests.`, false);
    }

    async function sendMessage() {
      if (isProcessing) return;
      
      // Check if online
      if (!isOnline()) {
        addMessage("Bwana, network connection lost. Verify internet connectivity and retry.", false, [
          { text: 'Retry', action: 'hi' },
        ]);
        return;
      }
      
      // Rate limiting - prevent spam
      const now = Date.now();
      if (now - lastMessageTime < MESSAGE_COOLDOWN) {
        console.log('⏳ Please wait before sending another message');
        return;
      }
      lastMessageTime = now;
      
      const input = document.getElementById('messageInput');
      const message = input.value.trim();
      
      if (!message) return;
      
      input.value = '';
      addMessage(message, true);
      
      //  INSTANT RESPONSES - No API call needed for simple messages!
      const instantResult = getInstantResponse(message);
      if (instantResult) {
        console.log(' Instant response (no API call)');
        setTimeout(() => {
          addMessage(instantResult.response, false, instantResult.quickActions || []);
        }, 300); // Small delay feels natural
        return;
      }
      
      // Check session time and remind user to take breaks
      const sessionMinutes = (now - sessionStart) / 60000;
      if (sessionMinutes > 60 && !sessionWarningShown) {
        sessionWarningShown = true;
        setTimeout(() => {
          addMessage("Bwana, session duration exceeds 60 minutes. Reminder: Take regular breaks. Gamble responsibly.", false, [
            { text: 'Acknowledged', action: 'thanks' },
            { text: 'More analysis', action: 'give me tips' },
          ]);
        }, 500);
      }
      
      isProcessing = true;
      document.getElementById('sendButton').disabled = true;
      document.getElementById('typingIndicator').classList.remove('hidden');
      updateTypingStatus('Typing...');
      
      try {
        const response = await callClaudeWithTools(message);
        // Generate smart quick actions based on AI's response AND user's message
        const smartActions = generateSmartQuickActions(message, response);
        addMessage(response, false, smartActions);
      } catch (error) {
        console.error('Error in sendMessage:', error);
        addMessage(`**Processing Error**\n\nBwana, request failed: ${error.message}\n\nConsult browser console for diagnostics.`, false, [
          { text: 'Retry', action: message },
          { text: 'Help', action: 'help' },
        ]);
      } finally {
        isProcessing = false;
        document.getElementById('sendButton').disabled = false;
        document.getElementById('typingIndicator').classList.add('hidden');
        updateTypingStatus('');
      }
    }

    //  INSTANT RESPONSES - Handle common messages without API calls
    // ============================================
    //  CASINO GAME STRATEGIES DATABASE
    // ============================================
    
    const CASINO_STRATEGIES = {
      aviator: {
        name: "Aviator",
        type: "Crash Game",
        description: "Watch the multiplier rise and cash out before the plane crashes!",
        howToPlay: [
          "1. Place your bet before the round starts",
          "2. Watch the plane take off - the multiplier increases as it flies",
          "3. Click 'Cash Out' anytime to collect your bet × the current multiplier",
          "4. If the plane crashes before you cash out, you lose your bet",
          "5. The crash point is random each round (could be 1.01x or 100x+)",
        ],
        strategies: [
          "**Low Risk Strategy**: Cash out early at 1.2x-1.5x. Small wins, but consistent.",
          "**Medium Risk**: Target 2x-3x multiplier. Good balance of risk/reward.",
          "**Auto Cash-Out**: Set automatic cash-out at your target to remove emotion.",
          "**Two Bets Strategy**: Place 2 bets - cash out one early (1.5x), let the other ride.",
          "**Martingale**: Double bet after loss, return to base after win.  Risky!",
        ],
        tips: [
          "Watch the game history - but remember each round is independent!",
          "Set a budget BEFORE you start and stick to it",
          "Don't chase losses - the plane doesn't care about your previous bets",
          "Use auto cash-out to avoid panic decisions",
        ],
        rtp: "97%",
      },
      
      blackjack: {
        name: "Blackjack",
        type: "Card Game",
        description: "Beat the dealer by getting closer to 21 without going over.",
        howToPlay: [
          "1. Place your bet",
          "2. You and dealer each get 2 cards (one dealer card face down)",
          "3. Card values: Number cards = face value, J/Q/K = 10, Ace = 1 or 11",
          "4. Choose: Hit (get another card), Stand (keep your hand), Double (double bet, get one card), Split (if you have a pair)",
          "5. Try to get closer to 21 than the dealer without going over (bust)",
          "6. Dealer must hit on 16 or less, stand on 17+",
          "7. Blackjack (Ace + 10-value card) pays 3:2",
        ],
        strategies: [
          "**Basic Strategy** (memorize this!):",
          "• Always split Aces and 8s",
          "• Never split 10s or 5s", 
          "• Double down on 11 (unless dealer shows Ace)",
          "• Double down on 10 if dealer shows 2-9",
          "• Stand on 17+ always",
          "• Hit on soft 17 (Ace + 6)",
          "• Stand on 12-16 if dealer shows 2-6, otherwise hit",
        ],
        tips: [
          "Dealer must hit on 16, stand on 17 - use this!",
          "Insurance is almost always a bad bet - skip it",
          "Don't take 'even money' on blackjack",
          "Card counting doesn't work online (shuffled each hand)",
        ],
        rtp: "99.5% with perfect strategy",
      },
      
      roulette: {
        name: "Roulette", 
        type: "Table Game",
        description: "Bet on where the ball will land on the spinning wheel.",
        howToPlay: [
          "1. Place chips on the betting table before the spin",
          "2. Bet types: Single number (35:1), Red/Black (1:1), Odd/Even (1:1), Dozens (2:1), Columns (2:1)",
          "3. The wheel spins and ball lands on a number",
          "4. If you bet on that number or group, you win!",
          "5. European wheel has 0-36, American has 0, 00, and 1-36",
        ],
        strategies: [
          "**Martingale**: Double bet after each loss.  Can hit table limits fast!",
          "**Reverse Martingale**: Double after wins, reset after loss.",
          "**D'Alembert**: Increase bet by 1 after loss, decrease by 1 after win.",
          "**James Bond**: Bet 70% on 19-36, 25% on 13-18, 5% on 0.",
          "**Column Betting**: Bet on 2 columns for 64% coverage.",
        ],
        tips: [
          "European Roulette (single 0) has better odds than American (double 00)",
          "Outside bets (red/black, odd/even) have ~48% win chance",
          "Inside bets pay more but hit less often",
          "The wheel has no memory - each spin is independent!",
        ],
        rtp: "European: 97.3% | American: 94.7%",
      },
      
      slots: {
        name: "Slots",
        type: "Video Slots",
        description: "Spin the reels and match symbols to win!",
        howToPlay: [
          "1. Choose your bet amount and number of paylines",
          "2. Click Spin to start the reels",
          "3. Matching symbols on paylines = win! Check paytable for values",
          "4. Special symbols: Wild (substitutes for others), Scatter (triggers bonus)",
          "5. Bonus features: Free Spins, Multipliers, Pick-and-Win games",
          "6. Some slots have progressive jackpots that grow until someone wins",
        ],
        strategies: [
          "**Bankroll Management**: Set bet size to 1-2% of your bankroll",
          "**High payout Slots**: Look for games with 96%+ payout rate",
          "**Volatility Choice**: Low = frequent small wins, High = rare big wins",
          "**Max Bet for Jackpots**: Some progressives require max bet to qualify",
          "**Bonus Hunting**: Use free spins bonuses to extend playtime",
        ],
        tips: [
          "Check the paytable before playing - know the best symbols",
          "Set win/loss limits before you start",
          "Slots are pure luck - no skill involved",
          "Take breaks - it's easy to lose track of time and money",
        ],
        rtp: "Varies: 92-98% (check each game)",
      },
      
      poker: {
        name: "Poker (Casino/Video)",
        type: "Card Game",
        description: "Make the best 5-card hand to win.",
        howToPlay: [
          "1. Place your bet (Ante)",
          "2. You receive 5 cards",
          "3. Choose which cards to hold and which to discard",
          "4. Draw new cards to replace discards",
          "5. Hand rankings (highest to lowest): Royal Flush, Straight Flush, Four of a Kind, Full House, Flush, Straight, Three of a Kind, Two Pair, One Pair, High Card",
          "6. Minimum winning hand is usually Jacks or Better (pair of Jacks)",
        ],
        strategies: [
          "**Starting Hands**: Only play strong hands (pairs, high cards, suited connectors)",
          "**Position Matters**: Play tighter early, looser in late position",
          "**Jacks or Better Strategy**:",
          "• Keep any paying hand",
          "• Keep 4 to a flush or straight",
          "• Keep high pairs (J+)",
          "• Keep 3 to a royal flush",
        ],
        tips: [
          "Video Poker has some of the best odds in the casino",
          "Always bet max coins for the royal flush bonus",
          "Learn one game well before trying others",
          "Jacks or Better is the best game for beginners",
        ],
        rtp: "Up to 99.5% with perfect play",
      },
      
      baccarat: {
        name: "Baccarat",
        type: "Card Game", 
        description: "Bet on Player, Banker, or Tie - closest to 9 wins.",
        howToPlay: [
          "1. Bet on Player, Banker, or Tie before cards are dealt",
          "2. Player and Banker each receive 2 cards",
          "3. Card values: A=1, 2-9=face value, 10/J/Q/K=0",
          "4. Add cards together, only the last digit counts (15 = 5, 20 = 0)",
          "5. Third card may be drawn based on rules (automatic)",
          "6. Hand closest to 9 wins. Banker bet wins pay 0.95:1 (5% commission)",
        ],
        strategies: [
          "**Always bet Banker**: 1.06% house edge (best bet in the game!)",
          "**Never bet Tie**: 14.4% house edge - terrible odds",
          "**Flat Betting**: Same bet size every hand",
          "**1-3-2-4 System**: Bet 1, 3, 2, 4 units. Reset after loss or completing sequence.",
        ],
        tips: [
          "Banker bet wins ~51% of the time (that's why there's commission)",
          "No skill involved - it's pure luck",
          "Scorecards/patterns are meaningless - each hand is independent",
          "One of the simplest and best-odds casino games",
        ],
        rtp: "Banker: 98.94% | Player: 98.76% | Tie: 85.6%",
      },
      
      crash: {
        name: "Crash Games (General)",
        type: "Crash Game",
        description: "Multiplier rises until it crashes - cash out in time!",
        howToPlay: [
          "1. Place bet before round starts",
          "2. Multiplier starts at 1.00x and increases",
          "3. Cash out anytime to win bet × current multiplier",
          "4. If you don't cash out before crash, you lose",
          "5. Crash point is random and different each round",
        ],
        strategies: [
          "**Conservative**: Auto cash-out at 1.2x-1.5x for steady small wins",
          "**Balanced**: Target 2x, accept some losses for bigger wins",
          "**Aggressive**: Go for 5x+ but expect many losses",
          "**Split Strategy**: Two bets - one safe (1.5x), one risky (5x+)",
        ],
        tips: [
          "The crash point is random - patterns don't predict future rounds",
          "Set strict loss limits before playing",
          "Auto cash-out removes emotional decisions",
          "Don't chase losses with bigger bets",
        ],
        rtp: "Usually 96-97%",
      },
      
      plinko: {
        name: "Plinko",
        type: "Instant Game",
        description: "Drop a ball and watch it bounce down to win multipliers!",
        howToPlay: [
          "1. Choose your bet amount",
          "2. Select risk level: Low, Medium, or High",
          "3. Choose number of rows (more rows = more variance)",
          "4. Drop the ball from the top",
          "5. Ball bounces off pegs randomly and lands in a multiplier slot",
          "6. You win your bet × the multiplier where ball lands",
        ],
        strategies: [
          "**Low Risk**: Smaller multipliers but more consistent wins",
          "**High Risk**: Big multipliers possible but more losses",
          "**Multi-drop**: Drop multiple balls to average out variance",
          "**Bankroll Split**: Use smaller bets on high risk for big win potential",
        ],
        tips: [
          "Each drop is completely random - no patterns",
          "High risk mode can have 1000x+ multipliers but also 0.2x",
          "Low risk is best for steady play",
          "Set a loss limit before you start",
        ],
        rtp: "97-99% depending on settings",
      },
      
      spaceman: {
        name: "Spaceman",
        type: "Crash Game",
        description: "Similar to Aviator - astronaut flies up, cash out before he disappears!",
        howToPlay: [
          "1. Place bet before round starts",
          "2. Spaceman launches and multiplier grows",
          "3. Click Cash Out to collect bet × current multiplier",
          "4. If spaceman disappears before you cash out, you lose",
          "5. Can place 2 bets per round for different strategies",
        ],
        strategies: [
          "**Same as Aviator**: Early cash-out (1.5x) or risky (3x+)",
          "**Half-Half**: Cash out one bet early, let other ride",
          "**Auto Mode**: Set auto cash-out to remove emotion",
          "**Base Bet Strategy**: Keep same bet size, don't chase losses",
        ],
        tips: [
          "Works exactly like Aviator - same strategies apply",
          "Each round is independent - no patterns",
          "Use auto cash-out for consistency",
          "Never bet more than you can afford to lose",
        ],
        rtp: "96-97%",
      },
      
      crazy_time: {
        name: "Crazy Time",
        type: "Live Game Show",
        description: "Spin the big wheel for multipliers and exciting bonus games!",
        howToPlay: [
          "1. Bet on segments: Numbers (1, 2, 5, 10) or Bonus Games (Coin Flip, Pachinko, Cash Hunt, Crazy Time)",
          "2. Host spins the big wheel",
          "3. If wheel lands on your bet, you win! Numbers pay that amount (bet on 5 = win 5x)",
          "4. Bonus games have big multiplier potential",
          "5. Top Slot can add random multipliers to any segment before spin",
        ],
        strategies: [
          "**Safe Play**: Bet on 1 (most common) for frequent small wins",
          "**Balanced**: Cover 1, 2, and one bonus game",
          "**Bonus Hunter**: Focus bets on bonus games for big win potential",
          "**Coverage**: Spread bets across multiple segments",
        ],
        tips: [
          "Number 1 appears most often on the wheel",
          "Bonus games are rare but can pay huge",
          "Crazy Time bonus has the biggest potential multipliers",
          "Watch the Top Slot - multipliers can make any segment valuable",
        ],
        rtp: "Around 95-96%",
      },
      
      lightning_roulette: {
        name: "Lightning Roulette",
        type: "Live Casino",
        description: "Roulette with random lightning multipliers up to 500x!",
        howToPlay: [
          "1. Place bets like regular roulette",
          "2. Before each spin, 1-5 numbers get random Lightning multipliers (50x-500x)",
          "3. Spin happens normally",
          "4. If you bet straight on a Lightning number and it hits, you win multiplier × your bet",
          "5. Regular bets pay standard roulette odds (but straight bets pay 30:1 instead of 35:1)",
        ],
        strategies: [
          "**Chase Lightning**: Bet small on multiple straight-up numbers hoping for lightning hit",
          "**Outside + Straight**: Cover outside bets for consistency, add straight-up for lightning chance",
          "**Numbers Only**: Focus on straight-up bets to maximize lightning potential",
          "**Safe Play**: Stick to outside bets (red/black) - lightning doesn't affect these",
        ],
        tips: [
          "Straight-up bets pay less (30:1 vs 35:1) without lightning",
          "Lightning multipliers only apply to straight-up number bets",
          "Outside bets are not affected by lightning - same as regular roulette",
          "Big wins require hitting a lightning number you bet on",
        ],
        rtp: "Around 97.3%",
      },
      
      sweet_bonanza: {
        name: "Sweet Bonanza",
        type: "Video Slot",
        description: "Colorful candy slot with tumble feature and multipliers!",
        howToPlay: [
          "1. Set your bet amount",
          "2. Spin the 6x5 reel grid",
          "3. Match 8+ identical symbols anywhere to win (no paylines needed)",
          "4. Winning symbols disappear and new ones tumble down (free re-spins!)",
          "5. Tumbles continue until no new wins",
          "6. Scatter symbols (lollipops) trigger Free Spins bonus",
          "7. In Free Spins, bomb multipliers appear and add up!",
        ],
        strategies: [
          "**Buy Bonus**: If available, buying free spins guarantees the bonus round",
          "**Ante Bet**: 25% extra bet doubles scatter chances",
          "**Base Game Grind**: Play normally and wait for natural bonus triggers",
          "**Low Stakes Long Play**: Smaller bets, more spins to hit bonus",
        ],
        tips: [
          "The bonus round is where big wins happen",
          "Multipliers in bonus can stack up to huge amounts",
          "Tumble feature can chain multiple wins from one spin",
          "High volatility - expect dry spells between big wins",
        ],
        rtp: "96.51%",
      },
      
      gates_of_olympus: {
        name: "Gates of Olympus",
        type: "Video Slot",
        description: "Zeus-themed slot with multipliers and tumbling reels!",
        howToPlay: [
          "1. Set your bet",
          "2. Spin the 6x5 grid",
          "3. Match 8+ same symbols anywhere to win",
          "4. Wins tumble away, new symbols fall down",
          "5. Random multipliers (2x-500x) can appear and multiply your wins",
          "6. 4+ Scatter symbols trigger 15 Free Spins",
          "7. In Free Spins, multipliers accumulate for the entire bonus!",
        ],
        strategies: [
          "**Buy Bonus**: Skip to free spins (costs 100x bet)",
          "**Ante Bet**: Extra 25% increases scatter frequency",
          "**Regular Play**: Standard spins waiting for natural triggers",
          "**Quick Spins**: More spins = more chances at bonus",
        ],
        tips: [
          "Free Spins is where the big money is",
          "Multipliers in bonus ADD together and apply to all wins",
          "Can retrigger more free spins during bonus",
          "Very high volatility - prepare for swings",
        ],
        rtp: "96.50%",
      },
      
      mega_moolah: {
        name: "Mega Moolah",
        type: "Progressive Jackpot Slot",
        description: "Famous progressive jackpot slot with life-changing wins!",
        howToPlay: [
          "1. Set bet (higher bets = better jackpot chances)",
          "2. Spin the 5x3 African safari themed reels",
          "3. Match symbols on 25 paylines to win",
          "4. Wild Lion substitutes and doubles wins",
          "5. 3+ Scatter Monkeys trigger 15 Free Spins with 3x multiplier",
          "6. Random Jackpot Wheel can trigger anytime!",
          "7. Spin the wheel for Mini, Minor, Major, or MEGA jackpot",
        ],
        strategies: [
          "**Max Bet**: Higher bets improve jackpot trigger chances",
          "**Jackpot Focus**: Play specifically for jackpot chance, not base game",
          "**Budget Play**: Set strict limits - jackpot is rare",
          "**Timing**: Some believe playing when jackpot is high helps (unproven)",
        ],
        tips: [
          "MEGA jackpot starts at 1 million and grows",
          "Jackpot wheel is randomly triggered - can happen anytime",
          "Lower payout rate than regular slots due to jackpot contribution",
          "Play for fun, don't expect to hit the big one",
        ],
        rtp: "88.12% (low due to jackpot contribution)",
      },
      
      live_dealer: {
        name: "Live Dealer Games",
        type: "Live Casino",
        description: "Real dealers streaming in real-time!",
        howToPlay: [
          "1. Choose your live game (Blackjack, Roulette, Baccarat, etc.)",
          "2. Join a table with available seats",
          "3. Place bets during betting time",
          "4. Watch the real dealer manage the game via video stream",
          "5. Game plays out same as regular casino version",
          "6. Chat with dealer and other players if you want",
        ],
        strategies: [
          "Use the same strategies as regular table games",
          "**Live Blackjack**: Basic strategy still applies",
          "**Live Roulette**: European tables have better odds",
          "**Live Baccarat**: Still bet Banker!",
        ],
        tips: [
          "Games are slower - good for bankroll management",
          "Chat with dealers but stay focused on your bets",
          "Check for live casino bonuses",
          "Internet connection matters - don't play on weak WiFi",
        ],
        rtp: "Same as regular versions",
      },
    };

    // ============================================
    //  ADVANCED BET MARKET PREDICTIONS
    // ============================================
    
    const BET_MARKET_DATA = {
      // Average statistics by league (based on historical data)
      corners: {
        'eng.1': { avgPerMatch: 10.2, homeAvg: 5.4, awayAvg: 4.8, over95: 65, over105: 48, over115: 32 },
        'esp.1': { avgPerMatch: 9.8, homeAvg: 5.2, awayAvg: 4.6, over95: 62, over105: 45, over115: 28 },
        'ger.1': { avgPerMatch: 10.5, homeAvg: 5.6, awayAvg: 4.9, over95: 68, over105: 52, over115: 35 },
        'ita.1': { avgPerMatch: 10.8, homeAvg: 5.7, awayAvg: 5.1, over95: 70, over105: 54, over115: 38 },
        'fra.1': { avgPerMatch: 9.5, homeAvg: 5.0, awayAvg: 4.5, over95: 58, over105: 42, over115: 26 },
        'default': { avgPerMatch: 10.0, homeAvg: 5.3, awayAvg: 4.7, over95: 63, over105: 47, over115: 30 },
      },
      cards: {
        'eng.1': { yellowAvg: 3.2, redChance: 8, totalCardsAvg: 3.4, over25: 62, over35: 38, over45: 18 },
        'esp.1': { yellowAvg: 4.5, redChance: 12, totalCardsAvg: 4.8, over25: 78, over35: 55, over45: 32 },
        'ger.1': { yellowAvg: 3.8, redChance: 9, totalCardsAvg: 4.0, over25: 70, over35: 45, over45: 22 },
        'ita.1': { yellowAvg: 4.2, redChance: 11, totalCardsAvg: 4.5, over25: 75, over35: 52, over45: 28 },
        'fra.1': { yellowAvg: 3.5, redChance: 10, totalCardsAvg: 3.7, over25: 65, over35: 42, over45: 20 },
        'default': { yellowAvg: 3.8, redChance: 10, totalCardsAvg: 4.0, over25: 70, over35: 46, over45: 24 },
      },
      goals: {
        'eng.1': { avgPerMatch: 2.85, bttsYes: 52, over15: 78, over25: 55, over35: 28, cleanSheet: 25 },
        'esp.1': { avgPerMatch: 2.65, bttsYes: 48, over15: 75, over25: 50, over35: 24, cleanSheet: 28 },
        'ger.1': { avgPerMatch: 3.15, bttsYes: 55, over15: 82, over25: 62, over35: 35, cleanSheet: 22 },
        'ita.1': { avgPerMatch: 2.55, bttsYes: 45, over15: 72, over25: 48, over35: 22, cleanSheet: 30 },
        'fra.1': { avgPerMatch: 2.70, bttsYes: 50, over15: 76, over25: 52, over35: 26, cleanSheet: 26 },
        'nba': { avgPerGame: 224.5, over220: 52, over230: 35, under215: 38 },
        'nfl': { avgPerGame: 46.5, over45: 48, over50: 32, under42: 40 },
        'default': { avgPerMatch: 2.75, bttsYes: 50, over15: 76, over25: 52, over35: 26, cleanSheet: 26 },
      },
      fouls: {
        'eng.1': { avgPerMatch: 22, homeAvg: 10, awayAvg: 12 },
        'esp.1': { avgPerMatch: 26, homeAvg: 12, awayAvg: 14 },
        'ita.1': { avgPerMatch: 28, homeAvg: 13, awayAvg: 15 },
        'default': { avgPerMatch: 24, homeAvg: 11, awayAvg: 13 },
      },
      shots: {
        'eng.1': { avgOnTarget: 10.5, homeAvg: 5.8, awayAvg: 4.7 },
        'esp.1': { avgOnTarget: 9.8, homeAvg: 5.5, awayAvg: 4.3 },
        'default': { avgOnTarget: 10.0, homeAvg: 5.5, awayAvg: 4.5 },
      },
    };

    // Function to get bet market predictions
    function getBetMarketPrediction(marketType, league = 'default', homeTeam = null, awayTeam = null) {
      const leagueKey = BET_MARKET_DATA[marketType]?.[league] ? league : 'default';
      const data = BET_MARKET_DATA[marketType]?.[leagueKey];
      
      if (!data) return null;
      
      return {
        market: marketType,
        league: leagueKey,
        stats: data,
        homeTeam,
        awayTeam,
      };
    }

    // Format bet market response with clickable options
    function formatBetMarketResponse(marketType, league, homeTeam, awayTeam) {
      const prediction = getBetMarketPrediction(marketType, league, homeTeam, awayTeam);
      if (!prediction) return null;
      
      const { stats } = prediction;
      let response = '';
      let quickActions = [];
      
      switch (marketType) {
        case 'corners':
          response = ` **Corner Kick Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += ` **League Average**: ${stats.avgPerMatch} corners per match\n`;
          response += ` Home team avg: ${stats.homeAvg} corners\n`;
          response += ` Away team avg: ${stats.awayAvg} corners\n\n`;
          response += `**Probability Estimates**:\n`;
          response += `• Over 9.5 corners: ${stats.over95}% likely\n`;
          response += `• Over 10.5 corners: ${stats.over105}% likely\n`;
          response += `• Over 11.5 corners: ${stats.over115}% likely\n\n`;
          response += ` **Tip**: High-pressing teams like Liverpool & Man City average 6+ corners per game.\n`;
          quickActions = [
            { text: 'Premier League tips', action: 'give me Premier League tips' },
            { text: 'Live matches', action: 'show live matches' },
            { text: 'Casino games', action: 'show casino games' },
            { text: 'My bonuses', action: 'what bonuses do I have' },
          ];
          break;
          
        case 'cards':
          response = ` **Cards Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += ` **League Averages**:\n`;
          response += `• Yellow cards: ${stats.yellowAvg} per match\n`;
          response += `• Red card chance: ${stats.redChance}%\n`;
          response += `• Total cards: ${stats.totalCardsAvg} per match\n\n`;
          response += `**Probability Estimates**:\n`;
          response += `• Over 2.5 cards: ${stats.over25}% likely\n`;
          response += `• Over 3.5 cards: ${stats.over35}% likely\n`;
          response += `• Over 4.5 cards: ${stats.over45}% likely\n\n`;
          response += ` **Tip**: Derbies and relegation battles have 40% more cards on average!\n`;
          quickActions = [
            { text: 'Serie A tips', action: 'give me Serie A tips' },
            { text: 'Live matches', action: 'show live matches' },
            { text: 'Casino games', action: 'show casino games' },
            { text: 'My bonuses', action: 'what bonuses do I have' },
          ];
          break;
          
        case 'goals':
          response = ` **Goals Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += ` **League Averages**:\n`;
          response += `• Goals per match: ${stats.avgPerMatch}\n`;
          response += `• Both Teams Score: ${stats.bttsYes}% of matches\n`;
          response += `• Clean sheet chance: ${stats.cleanSheet}%\n\n`;
          response += `**Probability Estimates**:\n`;
          response += `• Over 1.5 goals: ${stats.over15}% likely\n`;
          response += `• Over 2.5 goals: ${stats.over25}% likely\n`;
          response += `• Over 3.5 goals: ${stats.over35}% likely\n\n`;
          response += ` **Tip**: First 15 mins and last 15 mins see 35% of all goals!\n`;
          quickActions = [
            { text: 'Bundesliga tips', action: 'give me Bundesliga tips' },
            { text: 'Live matches', action: 'show live matches' },
            { text: 'Casino games', action: 'show casino games' },
            { text: 'My bonuses', action: 'what bonuses do I have' },
          ];
          break;
          
        case 'shots':
          response = ` **Shots Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += ` **League Averages**:\n`;
          response += `• Shots on target: ${stats.avgOnTarget} per match\n`;
          response += `• Home team avg: ${stats.homeAvg} shots on target\n`;
          response += `• Away team avg: ${stats.awayAvg} shots on target\n\n`;
          response += ` **Tip**: Teams chasing goals in 2nd half average 60% more shots!\n`;
          quickActions = [
            { text: 'Premier League tips', action: 'give me Premier League tips' },
            { text: 'Live matches', action: 'show live matches' },
            { text: 'Casino games', action: 'show casino games' },
            { text: 'My bonuses', action: 'what bonuses do I have' },
          ];
          break;
          
        case 'fouls':
          response = ` **Fouls Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += ` **League Averages**:\n`;
          response += `• Total fouls: ${stats.avgPerMatch} per match\n`;
          response += `• Home team avg: ${stats.homeAvg} fouls\n`;
          response += `• Away team avg: ${stats.awayAvg} fouls\n\n`;
          response += ` **Tip**: Away teams commit ~20% more fouls on average!\n`;
          quickActions = [
            { text: 'Sports tips', action: 'give me sports tips' },
            { text: 'Live matches', action: 'show live matches' },
            { text: 'Casino games', action: 'show casino games' },
            { text: 'My bonuses', action: 'what bonuses do I have' },
          ];
          break;
      }
      
      return { response, quickActions };
    }

    // ============================================
    //  CASINO SESSION TRACKING & RECOMMENDATIONS
    // ============================================
    
    let casinoSession = {
      startTime: null,
      currentGame: null,
      gamesPlayed: [],
      totalWins: 0,
      totalLosses: 0,
      totalSpent: 0,
      totalWon: 0,
    };

    // Simulated casino game data (would come from platform in production)
    const CASINO_GAMES_DATA = {
      games: [
        { id: 'aviator', name: 'Aviator', type: 'crash', rtp: 97, popularity: 95, currentPlayers: 234, recentWins: 12, jackpot: null },
        { id: 'starburst', name: 'Starburst', type: 'slot', rtp: 96.1, popularity: 88, currentPlayers: 156, recentWins: 8, jackpot: null },
        { id: 'book_of_dead', name: 'Book of Dead', type: 'slot', rtp: 96.2, popularity: 82, currentPlayers: 89, recentWins: 5, jackpot: null },
        { id: 'gonzo_quest', name: "Gonzo's Quest", type: 'slot', rtp: 95.9, popularity: 78, currentPlayers: 67, recentWins: 4, jackpot: null },
        { id: 'mega_moolah', name: 'Mega Moolah', type: 'slot', rtp: 88.1, popularity: 70, currentPlayers: 45, recentWins: 1, jackpot: 2500000 },
        { id: 'lightning_roulette', name: 'Lightning Roulette', type: 'live', rtp: 97.3, popularity: 85, currentPlayers: 178, recentWins: 15, jackpot: null },
        { id: 'blackjack_live', name: 'Live Blackjack', type: 'live', rtp: 99.5, popularity: 80, currentPlayers: 123, recentWins: 20, jackpot: null },
        { id: 'crazy_time', name: 'Crazy Time', type: 'live', rtp: 96.0, popularity: 92, currentPlayers: 289, recentWins: 18, jackpot: null },
        { id: 'sweet_bonanza', name: 'Sweet Bonanza', type: 'slot', rtp: 96.5, popularity: 86, currentPlayers: 134, recentWins: 9, jackpot: null },
        { id: 'gates_of_olympus', name: 'Gates of Olympus', type: 'slot', rtp: 96.5, popularity: 84, currentPlayers: 112, recentWins: 7, jackpot: null },
        { id: 'spaceman', name: 'Spaceman', type: 'crash', rtp: 96, popularity: 75, currentPlayers: 56, recentWins: 6, jackpot: null },
        { id: 'plinko', name: 'Plinko', type: 'instant', rtp: 97, popularity: 72, currentPlayers: 34, recentWins: 11, jackpot: null },
      ],
    };

    // Start casino session tracking
    function startCasinoSession(gameName) {
      if (!casinoSession.startTime) {
        casinoSession.startTime = Date.now();
      }
      casinoSession.currentGame = gameName;
      if (!casinoSession.gamesPlayed.includes(gameName)) {
        casinoSession.gamesPlayed.push(gameName);
      }
    }

    // Get session duration in minutes
    function getSessionDuration() {
      if (!casinoSession.startTime) return 0;
      return Math.floor((Date.now() - casinoSession.startTime) / 60000);
    }

    // Get casino recommendations based on user behavior
    function getCasinoRecommendations(context = {}) {
      const { 
        currentGame = null,
        sessionMinutes = getSessionDuration(),
        winRate = casinoSession.totalWins / (casinoSession.totalWins + casinoSession.totalLosses + 1),
        gamesPlayed = casinoSession.gamesPlayed,
      } = context;

      const recommendations = [];
      const games = CASINO_GAMES_DATA.games;
      
      // Find games user hasn't played
      const unplayedGames = games.filter(g => !gamesPlayed.includes(g.name));
      
      // Recommendation 1: Long session - suggest a break or change
      if (sessionMinutes >= 20) {
        const differentTypeGames = games.filter(g => {
          const currentGameData = games.find(cg => cg.name === currentGame);
          return currentGameData && g.type !== currentGameData.type && !gamesPlayed.includes(g.name);
        });
        if (differentTypeGames.length > 0) {
          const suggested = differentTypeGames.sort((a, b) => b.popularity - a.popularity)[0];
          recommendations.push({
            type: 'session_change',
            reason: `You've been playing for ${sessionMinutes} minutes`,
            game: suggested,
            message: ` **${suggested.name}** has ${suggested.currentPlayers} players online right now!`,
          });
        }
      }
      
      // Recommendation 2: Low win rate - suggest higher RTP game
      if (winRate < 0.3 && (casinoSession.totalWins + casinoSession.totalLosses) >= 5) {
        const highRtpGames = games.filter(g => g.rtp >= 96.5 && g.name !== currentGame);
        if (highRtpGames.length > 0) {
          const suggested = highRtpGames.sort((a, b) => b.rtp - a.rtp)[0];
          recommendations.push({
            type: 'better_odds',
            reason: 'Looking for a change of luck?',
            game: suggested,
            message: ` **${suggested.name}** has ${suggested.rtp}% payout rate - great for winning!`,
          });
        }
      }
      
      // Recommendation 3: Popular games - join the fun
      const popularGames = games
        .filter(g => g.name !== currentGame && g.currentPlayers > 100)
        .sort((a, b) => b.currentPlayers - a.currentPlayers);
      if (popularGames.length > 0) {
        recommendations.push({
          type: 'popular',
          reason: 'Join the action!',
          game: popularGames[0],
          message: ` **${popularGames[0].name}** - ${popularGames[0].currentPlayers} players online, ${popularGames[0].recentWins} wins in the last hour!`,
        });
      }
      
      // Recommendation 4: Recent wins on another game
      const hotGames = games
        .filter(g => g.name !== currentGame && g.recentWins >= 8)
        .sort((a, b) => b.recentWins - a.recentWins);
      if (hotGames.length > 0) {
        recommendations.push({
          type: 'hot_game',
          reason: 'Games paying out right now',
          game: hotGames[0],
          message: ` **${hotGames[0].name}** - ${hotGames[0].recentWins} wins in the last hour!`,
        });
      }
      
      // Recommendation 5: Low activity game - potential bigger wins
      const quietGames = games
        .filter(g => g.name !== currentGame && g.currentPlayers < 50 && g.rtp >= 95)
        .sort((a, b) => a.currentPlayers - b.currentPlayers);
      if (quietGames.length > 0) {
        recommendations.push({
          type: 'quiet_game',
          reason: 'Less competition',
          game: quietGames[0],
          message: ` **${quietGames[0].name}** - Only ${quietGames[0].currentPlayers} players, could be your moment!`,
        });
      }
      
      // Recommendation 6: Jackpot games
      const jackpotGames = games.filter(g => g.jackpot && g.jackpot > 1000000 && g.name !== currentGame);
      if (jackpotGames.length > 0) {
        const jp = jackpotGames[0];
        recommendations.push({
          type: 'jackpot',
          reason: 'Life-changing win potential',
          game: jp,
          message: ` **${jp.name}** - ZMW ${(jp.jackpot).toLocaleString()} jackpot waiting!`,
        });
      }
      
      // Recommendation 7: Try something new
      if (unplayedGames.length > 0 && gamesPlayed.length >= 1) {
        const newGame = unplayedGames.sort((a, b) => b.popularity - a.popularity)[0];
        recommendations.push({
          type: 'try_new',
          reason: 'Expand your horizons',
          game: newGame,
          message: ` **${newGame.name}** - Popular game you haven't tried yet!`,
        });
      }
      
      return recommendations.slice(0, 4); // Return max 4 recommendations
    }

    // Format casino recommendations with clickable options
    function formatCasinoRecommendations(currentGame = null) {
      const recs = getCasinoRecommendations({ currentGame });
      
      let response = "**Games You Might Enjoy**:\n\n";
      
      recs.forEach((rec, i) => {
        response += `${rec.message}\n`;
      });
      
      const quickActions = recs.map(rec => ({
        text: ` ${rec.game.name}`,
        action: `tell me about ${rec.game.name}`,
      }));
      
      // Add some standard actions
      quickActions.push({ text: 'Casino strategies', action: 'casino strategies' });
      
      return { response, quickActions: quickActions.slice(0, 4) };
    }

    // ============================================
    //  CLICKABLE QUICK ACTIONS SYSTEM
    // ============================================
    
    // Generate quick action buttons HTML
    function generateQuickActionsHTML(actions) {
      if (!actions || actions.length === 0) return '';
      
      let html = '<div class="quick-actions-container">';
      actions.forEach(action => {
        html += `<button class="quick-action" onclick="handleQuickAction('${action.action.replace(/'/g, "\\'")}')">${action.text}</button>`;
      });
      html += '</div>';
      return html;
    }

    // Handle quick action click
    function handleQuickAction(action) {
      document.getElementById('messageInput').value = action;
      sendMessage();
    }

    // Detect the topic from user message to provide relevant quick actions
    function detectMessageTopic(message) {
      const msg = message.toLowerCase().trim();
      
      // Casino-specific keywords (high confidence)
      const casinoKeywords = ['casino', 'slot', 'slots', 'roulette', 'blackjack', 'poker', 'baccarat', 'aviator', 'crash game', 'live dealer', 'jackpot', 'spin', 'rtp', 'crazy time', 'lightning', 'starburst', 'book of dead', 'sweet bonanza', 'spaceman', 'plinko', 'mega moolah'];
      
      // Sports-specific keywords (high confidence) - includes "tips" with sports context
      const sportsKeywords = ['match', 'team', 'league', 'premier league', 'epl', 'la liga', 'serie a', 'bundesliga', 'champions league', 'nba', 'nfl', 'mlb', 'nhl', 'soccer', 'football match', 'basketball', 'tennis', 'golf', 'ufc', 'boxing', 'f1', 'formula', 'racing', 'cricket', 'rugby', 'corner', 'corners', 'goals', 'btts', 'both teams', 'score', 'standings', 'fixture', 'liverpool', 'manchester', 'arsenal', 'chelsea', 'barcelona', 'real madrid', 'lakers', 'celtics', 'warriors', 'picks', 'predictions'];
      
      // Strategy-related keywords - NOTE: "tips" is NOT here, it's context-dependent
      const strategyKeywords = ['strategy', 'strategies', 'how to win', 'bankroll', 'martingale', 'system', 'how to play'];
      
      // Help/general keywords
      const helpKeywords = ['help', 'what can you', 'how do i', 'explain', 'what is'];
      
      // Count matches for each category
      let casinoScore = 0;
      let sportsScore = 0;
      let strategyScore = 0;
      let helpScore = 0;
      
      casinoKeywords.forEach(k => { if (msg.includes(k)) casinoScore++; });
      sportsKeywords.forEach(k => { if (msg.includes(k)) sportsScore++; });
      strategyKeywords.forEach(k => { if (msg.includes(k)) strategyScore++; });
      helpKeywords.forEach(k => { if (msg.includes(k)) helpScore++; });
      
      // Handle "tips" contextually - if sports keywords present, it's sports tips
      if (msg.includes('tip')) {
        if (sportsScore > 0) {
          sportsScore += 2; // Boost sports if "tips" + sports context
        } else if (casinoScore > 0) {
          strategyScore += 1; // Casino tips = strategy
        }
      }
      
      // Special case: if asking about casino strategy
      if (strategyScore > 0 && casinoScore > 0) return 'strategy';
      
      // Determine the highest scoring topic
      const scores = [
        { topic: 'casino', score: casinoScore },
        { topic: 'sports', score: sportsScore },
        { topic: 'strategy', score: strategyScore },
        { topic: 'help', score: helpScore },
      ];
      
      scores.sort((a, b) => b.score - a.score);
      
      // If no clear winner or all zero, return greeting (balanced options)
      if (scores[0].score === 0) return 'greeting';
      
      return scores[0].topic;
    }

    // Generate engaging quick actions that guide users toward betting decisions
    function generateSmartQuickActions(userMessage, aiResponse = '') {
      const msg = userMessage.toLowerCase().trim();
      const response = aiResponse.toLowerCase();
      
      let quickActions = [];
      
      // =====================================================
      // FIRST: Check AI RESPONSE content for context
      // =====================================================
      
      // Casino game mentions in AI response - provide game-specific actions
      const casinoGameInResponse = {
        blackjack: response.includes('blackjack'),
        baccarat: response.includes('baccarat'),
        roulette: response.includes('roulette'),
        poker: response.includes('poker') || response.includes('video poker'),
        slots: response.includes('slot'),
        aviator: response.includes('aviator'),
        crash: response.includes('crash'),
        craps: response.includes('craps'),
        payout: response.includes('payout') || response.includes('rtp'),
      };
      
      // If response mentions multiple casino games (like payout comparison)
      const casinoGamesCount = Object.values(casinoGameInResponse).filter(v => v).length;
      
      if (casinoGamesCount >= 2 || casinoGameInResponse.payout) {
        // Response is about casino games/payouts - offer specific game strategies
        quickActions = [];
        if (casinoGameInResponse.blackjack) {
          quickActions.push({ text: 'Blackjack strategy', action: 'teach me blackjack strategy' });
        }
        if (casinoGameInResponse.baccarat) {
          quickActions.push({ text: 'Baccarat strategy', action: 'teach me baccarat strategy' });
        }
        if (casinoGameInResponse.roulette) {
          quickActions.push({ text: 'Roulette strategy', action: 'teach me roulette strategy' });
        }
        if (casinoGameInResponse.poker) {
          quickActions.push({ text: 'Video Poker tips', action: 'teach me video poker strategy' });
        }
        if (casinoGameInResponse.slots) {
          quickActions.push({ text: 'Best slots', action: 'show me best payout slots' });
        }
        if (casinoGameInResponse.aviator || casinoGameInResponse.crash) {
          quickActions.push({ text: 'Aviator strategy', action: 'teach me aviator strategy' });
        }
        // Limit to 4 and add sports crossover
        quickActions = quickActions.slice(0, 3);
        quickActions.push({ text: 'Sports picks', action: 'give me sports picks' });
        return quickActions;
      }
      
      // Single casino game mentioned - offer that game's actions
      if (casinoGameInResponse.blackjack && casinoGamesCount === 1) {
        return [
          { text: 'Blackjack strategy', action: 'teach me blackjack basic strategy' },
          { text: 'Live Blackjack', action: 'tell me about live blackjack' },
          { text: 'Other table games', action: 'show me other table games' },
          { text: 'Sports picks', action: 'give me sports picks' },
        ];
      }
      if (casinoGameInResponse.aviator && casinoGamesCount === 1) {
        return [
          { text: 'Aviator strategy', action: 'best aviator cash out strategy' },
          { text: 'Other crash games', action: 'show me other crash games' },
          { text: 'Slots', action: 'show me popular slots' },
          { text: 'Sports picks', action: 'give me sports picks' },
        ];
      }
      if (casinoGameInResponse.roulette && casinoGamesCount === 1) {
        return [
          { text: 'Roulette strategy', action: 'teach me roulette betting strategies' },
          { text: 'Lightning Roulette', action: 'tell me about lightning roulette' },
          { text: 'Other table games', action: 'show me baccarat and blackjack' },
          { text: 'Sports picks', action: 'give me sports picks' },
        ];
      }
      
      // Check if response mentions sports teams
      const teamPatterns = [
        { pattern: /liverpool/i, name: 'Liverpool', action: 'give me full analysis on Liverpool match' },
        { pattern: /manchester city|man city/i, name: 'Man City', action: 'give me full analysis on Man City match' },
        { pattern: /manchester united|man united|man utd/i, name: 'Man United', action: 'give me full analysis on Man United match' },
        { pattern: /arsenal/i, name: 'Arsenal', action: 'give me full analysis on Arsenal match' },
        { pattern: /chelsea/i, name: 'Chelsea', action: 'give me full analysis on Chelsea match' },
        { pattern: /tottenham|spurs/i, name: 'Tottenham', action: 'give me full analysis on Tottenham match' },
        { pattern: /barcelona|barca/i, name: 'Barcelona', action: 'give me full analysis on Barcelona match' },
        { pattern: /real madrid/i, name: 'Real Madrid', action: 'give me full analysis on Real Madrid match' },
        { pattern: /bayern/i, name: 'Bayern', action: 'give me full analysis on Bayern match' },
        { pattern: /juventus|juve/i, name: 'Juventus', action: 'give me full analysis on Juventus match' },
        { pattern: /lakers/i, name: 'Lakers', action: 'give me full analysis on Lakers game' },
        { pattern: /celtics/i, name: 'Celtics', action: 'give me full analysis on Celtics game' },
      ];
      
      const mentionedTeams = teamPatterns.filter(team => team.pattern.test(aiResponse));
      
      if (mentionedTeams.length >= 2) {
        return [
          { text: `${mentionedTeams[0].name} analysis`, action: mentionedTeams[0].action },
          { text: `${mentionedTeams[1].name} analysis`, action: mentionedTeams[1].action },
          { text: 'Build betslip', action: 'help me build a betslip with these picks' },
          { text: 'Casino games', action: 'show me casino games' },
        ];
      }
      
      if (mentionedTeams.length === 1) {
        return [
          { text: `${mentionedTeams[0].name} analysis`, action: mentionedTeams[0].action },
          { text: 'Build betslip', action: 'help me build a winning betslip' },
          { text: 'More picks', action: 'show me more picks for today' },
          { text: 'Casino games', action: 'show me casino games' },
        ];
      }
      
      // Check if response is about betting markets/strategies
      if (response.includes('double chance') || response.includes('over/under') || response.includes('handicap')) {
        return [
          { text: 'Apply to today', action: 'find these bets for today' },
          { text: 'Premier League', action: 'Premier League tips' },
          { text: 'Build betslip', action: 'help me build a betslip' },
          { text: 'Casino games', action: 'show me casino games' },
        ];
      }
      
      // Check if response mentions corners/cards
      if (response.includes('corner') && (response.includes('over') || response.includes('average'))) {
        return [
          { text: 'Corner predictions', action: 'give me corner predictions for today' },
          { text: 'Card predictions', action: 'give me card predictions for today' },
          { text: 'Build betslip', action: 'help me build a corners betslip' },
          { text: 'Match tips', action: 'give me match winner tips' },
        ];
      }
      
      // =====================================================
      // SECOND: Fall back to USER MESSAGE context
      // =====================================================
      
      const casinoKeywords = ['casino', 'slot', 'roulette', 'blackjack', 'aviator', 'poker', 'crash', 'spin', 'payout'];
      const isCasinoRequest = casinoKeywords.some(k => msg.includes(k));
      
      const sportsKeywords = ['tips', 'picks', 'predictions', 'match', 'team', 'league', 'bet', 'parlay', 'betslip'];
      const isSportsRequest = sportsKeywords.some(k => msg.includes(k));
      
      const leagueMap = {
        'epl': 'Premier League', 'premier league': 'Premier League', 'english': 'Premier League',
        'la liga': 'La Liga', 'spanish': 'La Liga',
        'serie a': 'Serie A', 'italian': 'Serie A',
        'bundesliga': 'Bundesliga', 'german': 'Bundesliga',
        'champions league': 'Champions League', 'ucl': 'Champions League',
        'nba': 'NBA', 'basketball': 'NBA',
        'nfl': 'NFL',
        'ufc': 'UFC', 'mma': 'UFC'
      };
      
      let detectedLeague = null;
      for (const [keyword, league] of Object.entries(leagueMap)) {
        if (msg.includes(keyword)) {
          detectedLeague = league;
          break;
        }
      }
      
      if (isCasinoRequest) {
        return [
          { text: 'Game strategies', action: 'show me casino game strategies' },
          { text: 'Best payouts', action: 'which games have best payout rates' },
          { text: 'Jackpots', action: 'show me jackpot games' },
          { text: 'Sports picks', action: 'give me sports picks' },
        ];
      }
      
      if (isSportsRequest) {
        if (detectedLeague) {
          return [
            { text: 'Build betslip', action: `help me build a ${detectedLeague} betslip` },
            { text: 'Safe picks', action: `show me safest ${detectedLeague} bets` },
            { text: 'Value picks', action: `show me value ${detectedLeague} picks` },
            { text: 'Casino games', action: 'show me casino games' },
          ];
        }
        return [
          { text: 'Build betslip', action: 'help me build a winning betslip' },
          { text: 'Best bets', action: 'show me the best bets for today' },
          { text: 'Live betting', action: 'show me live matches' },
          { text: 'Casino games', action: 'show me casino games' },
        ];
      }
      
      // Default - balanced options
      return [
        { text: 'Top picks', action: 'show me top picks for today' },
        { text: 'Build betslip', action: 'help me build a winning betslip' },
        { text: 'Casino games', action: 'show me casino games' },
        { text: 'My bonuses', action: 'what bonuses do I have' },
      ];
    }

    // Get contextual quick actions based on conversation
    function getContextualQuickActions(topic, context = {}) {
      const actions = {
        greeting: [
          { text: 'Premier League tips', action: 'give me Premier League tips for today' },
          { text: 'Casino games', action: 'show me casino games' },
          { text: 'My betting stats', action: 'show my betting statistics' },
          { text: 'My bonuses', action: 'what bonuses do I have' },
        ],
        sports: [
          { text: 'La Liga tips', action: 'give me La Liga tips' },
          { text: 'Serie A tips', action: 'give me Serie A tips' },
          { text: 'NBA tips', action: 'give me NBA tips' },
          { text: 'Casino games', action: 'show me casino games' },
        ],
        casino: [
          { text: 'Popular games', action: 'show popular casino games' },
          { text: 'High payout games', action: 'show highest payout games' },
          { text: 'Game strategies', action: 'casino game strategies' },
          { text: 'Sports tips', action: 'give me sports tips' },
        ],
        match_analysis: [
          { text: 'More matches', action: 'show more matches today' },
          { text: 'League standings', action: 'show league standings' },
          { text: 'Team form', action: 'show team recent form' },
          { text: 'My bonuses', action: 'what bonuses do I have' },
        ],
        strategy: [
          { text: 'Slots strategy', action: 'slots strategy' },
          { text: 'Blackjack tips', action: 'blackjack strategy' },
          { text: 'Aviator tactics', action: 'aviator strategy' },
          { text: 'Sports tips', action: 'give me sports tips' },
        ],
        help: [
          { text: 'Sports tips', action: 'give me sports tips for today' },
          { text: 'Casino games', action: 'show casino games' },
          { text: 'Bet types', action: 'explain different bet types' },
          { text: 'Bankroll tips', action: 'bankroll management advice' },
        ],
        bet_markets: [
          { text: 'Get predictions', action: 'give me match predictions' },
          { text: 'Premier League tips', action: 'give me Premier League tips' },
          { text: 'NBA tips', action: 'give me NBA tips' },
          { text: 'Casino games', action: 'show casino games' },
        ],
      };
      
      return actions[topic] || actions.greeting;
    }

    // Get strategy for a specific game
    function getCasinoStrategy(game) {
      const gameLower = game.toLowerCase();
      const gameKey = gameLower.replace(/\s+/g, '_');
      
      // Explicit game name mappings
      const gameAliases = {
        'sweet bonanza': 'sweet_bonanza',
        'gates of olympus': 'gates_of_olympus',
        'gates': 'gates_of_olympus',
        'olympus': 'gates_of_olympus',
        'mega moolah': 'mega_moolah',
        'moolah': 'mega_moolah',
        'lightning roulette': 'lightning_roulette',
        'lightning': 'lightning_roulette',
        'crazy time': 'crazy_time',
        'plinko': 'plinko',
        'spaceman': 'spaceman',
        'live dealer': 'live_dealer',
        'live casino': 'live_dealer',
        'live': 'live_dealer',
      };
      
      // Check aliases first
      if (gameAliases[gameLower]) {
        return CASINO_STRATEGIES[gameAliases[gameLower]];
      }
      
      // Find matching strategy by key or name
      for (const [key, data] of Object.entries(CASINO_STRATEGIES)) {
        if (key === gameKey || data.name.toLowerCase() === gameLower) {
          return data;
        }
      }
      
      // Fuzzy match
      for (const [key, data] of Object.entries(CASINO_STRATEGIES)) {
        if (gameLower.includes(key) || key.includes(gameLower) || 
            gameLower.includes(data.name.toLowerCase()) || data.name.toLowerCase().includes(gameLower)) {
          return data;
        }
      }
      
      return null;
    }

    // Format strategy response with quick actions
    function formatStrategyResponse(strategy) {
      let response = `Bwana, **${strategy.name}** analysis (${strategy.type}):\n\n`;
      response += `${strategy.description}\n\n`;
      response += `**Payout Rate**: ${strategy.rtp}\n\n`;
      
      // Add How to Play section if available
      if (strategy.howToPlay && strategy.howToPlay.length > 0) {
        response += `**Game Mechanics**:\n`;
        strategy.howToPlay.forEach(step => {
          response += `${step}\n`;
        });
        response += `\n`;
      }
      
      response += `**Optimal Strategies**:\n`;
      strategy.strategies.forEach(s => {
        response += `${s}\n`;
      });
      response += `\n**Recommendations**:\n`;
      strategy.tips.forEach(t => {
        response += `- ${t}\n`;
      });
      response += `\nNote: No strategy guarantees wins. Gamble responsibly.`;
      return response;
    }

    // Enhanced getInstantResponse - returns { response, quickActions } or null
    function getInstantResponse(message) {
      const msg = message.toLowerCase().trim();
      let response = null;
      let quickActions = [];
      
      // ============================================
      // CONTEXT DETECTION - Used throughout the function
      // ============================================
      
      // Sports context keywords - if any of these appear, it's likely sports-related
      const sportsExcludeKeywords = ['epl', 'premier', 'league', 'la liga', 'serie', 'bundesliga', 'champions', 'europa', 'nba', 'nfl', 'mlb', 'nhl', 'ufc', 'soccer', 'football', 'basketball', 'tennis', 'golf', 'cricket', 'rugby', 'match', 'matches', 'team', 'teams', 'liverpool', 'manchester', 'arsenal', 'chelsea', 'tottenham', 'barcelona', 'real madrid', 'juventus', 'bayern', 'psg', 'lakers', 'celtics', 'warriors', 'corner', 'corners', 'goal', 'goals', 'btts', 'standings', 'fixture', 'fixtures', 'odds', 'score', 'scores', 'halftime', 'fulltime', 'handicap'];
      const hasSportsContext = sportsExcludeKeywords.some(k => msg.includes(k));
      
      // Casino context keywords - specific casino game names
      const casinoGameNames = ['aviator', 'blackjack', 'roulette', 'slots', 'slot', 'poker', 'baccarat', 'crash', 'live dealer', 'live casino', 'crazy time', 'starburst', 'plinko', 'sweet bonanza', 'book of dead', 'mega moolah', 'lightning', 'spaceman', 'gates of olympus', 'gates'];
      const hasCasinoKeyword = msg.includes('casino') || casinoGameNames.some(g => msg.includes(g));
      
      // ============================================
      // BET MARKET PREDICTIONS (Corners, Cards, Goals, etc.)
      // ============================================
      
      // Corner predictions
      if (msg.includes('corner') && (msg.includes('predict') || msg.includes('how many') || msg.includes('over') || msg.includes('under') || msg.includes('tip'))) {
        const result = formatBetMarketResponse('corners', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Cards predictions
      if ((msg.includes('card') || msg.includes('yellow') || msg.includes('red card') || msg.includes('booking')) && 
          (msg.includes('predict') || msg.includes('how many') || msg.includes('over') || msg.includes('tip'))) {
        const result = formatBetMarketResponse('cards', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Goals predictions
      if ((msg.includes('goal') || msg.includes('btts') || msg.includes('both teams') || msg.includes('over 2.5') || msg.includes('over 1.5')) && 
          (msg.includes('predict') || msg.includes('how many') || msg.includes('tip') || msg.includes('score'))) {
        const result = formatBetMarketResponse('goals', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Shots predictions
      if (msg.includes('shot') && (msg.includes('predict') || msg.includes('how many') || msg.includes('target'))) {
        const result = formatBetMarketResponse('shots', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Fouls predictions
      if (msg.includes('foul') && (msg.includes('predict') || msg.includes('how many'))) {
        const result = formatBetMarketResponse('fouls', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // All betting markets
      if (msg.includes('betting market') || msg.includes('all market') || msg.includes('what bets') || msg.includes('types of bet') || msg.includes('bet types') || msg.includes('other bet')) {
        response = "Bwana, available betting markets:\n\n" +
                   "**1. Match Result (1X2)**:\nPrediction of match outcome - home win, draw, or away win\n\n" +
                   "**2. Double Chance**:\nCovers 2 of 3 outcomes - higher probability, lower payout\n\n" +
                   "**3. Goals**:\nOver/Under 1.5, 2.5, 3.5 goals | Both Teams to Score (Yes/No)\n\n" +
                   "**4. Corners**:\nOver/Under 8.5, 9.5, 10.5 total corners\n\n" +
                   "**5. Cards**:\nOver/Under 2.5, 3.5 total cards\n\n" +
                   "**6. Specials**:\nHandicap, First Half Result, Clean Sheet";
        quickActions = [
          { text: 'Match Result tips', action: 'give me match result predictions' },
          { text: 'Double Chance tips', action: 'give me double chance predictions' },
          { text: 'Goals tips', action: 'give me goals predictions' },
          { text: 'Corners tips', action: 'give me corner predictions' },
        ];
        return { response, quickActions };
      }
      
      // Explain specific bet types
      if (msg.includes('explain') && (msg.includes('double chance') || msg.includes('1x2') || msg.includes('match result'))) {
        response = "Bwana, Double Chance analysis:\n\n" +
                   "Double Chance covers 2 of 3 outcomes:\n\n" +
                   "- **1X** = Home Win OR Draw\n" +
                   "- **X2** = Draw OR Away Win\n" +
                   "- **12** = Home OR Away Win (no draw)\n\n" +
                   "**Advantage**: Higher probability - covers 2 outcomes\n" +
                   "**Trade-off**: Lower payout than single outcome bets\n\n" +
                   "Recommendation: Optimal for tight matches with uncertain outcomes.";
        quickActions = [
          { text: 'Find DC bets', action: 'find good double chance bets today' },
          { text: 'Premier League tips', action: 'give me Premier League tips' },
          { text: 'La Liga tips', action: 'give me La Liga tips' },
          { text: 'Casino games', action: 'show casino games' },
        ];
        return { response, quickActions };
      }
      
      // Explain corner bets
      if (msg.includes('explain') && msg.includes('corner')) {
        response = "Bwana, Corner Bets analysis:\n\n" +
                   "**Available Markets**:\n\n" +
                   "- **Over/Under 9.5** - Standard line\n" +
                   "- **Over/Under 10.5** - Higher risk, better payout\n" +
                   "- **Team Corners** - Which team accumulates more\n" +
                   "- **First Corner** - Opening corner prediction\n\n" +
                   "**Correlation Factors**:\n" +
                   "- Attacking team formations increase corners\n" +
                   "- Derby matches show elevated corner counts\n" +
                   "- Late-game chasing behavior increases corners\n\n" +
                   "**League Averages**:\n" +
                   "- Premier League: 10.2 per match\n" +
                   "- La Liga: 9.8 per match\n" +
                   "- Bundesliga: 10.5 per match";
        quickActions = [
          { text: 'Corner predictions', action: 'give me corner predictions for today' },
          { text: 'Premier League tips', action: 'give me Premier League tips' },
          { text: 'NBA tips', action: 'give me NBA tips' },
          { text: 'Casino games', action: 'show casino games' },
        ];
        return { response, quickActions };
      }
      
      // Explain card bets
      if (msg.includes('explain') && (msg.includes('card') || msg.includes('booking') || msg.includes('yellow') || msg.includes('red'))) {
        response = "Bwana, Card Bets analysis:\n\n" +
                   "**Available Markets**:\n\n" +
                   "- **Over/Under 3.5 cards** - Total match cards\n" +
                   "- **Over/Under 4.5 cards** - High intensity matches\n" +
                   "- **Player to be booked** - Individual player cards\n" +
                   "- **Red card in match** - Lower probability, higher payout\n\n" +
                   "**High-Card Indicators**:\n" +
                   "- Derby and rivalry matches\n" +
                   "- Relegation battles\n" +
                   "- Strict referee assignments\n\n" +
                   "**League Averages (yellow cards)**:\n" +
                   "- Premier League: 3.2 per match\n" +
                   "- La Liga: 4.5 per match\n" +
                   "- Serie A: 4.2 per match";
        quickActions = [
          { text: 'Card predictions', action: 'give me card predictions for today' },
          { text: 'Premier League tips', action: 'give me Premier League tips' },
          { text: 'Serie A tips', action: 'give me Serie A tips' },
          { text: 'Casino games', action: 'show casino games' },
        ];
        return { response, quickActions };
      }
      
      // ============================================
      // CASINO GAME RECOMMENDATIONS
      // ============================================
      
      // Popular games request - only if NOT sports context
      if (!hasSportsContext && msg.includes('popular') && (msg.includes('game') || msg.includes('casino'))) {
        startCasinoSession('browsing');
        const games = CASINO_GAMES_DATA.games.sort((a, b) => b.currentPlayers - a.currentPlayers).slice(0, 5);
        response = "**Everyone's Playing These Right Now**:\n\n";
        games.forEach((g, i) => {
          response += `${i + 1}. **${g.name}** - ${g.currentPlayers} players winning! \n`;
        });
        response += "\nJump in while they're hot, Bwana! ";
        quickActions = [
          { text: ` Try ${games[0].name}`, action: `how do I win at ${games[0].name}` },
          { text: ` Try ${games[1].name}`, action: `how do I win at ${games[1].name}` },
          { text: 'Best payout games', action: 'show games with best payout' },
          { text: 'Sports picks', action: 'show me hot sports picks' },
        ];
        return { response, quickActions };
      }
      
      // High payout games
      if (!hasSportsContext && (msg.includes('high') && msg.includes('rtp') || msg.includes('best odds') && msg.includes('casino'))) {
        const games = CASINO_GAMES_DATA.games.sort((a, b) => b.rtp - a.rtp).slice(0, 5);
        response = "**Best Odds Games** (Your money goes further!):\n\n";
        games.forEach((g, i) => {
          response += `${i + 1}. **${g.name}** - ${g.rtp}% returns to players!\n`;
        });
        response += "\nThese give you the best chance to win, Bwana!";
        quickActions = [
          { text: ` Try ${games[0].name}`, action: `how do I win at ${games[0].name}` },
          { text: ` Try ${games[1].name}`, action: `how do I win at ${games[1].name}` },
          { text: 'What\'s hot now', action: 'which games are paying out right now' },
          { text: 'Sports betslip', action: 'build me a sports betslip' },
        ];
        return { response, quickActions };
      }
      
      // Hot games / games paying out - casino only
      if (!hasSportsContext && (msg.includes('hot') || msg.includes('paying') || msg.includes('winning')) && (msg.includes('game') || msg.includes('casino') || msg.includes('slot'))) {
        const games = CASINO_GAMES_DATA.games.sort((a, b) => b.recentWins - a.recentWins).slice(0, 5);
        response = "**Games Paying Out RIGHT NOW**:\n\n";
        games.forEach((g, i) => {
          response += `${i + 1}. **${g.name}** - ${g.recentWins} wins this hour! \n`;
        });
        response += "\nLady luck is smiling on these, Bwana! Get in there! ";
        quickActions = [
          { text: ` Play ${games[0].name}`, action: `how do I win at ${games[0].name}` },
          { text: ` Play ${games[1].name}`, action: `how do I win at ${games[1].name}` },
          { text: 'Best payout', action: 'games with best payout' },
          { text: 'Sports picks', action: 'give me hot sports picks too' },
        ];
        return { response, quickActions };
      }
      
      // Casino game recommendations based on session - only if asking about casino
      if (!hasSportsContext && (msg.includes('recommend') && (msg.includes('casino') || msg.includes('slot') || msg.includes('play')) || msg.includes('what should i play'))) {
        const result = formatCasinoRecommendations(casinoSession.currentGame);
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Specific game info
      for (const game of CASINO_GAMES_DATA.games) {
        if (msg.includes(game.name.toLowerCase()) && (msg.includes('tell') || msg.includes('about') || msg.includes('info') || msg.includes('win') || msg.includes('how'))) {
          startCasinoSession(game.name);
          response = ` **${game.name}** - Let's get you winning!\n\n`;
          response += ` **Payout Rate**: ${game.rtp}% (${game.rtp > 96 ? 'Great returns!' : 'Solid game!'})\n`;
          response += ` **Players Online**: ${game.currentPlayers} playing now\n`;
          response += ` **Recent Wins**: ${game.recentWins} in the last hour! \n`;
          response += ` **Type**: ${game.type.charAt(0).toUpperCase() + game.type.slice(1)}\n`;
          if (game.jackpot) {
            response += ` **JACKPOT**: ZMW ${game.jackpot.toLocaleString()} up for grabs!\n`;
          }
          response += `\nReady to win? Let me show you how! `;
          
          // Find similar games
          const similarGames = CASINO_GAMES_DATA.games
            .filter(g => g.type === game.type && g.id !== game.id)
            .slice(0, 2);
          
          quickActions = [
            { text: ` ${game.name} tips`, action: `how do I win at ${game.name}` },
            { text: 'What\'s hot', action: 'which games are paying out now' },
          ];
          if (similarGames.length > 0) {
            quickActions.push({ text: ` Try ${similarGames[0].name}`, action: `how do I win at ${similarGames[0].name}` });
          }
          quickActions.push({ text: 'Sports picks', action: 'show me hot sports picks' });
          return { response, quickActions };
        }
      }
      
      // ============================================
      // CASINO STRATEGY REQUESTS - INSTANT
      // ============================================
      
      const strategyKeywords = ['strategy', 'strategies', 'how to play', 'how do i play', 'how to win', 'best way to play'];
      const isStrategyRequest = strategyKeywords.some(k => msg.includes(k));
      
      // Only handle as casino strategy if there's specific casino context AND strategy keywords
      if (isStrategyRequest && hasCasinoKeyword && !hasSportsContext) {
        for (const game of casinoGameNames) {
          if (msg.includes(game)) {
            const strategy = getCasinoStrategy(game);
            if (strategy) {
              response = formatStrategyResponse(strategy);
              quickActions = [
                { text: 'Play now', action: `which ${game} games are hot right now` },
                { text: 'Hot games', action: 'which games are paying out right now' },
                { text: 'Best payout', action: 'games with best payout' },
                { text: 'Sports picks', action: 'show me hot sports picks too' },
              ];
              return { response, quickActions };
            }
          }
        }
        // General casino strategy request (only if explicitly asking about casino)
        if (msg.includes('casino')) {
          response = "Let me help you win Bwana! \n\n" +
                 " **Aviator** - Know when to cash out\n" +
                 " **Blackjack** - Beat the dealer consistently\n" +
                 " **Roulette** - Smart betting systems\n" +
                 " **Slots** - Maximize your spins\n" +
                 " **Baccarat** - The banker's secret\n\n" +
                 "Which game are you playing? ";
          quickActions = [
            { text: 'Win at Aviator', action: 'how do I win at aviator' },
            { text: 'Win at Blackjack', action: 'how do I win at blackjack' },
            { text: 'Win at Roulette', action: 'how do I win at roulette' },
            { text: 'Hot games now', action: 'which games are paying out' },
          ];
          return { response, quickActions };
        }
      }
      
      // Direct game mentions asking for strategy - must have specific game name
      if (msg.includes('aviator') && (msg.includes('how') || msg.includes('tip') || msg.includes('strat') || msg.includes('win'))) {
        response = formatStrategyResponse(CASINO_STRATEGIES.aviator);
        quickActions = [
          { text: 'Play Aviator now', action: 'is aviator hot right now' },
          { text: 'Other hot games', action: 'which games are paying out' },
          { text: 'Best payout games', action: 'games with best payout' },
          { text: 'Sports picks', action: 'show me hot sports picks' },
        ];
        return { response, quickActions };
      }
      
      if (msg.includes('blackjack') && (msg.includes('how') || msg.includes('tip') || msg.includes('strat') || msg.includes('win'))) {
        response = formatStrategyResponse(CASINO_STRATEGIES.blackjack);
        quickActions = [
          { text: 'Play Blackjack', action: 'is live blackjack hot right now' },
          { text: 'Hot games', action: 'which games are paying out' },
          { text: 'Best payout', action: 'games with best payout' },
          { text: 'Sports picks', action: 'show me hot sports picks' },
        ];
        return { response, quickActions };
      }
      
      if (msg.includes('roulette') && (msg.includes('how') || msg.includes('tip') || msg.includes('strat') || msg.includes('win'))) {
        response = formatStrategyResponse(CASINO_STRATEGIES.roulette);
        quickActions = [
          { text: 'Play Roulette', action: 'tell me about Lightning Roulette' },
          { text: 'Live casino', action: 'live casino games' },
          { text: 'Table games', action: 'show table games' },
          { text: 'All games', action: 'show casino games' },
        ];
        return { response, quickActions };
      }
      
      if ((msg.includes('slot') || msg.includes('slots')) && (msg.includes('how') || msg.includes('tip') || msg.includes('strat') || msg.includes('win'))) {
        response = formatStrategyResponse(CASINO_STRATEGIES.slots);
        quickActions = [
          { text: 'Hot slots now', action: 'which slots are paying out right now' },
          { text: 'Jackpot games', action: 'show me jackpot games' },
          { text: 'Best payout slots', action: 'slots with best payout' },
          { text: 'Sports picks', action: 'give me hot sports picks' },
        ];
        return { response, quickActions };
      }
      
      // Casino games list
      if (msg === 'casino' || msg === 'casino games' || msg.includes('what casino games') || msg.includes('show casino') || msg.includes('all casino')) {
        response = "Bwana, casino analysis complete.\n\n" +
               "**High Activity Games**:\nAviator - High player volume\nCrazy Time - Frequent bonus rounds\n\n" +
               "**Progressive Jackpots**:\nMega Moolah - ZMW 2.5M+ available\nSweet Bonanza - High multiplier potential\n\n" +
               "**Optimal Payout Rates**:\nLive Blackjack - 99.5% payout rate\nLightning Roulette - Enhanced multipliers";
        quickActions = [
          { text: 'Aviator strategy', action: 'tell me how to win at Aviator' },
          { text: 'Jackpot games', action: 'show me the biggest jackpots' },
          { text: 'Hot games now', action: 'which games are paying out right now' },
          { text: 'Sports analysis', action: 'show me hot sports picks while I play' },
        ];
        return { response, quickActions };
      }
      
      // ============================================
      // GREETINGS & COMMON MESSAGES
      // ============================================
      
      // Greetings - INSTANT
      const greetings = ['hi', 'hello', 'hey', 'yo', 'sup', 'hola', 'howdy', 'good morning', 'good afternoon', 'good evening', 'whats up', "what's up", 'wassup'];
      if (greetings.some(g => msg === g || msg === g + '!' || msg === g + '?')) {
        const responses = [
          "Bwana, system online. Ready to provide betting analysis.",
          "Bwana, BetAssist activated. Multiple matches available for analysis.",
          "Bwana, welcome. Current data shows favorable betting opportunities today.",
          "Bwana, system ready. Awaiting your selection for analysis.",
        ];
        response = responses[Math.floor(Math.random() * responses.length)];
        quickActions = [
          { text: 'View top picks', action: 'show me the hottest picks for today' },
          { text: 'Build betslip', action: 'help me build a winning betslip' },
          { text: 'Casino analysis', action: 'show me casino games that are paying out' },
          { text: 'Check bonuses', action: 'what bonuses can I use right now' },
        ];
        return { response, quickActions };
      }
      
      // How are you - INSTANT
      if (msg.includes('how are you') || msg.includes('how r u') || msg === 'hru') {
        response = "Bwana, all systems operational. Ready to process your betting analysis requests.";
        quickActions = [
          { text: 'View top picks', action: 'show me the hottest picks right now' },
          { text: 'Value bet analysis', action: 'show me the best value bets today' },
          { text: 'Casino games', action: 'show me a quick casino game' },
          { text: 'Build betslip', action: 'build me a lucky betslip' },
        ];
        return { response, quickActions };
      }
      
      // Thanks - INSTANT
      if (msg === 'thanks' || msg === 'thank you' || msg === 'thx' || msg === 'ty') {
        response = "Acknowledged, Bwana. Standing by for additional analysis requests.";
        quickActions = [
          { text: 'More analysis', action: 'give me more hot picks' },
          { text: 'Casino games', action: 'show me a lucky casino game' },
          { text: 'New betslip', action: 'build me another betslip' },
          { text: 'Check bonuses', action: 'do I have any bonuses to use' },
        ];
        return { response, quickActions };
      }
      
      // Bye - INSTANT
      if (msg === 'bye' || msg === 'goodbye' || msg === 'see you' || msg === 'later' || msg === 'cya') {
        response = "Session ending, Bwana. Reminder: Gamble responsibly. System available 24/7 for future analysis.";
        quickActions = []; // No actions needed for goodbye
        return { response, quickActions };
      }
      
      // Help - INSTANT
      if (msg === 'help' || msg === '?' || msg === 'what can you do') {
        response = "Bwana, BetAssist capabilities:\n\n" +
                   "**Match Analysis** - Probability-based predictions for all major leagues\n" +
                   "**Betslip Builder** - Optimized bet combinations\n" +
                   "**Casino Analysis** - Game payout rates and strategies\n" +
                   "**Bonus Tracking** - Available promotional offers";
        quickActions = [
          { text: 'View top picks', action: 'show me today\'s hottest picks' },
          { text: 'Build betslip', action: 'help me build a winning betslip' },
          { text: 'Casino analysis', action: 'which casino games are hot right now' },
          { text: 'Check bonuses', action: 'what bonuses can I use' },
        ];
        return { response, quickActions };
      }
      
      // ============================================
      // SPORTS TIPS REQUESTS - Pass to Claude API for real data
      // ============================================
      
      // These patterns should NOT be instant - they need live data from Claude API
      // We return null to let them go through to the API
      const sportsLeaguePatterns = [
        'epl tips', 'premier league tips', 'la liga tips', 'serie a tips', 
        'bundesliga tips', 'champions league tips', 'nba tips', 'nfl tips',
        'mlb tips', 'nhl tips', 'sports tips', 'football tips', 'soccer tips',
        'basketball tips', 'tennis tips', 'ufc tips', 'boxing tips',
        'give me tips', 'betting tips', 'match tips', 'today tips',
        'tips for today', 'picks for today', 'predictions for today',
        'give me picks', 'give me predictions', 'best picks', 'best bets',
        'recommend bets', 'recommend picks', 'what should i bet',
        'games today', 'matches today', 'fixtures today',
        'who will win', 'who is playing'
      ];
      
      // If it's a sports tips request, let it go to Claude API (return null)
      if (sportsLeaguePatterns.some(p => msg.includes(p))) {
        return null; // Go to Claude API for live data
      }
      
      // Betting strategies request - offer both sports and casino
      if (msg.includes('betting strateg') || (msg.includes('strateg') && !hasCasinoKeyword && !casinoGameNames.some(g => msg.includes(g)))) {
        response = "Bwana, strategy database accessed.\n\n" +
                   "**Sports Betting Strategies**:\n" +
                   "- Value betting: Identify odds exceeding true probability\n" +
                   "- Bankroll management: Maximum 5% stake per bet recommended\n" +
                   "- Form analysis: Weight recent performance data\n" +
                   "- In-play betting: React to live match conditions\n\n" +
                   "**Casino Strategies**:\n" +
                   "- Game-specific optimal play available for Aviator, Blackjack, Roulette";
        quickActions = [
          { text: 'Sports strategies', action: 'sports betting strategies explained' },
          { text: 'Casino strategies', action: 'casino strategies' },
          { text: 'Bankroll management', action: 'bankroll management tips' },
          { text: 'Value betting', action: 'explain value betting' },
        ];
        return { response, quickActions };
      }
      
      // Simple sport mentions
      if (msg === 'epl' || msg === 'premier league') {
        response = "Bwana, Premier League selected. Data available for analysis.";
        quickActions = [
          { text: 'Premier League tips', action: 'Premier League tips for today' },
          { text: 'Corner statistics', action: 'Premier League corner statistics' },
          { text: 'Goals statistics', action: 'Premier League goals statistics' },
          { text: 'League standings', action: 'Premier League standings' },
        ];
        return { response, quickActions };
      }
      
      if (msg === 'nba') {
        response = "Bwana, NBA selected. Match data ready for analysis.";
        quickActions = [
          { text: 'NBA tips', action: 'NBA tips for today' },
          { text: 'Team statistics', action: 'NBA team statistics' },
          { text: 'Standings', action: 'NBA standings' },
          { text: 'Other sports', action: 'show other sports' },
        ];
        return { response, quickActions };
      }
      
      if (msg === 'la liga') {
        response = "Bwana, La Liga selected. Spanish league data loaded.";
        quickActions = [
          { text: 'La Liga tips', action: 'La Liga tips for today' },
          { text: 'Corner statistics', action: 'La Liga corner statistics' },
          { text: 'Goals statistics', action: 'La Liga goals statistics' },
          { text: 'League standings', action: 'La Liga standings' },
        ];
        return { response, quickActions };
      }
      
      // Not a simple message - needs Claude API
      return null;
    }

    function askQuestion(question) {
      document.getElementById('messageInput').value = question;
      sendMessage();
    }

    //  SPEED: Streaming-style message display (shows text progressively)
    // Now supports quickActions for clickable recommendations
    function addMessage(text, isUser, quickActions = []) {
      const container = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `flex ${isUser ? 'justify-end' : 'justify-start'} message-appear`;
      
      const contentId = 'msg-' + Date.now();
      const actionsId = 'actions-' + Date.now();
      
      messageDiv.innerHTML = `
        <div class="max-w-[90%] rounded-2xl px-4 py-3 ${
          isUser 
            ? 'bg-gradient-to-r from-amber-500 to-orange-500 text-white rounded-br-sm'
            : 'bg-slate-800 text-slate-100 rounded-bl-sm border border-slate-700'
        }">
          ${!isUser ? `
            <div class="flex items-center gap-2 mb-2 pb-2 border-b border-slate-600">
              <div class="w-6 h-6 rounded-full bg-gradient-to-r from-amber-400 to-orange-500 flex items-center justify-center">
                <span class="text-xs"></span>
              </div>
              <span class="text-xs font-medium text-amber-400">BetAssist AI</span>
              <span class="text-xs text-slate-500">• Live Data</span>
            </div>
          ` : ''}
          <div id="${contentId}" class="text-sm whitespace-pre-wrap leading-relaxed"></div>
          <div id="${actionsId}"></div>
        </div>
      `;
      
      container.appendChild(messageDiv);
      messageDiv.scrollIntoView({ behavior: 'smooth' });
      
      const contentDiv = document.getElementById(contentId);
      const actionsDiv = document.getElementById(actionsId);
      
      // Show text content
      contentDiv.innerHTML = formatText(text);
      
      // Add quick action buttons if provided (only for AI messages)
      if (!isUser && quickActions && quickActions.length > 0) {
        actionsDiv.innerHTML = generateQuickActionsHTML(quickActions);
      }
      
      // Scroll to show the message
      setTimeout(() => {
        messageDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }, 100);
    }

    //  SPEED: Simulate streaming by showing text progressively
    function streamText(element, text, speed = 5) {
      const formatted = formatText(text);
      let index = 0;
      const chunkSize = 3; // Characters per frame
      
      function showNextChunk() {
        if (index < formatted.length) {
          // Find a good break point (don't break mid-tag)
          let end = Math.min(index + chunkSize, formatted.length);
          
          // Don't break in the middle of an HTML tag
          const remaining = formatted.substring(index);
          const tagStart = remaining.indexOf('<');
          const tagEnd = remaining.indexOf('>');
          
          if (tagStart >= 0 && tagStart < chunkSize && tagEnd > tagStart) {
            end = index + tagEnd + 1;
          }
          
          element.innerHTML = formatted.substring(0, end);
          index = end;
          
          // Scroll to keep up with text
          element.parentElement.parentElement.scrollIntoView({ behavior: 'smooth', block: 'end' });
          
          requestAnimationFrame(showNextChunk);
        }
      }
      
      requestAnimationFrame(showNextChunk);
    }

    // Original addMessage for backwards compatibility
    function addMessageInstant(text, isUser) {
      const container = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `flex ${isUser ? 'justify-end' : 'justify-start'} message-appear`;
      
      messageDiv.innerHTML = `
        <div class="max-w-[90%] rounded-2xl px-4 py-3 ${
          isUser 
            ? 'bg-gradient-to-r from-amber-500 to-orange-500 text-white rounded-br-sm'
            : 'bg-slate-800 text-slate-100 rounded-bl-sm border border-slate-700'
        }">
          ${!isUser ? `
            <div class="flex items-center gap-2 mb-2 pb-2 border-b border-slate-600">
              <div class="w-6 h-6 rounded-full bg-gradient-to-r from-amber-400 to-orange-500 flex items-center justify-center">
                <span class="text-xs"></span>
              </div>
              <span class="text-xs font-medium text-amber-400">BetAssist AI</span>
              <span class="text-xs text-slate-500">• Live Data</span>
            </div>
          ` : ''}
          <div class="text-sm whitespace-pre-wrap leading-relaxed">${formatText(text)}</div>
        </div>
      `;
      
      container.appendChild(messageDiv);
      messageDiv.scrollIntoView({ behavior: 'smooth' });
    }

    function formatText(text) {
      return text
        // Bold
        .replace(/\*\*(.*?)\*\*/g, '<strong class="text-amber-300">$1</strong>')
        // Links
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" class="text-amber-400 hover:underline">$1</a>')
        // Line breaks
        .replace(/\n/g, '<br>');
    }

    function addWelcomeMessage() {
      // Get player summary
      const profile = getPlayerSummaryForAI();
      const isReturning = profile.behavior.totalInteractions > 0;
      const hasFavorites = profile.preferences.favoriteLeagues.length > 0;
      const hasHistory = profile.performance.totalBets > 0;

      let welcomeText = `Hey Bwana!  ${isReturning ? 'Good to see you again!' : 'Welcome to BetAssist!'}\n\n`;

      // Personalized greeting for returning players
      if (hasFavorites) {
        const favLeagueNames = profile.preferences.favoriteLeagues.map(l => l.name).slice(0, 2).join(' and ');
        welcomeText += `I know you're into **${favLeagueNames}** - got some nice picks today! \n\n`;
      }

      // Show quick stats if they have history
      if (hasHistory) {
        welcomeText += `Quick check: **${profile.performance.winRate}** win rate`;
        if (profile.performance.currentStreak.count > 0) {
          welcomeText += ` and you're on a **${profile.performance.currentStreak.count}-${profile.performance.currentStreak.type} streak** `;
        }
        welcomeText += `\n\n`;
      }

      // Bonus reminder
      welcomeText += ` Don't forget to check your **bonuses** before placing bets!\n\n`;

      welcomeText += `What can I help with today? `;

      // Welcome quick actions
      const welcomeActions = [
        { text: 'Sports tips', action: 'give me sports tips for today' },
        { text: 'Casino games', action: 'show casino games' },
        { text: 'Betting markets', action: 'explain betting markets' },
        { text: 'Strategies', action: 'show betting strategies' },
      ];

      addMessage(welcomeText, false, welcomeActions);
    }

    // ============================================
    // INITIALIZATION
    // ============================================

    // Pre-fetched data for instant responses
    let prefetchedData = {
      leagues: {},
      lastFetch: null,
    };

    // Pre-fetch popular leagues in background for instant responses
    async function prefetchPopularData() {
      const popularLeagues = ['eng.1', 'esp.1', 'ger.1', 'ita.1', 'nba', 'nfl'];
      
      console.log(' Pre-fetching popular league data...');
      
      // Fetch all in parallel for speed
      const promises = popularLeagues.map(async (league) => {
        try {
          const data = await fetchGames(league);
          if (!data.error) {
            prefetchedData.leagues[league] = data;
          }
        } catch (e) {
          // Silently fail - this is just optimization
        }
      });

      // Don't wait - let it run in background
      Promise.all(promises).then(() => {
        prefetchedData.lastFetch = Date.now();
        console.log(' Pre-fetch complete:', Object.keys(prefetchedData.leagues).length, 'leagues cached');
      });
    }

    // Initialize the app
    async function initializeApp() {
      // Initialize Supabase first
      await initSupabase();
      
      // Load player data (from Supabase or localStorage)
      playerData = await loadPlayerData();
      console.log(' Player data loaded:', playerData.profile.username || 'Guest');
      
      // Show welcome message
      addWelcomeMessage();
      
      // Pre-fetch popular data in background (non-blocking)
      prefetchPopularData();
      
      // Show connection status
      if (supabaseClient && currentPlayerId) {
        console.log(' Connected to Supabase database');
      } else {
        console.log(' Running in demo mode (localStorage)');
      }
    }

    // Expose functions globally for onclick handlers
    window.sendMessage = sendMessage;
    window.clearChat = clearChat;
    window.askQuestion = askQuestion;

    window.onload = async function() {
      console.log(' BetAssist AI Starting...');
      console.log(' Using Supabase proxy:', SUPABASE_CONFIG.claudeProxyUrl);
      
      try {
        await initializeApp();
        console.log(' BetAssist AI Ready!');
      } catch (error) {
        console.error(' Initialization failed:', error);
        document.getElementById('messages').innerHTML = `
          <div class="bg-red-500/20 border border-red-500 rounded-xl p-4 text-red-200">
            <strong> Initialization Error</strong><br>
            ${error.message}<br>
            <small>Check browser console for details</small>
          </div>
        `;
      }
    };
  </script>
</body>
</html>
