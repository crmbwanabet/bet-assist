<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BetAssist AI - Personalized Sports Betting Assistant</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes typing-dot {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.5; }
      30% { transform: translateY(-4px); opacity: 1; }
    }
    .typing-dot { animation: typing-dot 1.4s infinite ease-in-out; }
    .typing-dot:nth-child(1) { animation-delay: 0s; }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes message-appear {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .message-appear { animation: message-appear 0.3s ease-out; }
    
    .chat-scroll::-webkit-scrollbar { width: 6px; }
    .chat-scroll::-webkit-scrollbar-track { background: transparent; }
    .chat-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }

    .game-card {
      background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
    }
  </style>
</head>
<body class="bg-slate-900 min-h-screen">

  <!-- Main App -->
  <div id="mainApp">
    <!-- Header -->
    <div class="fixed top-0 left-0 right-0 bg-slate-800 border-b border-slate-700 px-4 py-3 z-40">
      <div class="max-w-2xl mx-auto flex items-center justify-between">
        <div class="flex items-center gap-3">
          <div class="w-10 h-10 rounded-xl bg-gradient-to-br from-amber-400 to-orange-500 flex items-center justify-center">
            <span class="text-xl">ğŸ¯</span>
          </div>
          <div>
            <h1 class="font-bold text-white">BetAssist AI</h1>
            <div class="flex items-center gap-1">
              <div class="w-2 h-2 rounded-full bg-emerald-400 animate-pulse"></div>
              <span class="text-xs text-slate-400">Personalized Sports Betting AI</span>
            </div>
          </div>
        </div>
        <div class="flex gap-2">
          <button onclick="clearChat()" class="text-slate-400 hover:text-white p-2 rounded-lg hover:bg-slate-700" title="Clear chat">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <!-- Chat Container -->
    <div class="max-w-2xl mx-auto pt-20 pb-40 px-4">
      <div id="messages" class="space-y-4"></div>
      
      <!-- Typing Indicator -->
      <div id="typingIndicator" class="hidden flex items-center gap-2 p-4">
        <div class="w-8 h-8 rounded-full bg-gradient-to-r from-amber-400 to-orange-500 flex items-center justify-center">
          <span class="text-sm">ğŸ¯</span>
        </div>
        <div class="flex gap-1">
          <div class="w-2 h-2 bg-slate-400 rounded-full typing-dot"></div>
          <div class="w-2 h-2 bg-slate-400 rounded-full typing-dot"></div>
          <div class="w-2 h-2 bg-slate-400 rounded-full typing-dot"></div>
        </div>
        <span id="typingStatus" class="text-xs text-slate-400 ml-2"></span>
      </div>
    </div>

    <!-- Input Area -->
    <div class="fixed bottom-0 left-0 right-0 bg-slate-900 border-t border-slate-700 p-4">
      <div class="max-w-2xl mx-auto">
        <!-- Quick Actions -->
        <div class="flex gap-2 mb-3 overflow-x-auto pb-2">
          <button onclick="askQuestion('Give me recommendations')" class="quick-btn">ğŸ¯ My Picks</button>
          <button onclick="askQuestion('Premier League suggestions')" class="quick-btn">âš½ EPL Tips</button>
          <button onclick="askQuestion('La Liga suggestions')" class="quick-btn">ğŸ‡ªğŸ‡¸ La Liga Tips</button>
          <button onclick="askQuestion('NBA suggestions')" class="quick-btn">ğŸ€ NBA Tips</button>
          <button onclick="askQuestion('What are my favorite leagues?')" class="quick-btn">ğŸ‘¤ My Profile</button>
          <button onclick="askQuestion('What leagues do you cover?')" class="quick-btn">ğŸŒ All Leagues</button>
        </div>
        <style>.quick-btn { @apply flex-shrink-0 px-3 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-xs text-slate-200 whitespace-nowrap transition-all; }</style>
        
        <!-- Input -->
        <div class="flex gap-3">
          <input 
            type="text" 
            id="messageInput" 
            placeholder="Ask about live games, odds, betting, casino..." 
            class="flex-1 bg-slate-800 text-white placeholder-slate-400 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-amber-500 border border-slate-700"
            onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); }"
          >
          <button 
            onclick="sendMessage()" 
            id="sendButton"
            class="px-6 py-3 bg-gradient-to-r from-amber-500 to-orange-500 hover:from-amber-600 hover:to-orange-600 text-white font-semibold rounded-xl transition-all disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Send
          </button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // ============================================
    // âš™ï¸ CONFIGURATION - ADD YOUR API KEYS HERE
    // ============================================
    
    // ğŸ”‘ CLAUDE API KEY (REQUIRED)
    // Get your key at: https://console.anthropic.com
    const HARDCODED_API_KEY = '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';  // ğŸ‘ˆ PASTE YOUR KEY HERE
    // Example: const HARDCODED_API_KEY = 'sk-ant-api03-xxxxx...';
    
    // ============================================
    // ğŸ—„ï¸ SUPABASE DATABASE (OPTIONAL - for testing)
    // ============================================
    
    const SUPABASE_CONFIG = {
      url: 'https://dumjacmxefrxzcccsyxj.supabase.co',              // e.g., 'https://xxxxx.supabase.co'
      anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImR1bWphY214ZWZyeHpjY2NzeXhqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg0NjgwNTgsImV4cCI6MjA4NDA0NDA1OH0.lpzyMwI9Vds91FXm2oxK9Q8OpOYy-uSs3pWKdcx3Rd8',          // Your anon/public key
     enabled: true,        // Enable Supabase!
    };

    // Supabase client instance
    let supabaseClient = null;
    let currentPlayerId = null;

    // Initialize Supabase connection
    async function initSupabase() {
      if (SUPABASE_CONFIG.enabled && SUPABASE_CONFIG.url && SUPABASE_CONFIG.anonKey) {
        try {
          supabaseClient = window.supabase.createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);
          console.log('âœ… Supabase client created');
          
          // Try to get or create test player
          await ensureTestPlayer();
          return true;
        } catch (e) {
          console.error('âŒ Supabase connection failed:', e);
          console.log('ğŸ“¦ Falling back to localStorage');
          supabaseClient = null;
        }
      } else {
        console.log('ğŸ“¦ Supabase not configured - using localStorage');
      }
      return false;
    }

    // Ensure we have a test player in Supabase
    async function ensureTestPlayer() {
      if (!supabaseClient) return;
      
      // Check for existing player in localStorage
      const savedPlayerId = localStorage.getItem('betassist_player_id');
      
      if (savedPlayerId) {
        // Verify player exists in Supabase
        try {
          const { data, error } = await supabase
            .from('players')
            .select('id')
            .eq('id', savedPlayerId)
            .single();
          
          if (data && !error) {
            currentPlayerId = savedPlayerId;
            console.log('ğŸ‘¤ Loaded existing player:', currentPlayerId);
            return;
          }
        } catch (e) {
          console.log('Could not verify player, will create new one');
        }
      }
      
      // Create new player using RPC function
      try {
        const { data, error } = await supabaseClient.rpc('create_player_with_defaults', {
          p_username: 'player_' + Date.now(),
          p_country: 'Kenya',
          p_currency: 'KES'
        });
        
        if (error) {
          console.error('âŒ Supabase RPC error:', error);
          console.log('âš ï¸ Make sure you ran the SQL schema in Supabase!');
          console.log('ğŸ“¦ Falling back to localStorage');
          supabaseClient = null;
          return;
        }
        
        if (data) {
          currentPlayerId = data;
          localStorage.setItem('betassist_player_id', data);
          console.log('ğŸ‘¤ Created new player:', currentPlayerId);
        }
      } catch (e) {
        console.error('âŒ Failed to create player:', e);
        console.log('ğŸ“¦ Falling back to localStorage');
        supabaseClient = null;
      }
    }
    
    // ============================================
    // ğŸŒ COMPREHENSIVE SPORTS COVERAGE - ALL LEAGUES
    // ============================================
    
    const ALL_SPORTS = {
      // ========== SOCCER / FOOTBALL - 60+ LEAGUES ==========
      soccer: {
        name: 'Soccer/Football',
        leagues: {
          // ENGLAND
          'eng.1': 'Premier League', 'eng.2': 'Championship', 'eng.3': 'League One', 'eng.4': 'League Two', 'eng.fa': 'FA Cup', 'eng.league_cup': 'EFL Cup',
          // SPAIN
          'esp.1': 'La Liga', 'esp.2': 'La Liga 2', 'esp.copa_del_rey': 'Copa del Rey',
          // GERMANY
          'ger.1': 'Bundesliga', 'ger.2': '2. Bundesliga', 'ger.dfb_pokal': 'DFB Pokal',
          // ITALY
          'ita.1': 'Serie A', 'ita.2': 'Serie B', 'ita.coppa_italia': 'Coppa Italia',
          // FRANCE
          'fra.1': 'Ligue 1', 'fra.2': 'Ligue 2', 'fra.coupe_de_france': 'Coupe de France',
          // OTHER EUROPE
          'ned.1': 'Eredivisie', 'por.1': 'Primeira Liga', 'bel.1': 'Belgian Pro League', 'sco.1': 'Scottish Premiership',
          'tur.1': 'SÃ¼per Lig', 'rus.1': 'Russian Premier League', 'ukr.1': 'Ukrainian Premier League',
          'gre.1': 'Super League Greece', 'sui.1': 'Swiss Super League', 'aut.1': 'Austrian Bundesliga',
          'den.1': 'Danish Superliga', 'nor.1': 'Eliteserien', 'swe.1': 'Allsvenskan', 'pol.1': 'Ekstraklasa',
          'cze.1': 'Czech First League', 'cro.1': 'HNL', 'ser.1': 'Serbian SuperLiga', 'rom.1': 'Liga I',
          // SOUTH AMERICA
          'arg.1': 'Liga Profesional', 'bra.1': 'BrasileirÃ£o', 'bra.2': 'SÃ©rie B', 'col.1': 'Liga BetPlay',
          'chi.1': 'Primera DivisiÃ³n Chile', 'ecu.1': 'Liga Pro', 'per.1': 'Liga 1 Peru', 'uru.1': 'Primera DivisiÃ³n Uruguay',
          'par.1': 'Primera DivisiÃ³n Paraguay', 'ven.1': 'Primera DivisiÃ³n Venezuela', 'bol.1': 'DivisiÃ³n Profesional',
          // NORTH/CENTRAL AMERICA
          'usa.1': 'MLS', 'usa.nwsl': 'NWSL', 'mex.1': 'Liga MX', 'mex.2': 'Liga de ExpansiÃ³n',
          'crc.1': 'Primera DivisiÃ³n Costa Rica', 'hon.1': 'Liga Nacional Honduras',
          // ASIA
          'jpn.1': 'J1 League', 'jpn.2': 'J2 League', 'kor.1': 'K League 1', 'chn.1': 'Chinese Super League',
          'ind.1': 'Indian Super League', 'tha.1': 'Thai League', 'idn.1': 'Liga 1 Indonesia', 'mys.1': 'Malaysia Super League',
          'sau.1': 'Saudi Pro League', 'uae.1': 'UAE Pro League', 'qat.1': 'Qatar Stars League', 'irn.1': 'Persian Gulf Pro League',
          // OCEANIA
          'aus.1': 'A-League', 'nzl.1': 'New Zealand Football Championship',
          // AFRICA
          'rsa.1': 'PSL South Africa', 'egy.1': 'Egyptian Premier League', 'mar.1': 'Botola Pro', 
          'tun.1': 'Tunisian Ligue 1', 'nga.1': 'NPFL Nigeria', 'gha.1': 'Ghana Premier League', 'ken.1': 'Kenyan Premier League',
          // INTERNATIONAL COMPETITIONS
          'uefa.champions': 'UEFA Champions League', 'uefa.europa': 'UEFA Europa League', 'uefa.europa.conf': 'Conference League',
          'conmebol.libertadores': 'Copa Libertadores', 'conmebol.sudamericana': 'Copa Sudamericana',
          'concacaf.champions': 'CONCACAF Champions Cup', 'afc.champions': 'AFC Champions League', 'caf.champions': 'CAF Champions League',
          // INTERNATIONAL TEAMS
          'fifa.world': 'FIFA World Cup', 'fifa.worldq.uefa': 'World Cup Qual - UEFA', 'fifa.worldq.conmebol': 'World Cup Qual - CONMEBOL',
          'fifa.worldq.concacaf': 'World Cup Qual - CONCACAF', 'fifa.worldq.afc': 'World Cup Qual - AFC', 'fifa.worldq.caf': 'World Cup Qual - CAF',
          'uefa.euro': 'UEFA Euro', 'uefa.euro_qual': 'Euro Qualifiers', 'uefa.nations': 'UEFA Nations League',
          'conmebol.america': 'Copa America', 'concacaf.gold': 'CONCACAF Gold Cup', 'concacaf.nations': 'CONCACAF Nations League',
          'caf.nations': 'Africa Cup of Nations', 'afc.asian_cup': 'AFC Asian Cup',
          'fifa.friendly': 'International Friendlies', 'fifa.cwc': 'FIFA Club World Cup',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/soccer',
      },

      // ========== BASKETBALL ==========
      basketball: {
        name: 'Basketball',
        leagues: {
          'nba': 'NBA', 'wnba': 'WNBA', 'nba-g-league': 'NBA G League',
          'mens-college-basketball': 'NCAA Men\'s Basketball', 'womens-college-basketball': 'NCAA Women\'s Basketball',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/basketball',
      },

      // ========== AMERICAN FOOTBALL ==========
      football: {
        name: 'American Football',
        leagues: {
          'nfl': 'NFL', 'college-football': 'NCAA Football', 'xfl': 'XFL', 'cfl': 'CFL', 'ufl': 'UFL',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/football',
      },

      // ========== BASEBALL ==========
      baseball: {
        name: 'Baseball',
        leagues: {
          'mlb': 'MLB', 'college-baseball': 'NCAA Baseball',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/baseball',
      },

      // ========== ICE HOCKEY ==========
      hockey: {
        name: 'Ice Hockey',
        leagues: {
          'nhl': 'NHL', 'mens-college-hockey': 'NCAA Hockey',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/hockey',
      },

      // ========== TENNIS ==========
      tennis: {
        name: 'Tennis',
        leagues: {
          'atp': 'ATP Tour', 'wta': 'WTA Tour',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/tennis',
      },

      // ========== GOLF ==========
      golf: {
        name: 'Golf',
        leagues: {
          'pga': 'PGA Tour', 'lpga': 'LPGA Tour', 'euro': 'DP World Tour', 'liv': 'LIV Golf',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/golf',
      },

      // ========== MMA / COMBAT SPORTS ==========
      mma: {
        name: 'MMA',
        leagues: {
          'ufc': 'UFC', 'pfl': 'PFL', 'bellator': 'Bellator', 'one': 'ONE Championship',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/mma',
      },

      // ========== BOXING ==========
      boxing: {
        name: 'Boxing',
        leagues: {
          'boxing': 'Professional Boxing',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/boxing',
      },

      // ========== RUGBY ==========
      rugby: {
        name: 'Rugby',
        leagues: {
          'super-rugby': 'Super Rugby', 'six-nations': 'Six Nations', 'premiership': 'English Premiership',
          'top14': 'Top 14', 'urc': 'United Rugby Championship', 'mlr': 'Major League Rugby',
          'world-cup': 'Rugby World Cup',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/rugby',
      },

      // ========== CRICKET ==========
      cricket: {
        name: 'Cricket',
        leagues: {
          'ipl': 'IPL', 'bbl': 'Big Bash League', 'psl': 'Pakistan Super League', 'cpl': 'Caribbean Premier League',
          'hundred': 'The Hundred', 'sa20': 'SA20', 'ilt20': 'ILT20',
          't20-world-cup': 'T20 World Cup', 'odi-world-cup': 'ODI World Cup', 'wtc': 'World Test Championship',
          'the-ashes': 'The Ashes', 'icc-test': 'ICC Test Matches', 'icc-odi': 'ICC ODI Matches', 'icc-t20': 'ICC T20 Matches',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/cricket',
      },

      // ========== RACING ==========
      racing: {
        name: 'Racing',
        leagues: {
          'f1': 'Formula 1', 'nascar-cup': 'NASCAR Cup Series', 'nascar-xfinity': 'NASCAR Xfinity', 
          'indycar': 'IndyCar', 'motogp': 'MotoGP', 'wrc': 'World Rally Championship',
          'formula-e': 'Formula E', 'v8-supercars': 'V8 Supercars',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/racing',
      },

      // ========== ESPORTS ==========
      esports: {
        name: 'Esports',
        leagues: {
          'lol': 'League of Legends', 'csgo': 'Counter-Strike', 'dota2': 'Dota 2', 
          'valorant': 'Valorant', 'overwatch': 'Overwatch', 'rocket-league': 'Rocket League',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/esports',
      },

      // ========== AUSTRALIAN RULES ==========
      afl: {
        name: 'Australian Rules Football',
        leagues: {
          'afl': 'AFL',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/australian-football',
      },

      // ========== LACROSSE ==========
      lacrosse: {
        name: 'Lacrosse',
        leagues: {
          'pll': 'Premier Lacrosse League', 'nll': 'National Lacrosse League',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/lacrosse',
      },
    };

    // ============================================
    // DYNAMIC URL BUILDERS
    // ============================================
    
    function buildUrl(sport, league, endpoint = 'scoreboard') {
      const sportConfig = ALL_SPORTS[sport];
      if (!sportConfig) return null;
      return `${sportConfig.baseUrl}/${league}/${endpoint}`;
    }

    function buildTeamsUrl(sport, league) {
      return buildUrl(sport, league, 'teams');
    }

    function buildStandingsUrl(sport, league) {
      const sportConfig = ALL_SPORTS[sport];
      if (!sportConfig) return null;
      return `https://site.api.espn.com/apis/v2/sports/${sport}/${league}/standings`;
    }

    // ============================================
    // LEAGUE ALIASES FOR NATURAL LANGUAGE
    // ============================================
    
    const LEAGUE_ALIASES = {
      // Soccer
      'premier league': { sport: 'soccer', league: 'eng.1' },
      'epl': { sport: 'soccer', league: 'eng.1' },
      'la liga': { sport: 'soccer', league: 'esp.1' },
      'serie a': { sport: 'soccer', league: 'ita.1' },
      'bundesliga': { sport: 'soccer', league: 'ger.1' },
      'ligue 1': { sport: 'soccer', league: 'fra.1' },
      'champions league': { sport: 'soccer', league: 'uefa.champions' },
      'europa league': { sport: 'soccer', league: 'uefa.europa' },
      'mls': { sport: 'soccer', league: 'usa.1' },
      'liga mx': { sport: 'soccer', league: 'mex.1' },
      'brasileirao': { sport: 'soccer', league: 'bra.1' },
      'j league': { sport: 'soccer', league: 'jpn.1' },
      'saudi league': { sport: 'soccer', league: 'sau.1' },
      'eredivisie': { sport: 'soccer', league: 'ned.1' },
      'world cup': { sport: 'soccer', league: 'fifa.world' },
      'copa america': { sport: 'soccer', league: 'conmebol.america' },
      'euros': { sport: 'soccer', league: 'uefa.euro' },
      'afcon': { sport: 'soccer', league: 'caf.nations' },
      // Basketball
      'nba': { sport: 'basketball', league: 'nba' },
      'wnba': { sport: 'basketball', league: 'wnba' },
      'ncaa basketball': { sport: 'basketball', league: 'mens-college-basketball' },
      'march madness': { sport: 'basketball', league: 'mens-college-basketball' },
      // Football
      'nfl': { sport: 'football', league: 'nfl' },
      'college football': { sport: 'football', league: 'college-football' },
      'ncaa football': { sport: 'football', league: 'college-football' },
      // Baseball
      'mlb': { sport: 'baseball', league: 'mlb' },
      // Hockey
      'nhl': { sport: 'hockey', league: 'nhl' },
      // Tennis
      'atp': { sport: 'tennis', league: 'atp' },
      'wta': { sport: 'tennis', league: 'wta' },
      // Golf
      'pga': { sport: 'golf', league: 'pga' },
      'lpga': { sport: 'golf', league: 'lpga' },
      // MMA
      'ufc': { sport: 'mma', league: 'ufc' },
      // Racing
      'f1': { sport: 'racing', league: 'f1' },
      'formula 1': { sport: 'racing', league: 'f1' },
      'nascar': { sport: 'racing', league: 'nascar-cup' },
      'motogp': { sport: 'racing', league: 'motogp' },
      'indycar': { sport: 'racing', league: 'indycar' },
      // Cricket
      'ipl': { sport: 'cricket', league: 'ipl' },
      'big bash': { sport: 'cricket', league: 'bbl' },
      't20 world cup': { sport: 'cricket', league: 't20-world-cup' },
      // Rugby
      'six nations': { sport: 'rugby', league: 'six-nations' },
      'super rugby': { sport: 'rugby', league: 'super-rugby' },
      // AFL
      'afl': { sport: 'afl', league: 'afl' },
    };

    // Resolve league from user input
    function resolveLeague(input) {
      const lower = input.toLowerCase().trim();
      
      // Check direct alias
      if (LEAGUE_ALIASES[lower]) {
        return LEAGUE_ALIASES[lower];
      }
      
      // Check partial matches
      for (const [alias, config] of Object.entries(LEAGUE_ALIASES)) {
        if (lower.includes(alias) || alias.includes(lower)) {
          return config;
        }
      }
      
      // Check ALL_SPORTS leagues
      for (const [sport, config] of Object.entries(ALL_SPORTS)) {
        for (const [leagueId, leagueName] of Object.entries(config.leagues)) {
          if (leagueName.toLowerCase().includes(lower) || lower.includes(leagueName.toLowerCase())) {
            return { sport, league: leagueId };
          }
        }
      }
      
      return null;
    }

    // ============================================
    // ğŸ° BWANABET.COM CONFIGURATION
    // ============================================
    // ğŸ‘‡ CONFIGURE YOUR BWANABET API ENDPOINTS BELOW ğŸ‘‡
    
    const BWANABET_CONFIG = {
      // Base URL for bwanabet API
      baseUrl: 'https://bwanabet.com',
      
      // API endpoints - UPDATE THESE with actual bwanabet endpoints
      endpoints: {
        // Odds endpoints
        odds: {
          soccer: '/api/odds/soccer',      // Example: Update with real endpoint
          basketball: '/api/odds/basketball',
          football: '/api/odds/football',
          tennis: '/api/odds/tennis',
          all: '/api/odds/all',
        },
        // Casino endpoints
        casino: {
          games: '/api/casino/games',
          slots: '/api/casino/slots',
          liveDealer: '/api/casino/live-dealer',
          tableGames: '/api/casino/table-games',
          jackpots: '/api/casino/jackpots',
        },
        // Live betting
        liveBetting: '/api/live/events',
      },
      
      // Authentication (if required)
      auth: {
        apiKey: '',           // Add API key if needed
        authHeader: '',       // e.g., 'Authorization' or 'X-API-Key'
      },
      
      // Request headers
      headers: {
        'Content-Type': 'application/json',
        // Add any required headers here
      },
    };

    // ============================================
    // DYNAMIC GAMES FETCHER - ANY SPORT, ANY LEAGUE
    // ============================================

    async function fetchGames(sportOrLeague, leagueId = null) {
      let sport, league;
      
      // Try to resolve from alias first
      const resolved = resolveLeague(sportOrLeague);
      if (resolved) {
        sport = resolved.sport;
        league = resolved.league;
      } else if (leagueId) {
        sport = sportOrLeague;
        league = leagueId;
      } else {
        // Try direct sport lookup with default league
        if (ALL_SPORTS[sportOrLeague]) {
          sport = sportOrLeague;
          league = Object.keys(ALL_SPORTS[sportOrLeague].leagues)[0];
        } else {
          return { 
            error: `Unknown sport/league: ${sportOrLeague}`,
            hint: 'Try "Premier League", "NBA", "La Liga", "UFC", "Champions League", etc.',
            availableSports: Object.keys(ALL_SPORTS),
          };
        }
      }

      const url = buildUrl(sport, league, 'scoreboard');
      if (!url) {
        return { error: `Could not build URL for ${sport}/${league}` };
      }

      console.log(`ğŸŸï¸ Fetching games from: ${url}`);

      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`ESPN API error: ${response.status}`);
        
        const data = await response.json();
        const leagueName = ALL_SPORTS[sport]?.leagues[league] || league;
        
        // Transform ESPN data
        const games = (data.events || []).map(event => {
          const competition = event.competitions?.[0];
          const homeTeam = competition?.competitors?.find(c => c.homeAway === 'home');
          const awayTeam = competition?.competitors?.find(c => c.homeAway === 'away');
          
          return {
            id: event.id,
            name: event.name,
            shortName: event.shortName,
            status: {
              state: event.status?.type?.state,
              detail: event.status?.type?.detail,
              clock: event.status?.displayClock,
            },
            homeTeam: homeTeam ? {
              name: homeTeam.team?.displayName,
              abbreviation: homeTeam.team?.abbreviation,
              score: homeTeam.score || '0',
              logo: homeTeam.team?.logo,
            } : null,
            awayTeam: awayTeam ? {
              name: awayTeam.team?.displayName,
              abbreviation: awayTeam.team?.abbreviation,
              score: awayTeam.score || '0',
              logo: awayTeam.team?.logo,
            } : null,
            venue: competition?.venue?.fullName,
            broadcast: competition?.broadcasts?.[0]?.names?.[0],
            startTime: event.date,
          };
        });

        const liveGames = games.filter(g => g.status.state === 'in');
        const upcomingGames = games.filter(g => g.status.state === 'pre');
        const completedGames = games.filter(g => g.status.state === 'post');

        return {
          sport: sport,
          league: league,
          leagueName: leagueName,
          totalGames: games.length,
          liveGames,
          upcomingGames,
          completedGames,
          allGames: games,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        console.error('Fetch error:', error);
        return { error: error.message, sport, league };
      }
    }

    // Fetch all teams in a league
    async function fetchLeagueTeams(sportOrLeague, leagueId = null) {
      let sport, league;
      
      const resolved = resolveLeague(sportOrLeague);
      if (resolved) {
        sport = resolved.sport;
        league = resolved.league;
      } else if (leagueId) {
        sport = sportOrLeague;
        league = leagueId;
      } else {
        return { error: `Unknown league: ${sportOrLeague}` };
      }

      const url = buildTeamsUrl(sport, league);
      if (!url) return { error: `Could not build teams URL` };

      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        
        const data = await response.json();
        const teams = (data.sports?.[0]?.leagues?.[0]?.teams || []).map(t => ({
          id: t.team.id,
          name: t.team.displayName,
          abbreviation: t.team.abbreviation,
          logo: t.team.logos?.[0]?.href,
        }));

        return {
          sport,
          league,
          leagueName: ALL_SPORTS[sport]?.leagues[league],
          teams,
          totalTeams: teams.length,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        return { error: error.message, sport, league };
      }
    }

    // Search for a team by name across all leagues
    async function searchTeam(teamName) {
      const searchLower = teamName.toLowerCase();
      const results = [];
      
      // Search common leagues
      const searchLeagues = [
        { sport: 'basketball', league: 'nba' },
        { sport: 'football', league: 'nfl' },
        { sport: 'baseball', league: 'mlb' },
        { sport: 'hockey', league: 'nhl' },
        { sport: 'soccer', league: 'eng.1' },
        { sport: 'soccer', league: 'esp.1' },
        { sport: 'soccer', league: 'ger.1' },
        { sport: 'soccer', league: 'ita.1' },
        { sport: 'soccer', league: 'fra.1' },
        { sport: 'soccer', league: 'usa.1' },
      ];

      for (const { sport, league } of searchLeagues) {
        try {
          const url = buildTeamsUrl(sport, league);
          const response = await fetch(url);
          if (!response.ok) continue;
          
          const data = await response.json();
          const teams = data.sports?.[0]?.leagues?.[0]?.teams || [];
          
          for (const t of teams) {
            const name = t.team.displayName?.toLowerCase() || '';
            const abbr = t.team.abbreviation?.toLowerCase() || '';
            if (name.includes(searchLower) || abbr === searchLower || searchLower.includes(name.split(' ').pop())) {
              results.push({
                id: t.team.id,
                name: t.team.displayName,
                abbreviation: t.team.abbreviation,
                sport,
                league,
                leagueName: ALL_SPORTS[sport]?.leagues[league],
                logo: t.team.logos?.[0]?.href,
              });
            }
          }
        } catch (e) {
          continue;
        }
        
        // Limit search to avoid too many requests
        if (results.length >= 5) break;
      }

      return {
        query: teamName,
        results,
        totalFound: results.length,
      };
    }

    // List all available leagues
    function listAvailableLeagues(sportFilter = null) {
      const leagues = [];
      
      for (const [sport, config] of Object.entries(ALL_SPORTS)) {
        if (sportFilter && sport !== sportFilter) continue;
        
        for (const [leagueId, leagueName] of Object.entries(config.leagues)) {
          leagues.push({
            sport,
            sportName: config.name,
            leagueId,
            leagueName,
          });
        }
      }

      return {
        totalLeagues: leagues.length,
        totalSports: sportFilter ? 1 : Object.keys(ALL_SPORTS).length,
        leagues: sportFilter ? leagues : leagues.slice(0, 50), // Limit for readability
        allSports: Object.entries(ALL_SPORTS).map(([id, c]) => ({ id, name: c.name, leagueCount: Object.keys(c.leagues).length })),
      };
    }

    // ============================================
    // STATE
    // ============================================
    
    let API_KEY = HARDCODED_API_KEY;
    let conversationHistory = [];
    let isProcessing = false;

    // ============================================
    // ğŸ‘¤ PLAYER DATABASE SCHEMA & PROFILE SYSTEM
    // ============================================

    // Comprehensive player data model (simulates database)
    const DEFAULT_PLAYER_DATA = {
      // === BASIC PROFILE ===
      profile: {
        id: 'player_' + Date.now(),
        username: '',
        country: '',
        city: '',
        language: 'en',
        currency: 'KES',
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        createdAt: new Date().toISOString(),
        lastLogin: new Date().toISOString(),
        accountStatus: 'active',
      },

      // === BETTING PREFERENCES ===
      preferences: {
        favoriteSports: [],
        favoriteLeagues: [],
        favoriteTeams: [],
        preferredBetTypes: [],
        preferredOddsFormat: 'decimal',
        preferredStakeRange: { min: 100, max: 5000, average: 500 },
        riskTolerance: 'medium',
        preferredOddsRange: { min: 1.30, max: 5.00 },
        notifications: { matchReminders: true, betSuggestions: true, results: true },
      },

      // === BETTING HISTORY ===
      bettingHistory: {
        lifetime: {
          totalBets: 0,
          totalStaked: 0,
          totalWinnings: 0,
          netProfit: 0,
          winRate: 0,
          averageOdds: 0,
          averageStake: 0,
          biggestWin: 0,
          biggestLoss: 0,
          currentStreak: { type: null, count: 0 },
        },
        bySport: {},
        byBetType: {},
        byLeague: {},
        byTeam: {},
        recentBets: [],
        pendingBets: [],
      },

      // === BEHAVIORAL DATA ===
      behavior: {
        activity: {
          loginFrequency: 'new',
          sessionsThisWeek: 0,
          averageSessionDuration: 0,
          peakActivityTimes: [],
          peakActivityDays: [],
          preferredDevice: 'unknown',
        },
        browsing: {
          leagueViews: {},
          teamViews: {},
          recentSearches: [],
          viewedMatches: [],
        },
        engagement: {
          suggestionsViewed: 0,
          suggestionsAccepted: 0,
          suggestionsDismissed: 0,
        },
      },

      // === FINANCIAL DATA ===
      financial: {
        balance: { available: 0, bonus: 0, pending: 0 },
        limits: {
          dailyDeposit: { set: null, used: 0 },
          dailyLoss: { set: null, used: 0 },
          singleBetMax: null,
        },
        averageDeposit: 0,
      },

      // === RESPONSIBLE GAMBLING ===
      responsibleGambling: {
        riskScore: 1,
        riskFactors: [],
        selfControls: {
          depositLimits: false,
          lossLimits: false,
          sessionTimeLimit: null,
        },
        flags: {
          chasingLosses: false,
          increasingStakes: false,
          lateNightBetting: false,
        },
      },

      // === AI PERSONALIZATION ===
      aiPersonalization: {
        learnedPreferences: {
          profitableTeams: [],
          unprofitableTeams: [],
          profitableBetTypes: [],
          unprofitableBetTypes: [],
          profitableLeagues: [],
          optimalOddsRange: { min: 1.50, max: 3.00 },
        },
        recommendations: {
          accepted: [],
          rejected: [],
          dismissed: [],
          acceptanceRate: 0,
        },
        bestTimeToEngage: null,
        preferredMessageStyle: 'detailed',
      },
    };

    // Load player data from Supabase or localStorage
    async function loadPlayerData() {
      // If Supabase is configured and connected
      if (supabaseClient && currentPlayerId) {
        try {
          console.log('ğŸ“¥ Fetching player data from Supabase...');
          const { data, error } = await supabaseClient.rpc('get_player_ai_profile', {
            p_player_id: currentPlayerId
          });
          
          if (error) {
            console.error('âŒ Supabase RPC error:', error);
            console.log('âš ï¸ The get_player_ai_profile function may not exist in your database.');
            console.log('ğŸ“¦ Falling back to localStorage');
          } else if (data) {
            console.log('âœ… Loaded player data from Supabase');
            return transformSupabaseData(data);
          }
        } catch (e) {
          console.error('âŒ Supabase load error:', e);
          console.log('ğŸ“¦ Falling back to localStorage');
        }
      }
      
      // Fallback to localStorage
      try {
        const saved = localStorage.getItem('betassist_player_data');
        if (saved) {
          console.log('ğŸ“¦ Loaded player data from localStorage');
          const data = JSON.parse(saved);
          return deepMerge(DEFAULT_PLAYER_DATA, data);
        }
      } catch (e) {
        console.log('Could not load player data from localStorage');
      }
      
      console.log('ğŸ†• Using default player data');
      return JSON.parse(JSON.stringify(DEFAULT_PLAYER_DATA));
    }

    // Transform Supabase data to match our schema
    function transformSupabaseData(supabaseData) {
      return {
        profile: {
          id: supabaseData.profile?.id || '',
          username: supabaseData.profile?.username || '',
          country: supabaseData.profile?.country || '',
          city: supabaseData.profile?.city || '',
          language: supabaseData.profile?.language || 'en',
          currency: supabaseData.profile?.currency || 'KES',
          timezone: supabaseData.profile?.timezone || '',
          createdAt: supabaseData.profile?.created_at || new Date().toISOString(),
          lastLogin: supabaseData.profile?.last_login || new Date().toISOString(),
          accountStatus: supabaseData.profile?.account_status || 'active',
        },
        preferences: {
          favoriteSports: supabaseData.preferences?.favorite_sports || [],
          favoriteLeagues: supabaseData.preferences?.favorite_leagues || [],
          favoriteTeams: supabaseData.preferences?.favorite_teams || [],
          preferredBetTypes: supabaseData.preferences?.preferred_bet_types || [],
          preferredOddsFormat: supabaseData.preferences?.odds_format || 'decimal',
          preferredStakeRange: {
            min: supabaseData.preferences?.preferred_stake_min || 100,
            max: supabaseData.preferences?.preferred_stake_max || 5000,
            average: supabaseData.preferences?.preferred_stake_avg || 500,
          },
          riskTolerance: supabaseData.preferences?.risk_tolerance || 'medium',
          preferredOddsRange: {
            min: supabaseData.preferences?.preferred_odds_min || 1.30,
            max: supabaseData.preferences?.preferred_odds_max || 5.00,
          },
        },
        bettingHistory: {
          lifetime: {
            totalBets: supabaseData.stats?.total_bets || 0,
            totalStaked: supabaseData.stats?.total_staked || 0,
            totalWinnings: supabaseData.stats?.total_winnings || 0,
            netProfit: supabaseData.stats?.net_profit || 0,
            winRate: supabaseData.stats?.win_rate || 0,
            averageOdds: supabaseData.stats?.average_odds || 0,
            averageStake: supabaseData.stats?.average_stake || 0,
            biggestWin: supabaseData.stats?.biggest_win || 0,
            biggestLoss: supabaseData.stats?.biggest_loss || 0,
            currentStreak: {
              type: supabaseData.stats?.current_streak_type || null,
              count: supabaseData.stats?.current_streak_count || 0,
            },
          },
          recentBets: supabaseData.recentBets || [],
          bySport: {},
          byLeague: {},
        },
        behavior: {
          activity: {
            loginFrequency: supabaseData.behavior?.login_frequency || 'new',
            sessionsThisWeek: supabaseData.behavior?.sessions_this_week || 0,
          },
          browsing: {
            leagueViews: supabaseData.behavior?.league_views || {},
            teamViews: supabaseData.behavior?.team_views || {},
            recentSearches: supabaseData.behavior?.recent_searches || [],
          },
          engagement: {
            suggestionsViewed: supabaseData.behavior?.suggestions_viewed || 0,
            suggestionsAccepted: supabaseData.behavior?.suggestions_accepted || 0,
            suggestionsDismissed: supabaseData.behavior?.suggestions_dismissed || 0,
          },
        },
        financial: {
          balance: {
            available: supabaseData.financial?.balance_available || 0,
            bonus: supabaseData.financial?.balance_bonus || 0,
            pending: supabaseData.financial?.balance_pending || 0,
          },
          limits: {
            dailyDeposit: { 
              set: supabaseData.financial?.daily_deposit_limit, 
              used: supabaseData.financial?.daily_deposit_used || 0 
            },
            dailyLoss: { 
              set: supabaseData.financial?.daily_loss_limit, 
              used: supabaseData.financial?.daily_loss_used || 0 
            },
          },
        },
        responsibleGambling: {
          riskScore: supabaseData.responsibleGambling?.risk_score || 1,
          riskFactors: supabaseData.responsibleGambling?.risk_factors || [],
          selfControls: {
            depositLimits: supabaseData.responsibleGambling?.deposit_limits_enabled || false,
            lossLimits: supabaseData.responsibleGambling?.loss_limits_enabled || false,
            sessionTimeLimit: supabaseData.responsibleGambling?.session_time_limit,
          },
          flags: {
            chasingLosses: supabaseData.responsibleGambling?.chasing_losses_flag || false,
            increasingStakes: supabaseData.responsibleGambling?.increasing_stakes_flag || false,
            lateNightBetting: supabaseData.responsibleGambling?.late_night_betting_flag || false,
          },
        },
        aiPersonalization: {
          learnedPreferences: {
            profitableTeams: supabaseData.aiData?.profitable_teams || [],
            unprofitableTeams: supabaseData.aiData?.unprofitable_teams || [],
            profitableBetTypes: supabaseData.aiData?.profitable_bet_types || [],
            unprofitableBetTypes: supabaseData.aiData?.unprofitable_bet_types || [],
            profitableLeagues: supabaseData.aiData?.profitable_leagues || [],
            optimalOddsRange: {
              min: supabaseData.aiData?.optimal_odds_min || 1.50,
              max: supabaseData.aiData?.optimal_odds_max || 3.00,
            },
          },
          recommendations: {
            accepted: supabaseData.aiData?.accepted_recommendations || [],
            rejected: supabaseData.aiData?.rejected_recommendations || [],
            dismissed: supabaseData.aiData?.dismissed_recommendations || [],
            acceptanceRate: supabaseData.aiData?.acceptance_rate || 0,
          },
        },
      };
    }

    // Save player data to Supabase or localStorage
    async function savePlayerData() {
      // If Supabase is configured
      if (supabaseClient && currentPlayerId) {
        try {
          // Update preferences
          await supabaseClient.from('player_preferences').update({
            favorite_sports: playerData.preferences.favoriteSports,
            favorite_leagues: playerData.preferences.favoriteLeagues,
            favorite_teams: playerData.preferences.favoriteTeams,
            risk_tolerance: playerData.preferences.riskTolerance,
            preferred_stake_avg: playerData.preferences.preferredStakeRange.average,
            updated_at: new Date().toISOString(),
          }).eq('player_id', currentPlayerId);
          
          // Update behavior
          await supabaseClient.from('player_behavior').update({
            league_views: playerData.behavior.browsing.leagueViews,
            team_views: playerData.behavior.browsing.teamViews,
            suggestions_viewed: playerData.behavior.engagement.suggestionsViewed,
            suggestions_accepted: playerData.behavior.engagement.suggestionsAccepted,
            suggestions_dismissed: playerData.behavior.engagement.suggestionsDismissed,
            updated_at: new Date().toISOString(),
          }).eq('player_id', currentPlayerId);
          
          // Update AI data
          await supabaseClient.from('player_ai_data').update({
            profitable_teams: playerData.aiPersonalization.learnedPreferences.profitableTeams,
            unprofitable_teams: playerData.aiPersonalization.learnedPreferences.unprofitableTeams,
            accepted_recommendations: playerData.aiPersonalization.recommendations.accepted,
            rejected_recommendations: playerData.aiPersonalization.recommendations.rejected,
            dismissed_recommendations: playerData.aiPersonalization.recommendations.dismissed,
            acceptance_rate: playerData.aiPersonalization.recommendations.acceptanceRate,
            updated_at: new Date().toISOString(),
          }).eq('player_id', currentPlayerId);
          
          console.log('ğŸ“¤ Saved to Supabase');
          return;
        } catch (e) {
          console.error('Supabase save error:', e);
        }
      }
      
      // Fallback to localStorage
      try {
        playerData.profile.lastLogin = new Date().toISOString();
        localStorage.setItem('betassist_player_data', JSON.stringify(playerData));
      } catch (e) {
        console.log('Could not save player data');
      }
    }

    // Record a bet to Supabase
    async function recordBetToSupabase(betData) {
      if (!supabase || !currentPlayerId) return;
      
      try {
        await supabaseClient.from('bets').insert({
          player_id: currentPlayerId,
          sport: betData.sport,
          league: betData.league,
          league_name: betData.leagueName,
          match_name: betData.matchName,
          bet_type: betData.betType,
          selection: betData.selection,
          odds: betData.odds,
          stake: betData.stake,
          status: betData.status || 'pending',
        });
        console.log('ğŸ“ Bet recorded to Supabase');
      } catch (e) {
        console.error('Error recording bet:', e);
      }
    }

    // Deep merge helper
    function deepMerge(target, source) {
      const result = { ...target };
      for (const key in source) {
        if (source[key] instanceof Object && key in target) {
          result[key] = deepMerge(target[key], source[key]);
        } else {
          result[key] = source[key];
        }
      }
      return result;
    }

    // Current player data (loaded during initialization)
    let playerData = JSON.parse(JSON.stringify(DEFAULT_PLAYER_DATA));

    // ============================================
    // ğŸ“Š PLAYER DATA TRACKING FUNCTIONS
    // ============================================

    // Track league view
    function trackLeagueView(leagueId, leagueName) {
      if (!playerData.behavior.browsing.leagueViews[leagueId]) {
        playerData.behavior.browsing.leagueViews[leagueId] = { name: leagueName, views: 0, lastViewed: null };
      }
      playerData.behavior.browsing.leagueViews[leagueId].views++;
      playerData.behavior.browsing.leagueViews[leagueId].lastViewed = new Date().toISOString();

      // Auto-add to favorites after 3 views
      if (playerData.behavior.browsing.leagueViews[leagueId].views >= 3) {
        const exists = playerData.preferences.favoriteLeagues.find(l => l.id === leagueId);
        if (!exists) {
          playerData.preferences.favoriteLeagues.push({ id: leagueId, name: leagueName, addedAt: new Date().toISOString() });
        }
      }
      savePlayerData();
    }

    // Track team view
    function trackTeamView(teamName, leagueId) {
      const key = `${teamName}|${leagueId}`;
      if (!playerData.behavior.browsing.teamViews[key]) {
        playerData.behavior.browsing.teamViews[key] = { team: teamName, league: leagueId, views: 0, lastViewed: null };
      }
      playerData.behavior.browsing.teamViews[key].views++;
      playerData.behavior.browsing.teamViews[key].lastViewed = new Date().toISOString();

      // Auto-add to favorites after 3 views
      if (playerData.behavior.browsing.teamViews[key].views >= 3) {
        const exists = playerData.preferences.favoriteTeams.find(t => t.name === teamName);
        if (!exists) {
          playerData.preferences.favoriteTeams.push({ name: teamName, league: leagueId, addedAt: new Date().toISOString() });
        }
      }
      savePlayerData();
    }

    // Record a bet (for history tracking)
    function recordBet(betData) {
      playerData.bettingHistory.recentBets.unshift({
        ...betData,
        id: 'bet_' + Date.now(),
        date: new Date().toISOString(),
      });
      
      // Keep only last 100 bets
      playerData.bettingHistory.recentBets = playerData.bettingHistory.recentBets.slice(0, 100);
      
      // Update lifetime stats
      const lifetime = playerData.bettingHistory.lifetime;
      lifetime.totalBets++;
      lifetime.totalStaked += betData.stake;
      
      if (betData.status === 'won') {
        lifetime.totalWinnings += betData.payout;
        lifetime.netProfit += betData.profit;
        if (betData.profit > lifetime.biggestWin) lifetime.biggestWin = betData.profit;
      } else if (betData.status === 'lost') {
        lifetime.netProfit -= betData.stake;
        if (betData.stake > lifetime.biggestLoss) lifetime.biggestLoss = betData.stake;
      }
      
      lifetime.winRate = playerData.bettingHistory.recentBets.filter(b => b.status === 'won').length / 
                         playerData.bettingHistory.recentBets.filter(b => b.status !== 'pending').length || 0;
      
      savePlayerData();
    }

    // Track suggestion interaction
    function trackSuggestionInteraction(suggestionId, action) {
      playerData.behavior.engagement.suggestionsViewed++;
      
      if (action === 'accepted') {
        playerData.behavior.engagement.suggestionsAccepted++;
        playerData.aiPersonalization.recommendations.accepted.push(suggestionId);
      } else if (action === 'rejected') {
        playerData.aiPersonalization.recommendations.rejected.push(suggestionId);
      } else if (action === 'dismissed') {
        playerData.behavior.engagement.suggestionsDismissed++;
        playerData.aiPersonalization.recommendations.dismissed.push(suggestionId);
      }
      
      // Calculate acceptance rate
      const total = playerData.behavior.engagement.suggestionsViewed;
      const accepted = playerData.behavior.engagement.suggestionsAccepted;
      playerData.aiPersonalization.recommendations.acceptanceRate = total > 0 ? accepted / total : 0;
      
      savePlayerData();
    }

    // Update player preferences
    function updatePlayerPreferences(updates) {
      playerData.preferences = deepMerge(playerData.preferences, updates);
      savePlayerData();
      return playerData.preferences;
    }

    // Update player profile
    function updatePlayerProfile(updates) {
      playerData.profile = { ...playerData.profile, ...updates };
      savePlayerData();
      return playerData.profile;
    }

    // ============================================
    // ğŸ¯ AI ANALYSIS FUNCTIONS
    // ============================================

    // Get comprehensive player summary for AI
    function getPlayerSummaryForAI() {
      const topLeagues = Object.entries(playerData.behavior.browsing.leagueViews)
        .sort((a, b) => b[1].views - a[1].views)
        .slice(0, 5)
        .map(([id, data]) => ({ id, name: data.name, views: data.views }));

      const topTeams = Object.entries(playerData.behavior.browsing.teamViews)
        .sort((a, b) => b[1].views - a[1].views)
        .slice(0, 5)
        .map(([key, data]) => ({ name: data.team, league: data.league, views: data.views }));

      return {
        // Profile
        profile: {
          username: playerData.profile.username || 'Player',
          country: playerData.profile.country,
          accountAge: playerData.profile.createdAt,
          lastLogin: playerData.profile.lastLogin,
        },
        
        // Preferences
        preferences: {
          favoriteLeagues: playerData.preferences.favoriteLeagues,
          favoriteTeams: playerData.preferences.favoriteTeams,
          favoriteSports: playerData.preferences.favoriteSports,
          riskTolerance: playerData.preferences.riskTolerance,
          preferredBetTypes: playerData.preferences.preferredBetTypes,
          preferredOddsRange: playerData.preferences.preferredOddsRange,
          preferredStake: playerData.preferences.preferredStakeRange,
        },
        
        // Betting Performance
        performance: {
          totalBets: playerData.bettingHistory.lifetime.totalBets,
          winRate: (playerData.bettingHistory.lifetime.winRate * 100).toFixed(1) + '%',
          netProfit: playerData.bettingHistory.lifetime.netProfit,
          averageStake: playerData.bettingHistory.lifetime.averageStake || playerData.preferences.preferredStakeRange.average,
          currentStreak: playerData.bettingHistory.lifetime.currentStreak,
          biggestWin: playerData.bettingHistory.lifetime.biggestWin,
        },
        
        // Learned Patterns
        patterns: {
          profitableTeams: playerData.aiPersonalization.learnedPreferences.profitableTeams,
          unprofitableTeams: playerData.aiPersonalization.learnedPreferences.unprofitableTeams,
          profitableBetTypes: playerData.aiPersonalization.learnedPreferences.profitableBetTypes,
          profitableLeagues: playerData.aiPersonalization.learnedPreferences.profitableLeagues,
          optimalOddsRange: playerData.aiPersonalization.learnedPreferences.optimalOddsRange,
        },
        
        // Behavior
        behavior: {
          mostViewedLeagues: topLeagues,
          mostViewedTeams: topTeams,
          suggestionAcceptanceRate: (playerData.aiPersonalization.recommendations.acceptanceRate * 100).toFixed(0) + '%',
          totalInteractions: Object.values(playerData.behavior.browsing.leagueViews).reduce((a, b) => a + b.views, 0),
        },
        
        // Responsible Gambling Status
        responsibleGambling: {
          riskScore: playerData.responsibleGambling.riskScore,
          hasLimits: playerData.responsibleGambling.selfControls.depositLimits || playerData.responsibleGambling.selfControls.lossLimits,
          flags: playerData.responsibleGambling.flags,
        },
        
        // Financial Context
        financial: {
          balance: playerData.financial.balance.available,
          dailyLimitRemaining: playerData.financial.limits.dailyDeposit.set 
            ? playerData.financial.limits.dailyDeposit.set - playerData.financial.limits.dailyDeposit.used 
            : 'No limit set',
        },
      };
    }

    // Check if we should show responsible gambling warning
    function checkResponsibleGamblingStatus() {
      const rg = playerData.responsibleGambling;
      const warnings = [];
      
      // Check loss limit
      if (playerData.financial.limits.dailyLoss.set) {
        const remaining = playerData.financial.limits.dailyLoss.set - playerData.financial.limits.dailyLoss.used;
        if (remaining <= 0) {
          warnings.push({ type: 'limit_reached', message: 'You have reached your daily loss limit.' });
        } else if (remaining < playerData.financial.limits.dailyLoss.set * 0.2) {
          warnings.push({ type: 'limit_close', message: `Only ${remaining} remaining of your daily loss limit.` });
        }
      }
      
      // Check for concerning patterns
      if (rg.flags.chasingLosses) {
        warnings.push({ type: 'pattern', message: 'We noticed you may be chasing losses. Consider taking a break.' });
      }
      
      if (rg.riskScore >= 7) {
        warnings.push({ type: 'risk', message: 'Please gamble responsibly. Support: 1-800-522-4700' });
      }
      
      return warnings;
    }

    // Find league name from ID
    function findLeagueName(leagueId) {
      for (const [sport, config] of Object.entries(ALL_SPORTS)) {
        if (config.leagues[leagueId]) {
          return config.leagues[leagueId];
        }
      }
      return leagueId;
    }

    // ============================================
    // ğŸ¯ SMART RECOMMENDATIONS ENGINE
    // ============================================

    async function generateRecommendations() {
      const playerSummary = getPlayerSummaryForAI();
      const rgWarnings = checkResponsibleGamblingStatus();
      const recommendations = [];

      // Check responsible gambling first
      if (rgWarnings.some(w => w.type === 'limit_reached')) {
        return {
          playerProfile: playerSummary,
          recommendations: [],
          warning: rgWarnings[0].message,
          message: 'No suggestions available - daily limit reached. Please gamble responsibly.',
        };
      }

      // Get leagues to analyze (favorites first, then most viewed)
      let leaguesToAnalyze = playerData.preferences.favoriteLeagues.map(l => l.id);
      
      // Add most viewed leagues not already in favorites
      const topViewed = Object.entries(playerData.behavior.browsing.leagueViews)
        .sort((a, b) => b[1].views - a[1].views)
        .slice(0, 3)
        .map(([league]) => league);
      
      for (const league of topViewed) {
        if (!leaguesToAnalyze.includes(league)) {
          leaguesToAnalyze.push(league);
        }
      }

      // Default to popular leagues if no history
      if (leaguesToAnalyze.length === 0) {
        leaguesToAnalyze = ['eng.1', 'esp.1', 'nba', 'nfl'];
      }

      // Analyze each league for good betting opportunities
      for (const leagueId of leaguesToAnalyze.slice(0, 4)) {
        try {
          const resolved = resolveLeague(leagueId) || { sport: 'soccer', league: leagueId };
          const gamesData = await fetchGames(leagueId);
          
          if (gamesData.error || !gamesData.upcomingGames) continue;

          // Analyze upcoming games
          for (const game of gamesData.upcomingGames.slice(0, 5)) {
            if (!game.homeTeam || !game.awayTeam) continue;

            // Check if dismissed
            const recId = `rec_${game.id}`;
            if (playerData.aiPersonalization.recommendations.dismissed.includes(recId)) continue;

            // Get team stats for analysis
            const analysis = await analyzeMatchup(game.homeTeam.name, game.awayTeam.name, resolved.league);
            
            if (analysis && analysis.confidence !== 'Low') {
              // Check if favorite team involved
              const favoriteTeamInvolved = playerData.preferences.favoriteTeams.some(
                t => t.name === game.homeTeam.name || t.name === game.awayTeam.name
              );

              // Check if in player's profitable patterns
              const isProfitableTeam = playerData.aiPersonalization.learnedPreferences.profitableTeams.some(
                t => t.team === analysis.favorite
              );

              recommendations.push({
                id: recId,
                type: 'match_recommendation',
                league: leagueId,
                leagueName: gamesData.leagueName,
                match: {
                  home: game.homeTeam.name,
                  away: game.awayTeam.name,
                  startTime: game.startTime,
                  venue: game.venue,
                },
                analysis: analysis,
                personalization: {
                  favoriteTeamInvolved,
                  isProfitableTeam,
                  matchesRiskTolerance: checkRiskTolerance(analysis.favoriteOdds),
                  matchesOddsPreference: checkOddsPreference(parseFloat(analysis.favoriteOdds)),
                },
                reason: generateRecommendationReason(analysis, playerSummary, favoriteTeamInvolved, isProfitableTeam),
                suggestedStake: calculateSuggestedStake(analysis.confidence, parseFloat(analysis.favoriteProb)),
              });
            }
          }
        } catch (e) {
          console.log(`Could not analyze league ${leagueId}:`, e);
        }
      }

      // Sort by personalization score and confidence
      recommendations.sort((a, b) => {
        // Prioritize favorite teams
        if (a.personalization.favoriteTeamInvolved && !b.personalization.favoriteTeamInvolved) return -1;
        if (b.personalization.favoriteTeamInvolved && !a.personalization.favoriteTeamInvolved) return 1;
        
        // Then by confidence
        if (a.analysis.confidence === 'High' && b.analysis.confidence !== 'High') return -1;
        if (b.analysis.confidence === 'High' && a.analysis.confidence !== 'High') return 1;
        
        // Then by probability
        return parseFloat(b.analysis.favoriteProb) - parseFloat(a.analysis.favoriteProb);
      });

      return {
        playerProfile: playerSummary,
        recommendations: recommendations.slice(0, 10),
        warnings: rgWarnings,
        generatedAt: new Date().toISOString(),
        basedOn: leaguesToAnalyze.map(l => findLeagueName(l)),
      };
    }

    // Check if odds match player's risk tolerance
    function checkRiskTolerance(odds) {
      const decimalOdds = parseFloat(odds);
      const tolerance = playerData.preferences.riskTolerance;
      
      switch (tolerance) {
        case 'low': return decimalOdds <= 1.80;
        case 'medium': return decimalOdds >= 1.40 && decimalOdds <= 3.00;
        case 'high': return decimalOdds >= 2.00;
        default: return true;
      }
    }

    // Check if odds are in player's preferred range
    function checkOddsPreference(odds) {
      const range = playerData.preferences.preferredOddsRange;
      return odds >= range.min && odds <= range.max;
    }

    // Calculate suggested stake based on confidence and probability
    function calculateSuggestedStake(confidence, probability) {
      const baseStake = playerData.preferences.preferredStakeRange.average || 500;
      
      let multiplier = 1;
      if (confidence === 'High' && probability > 65) multiplier = 1.2;
      if (confidence === 'Low') multiplier = 0.5;
      
      const suggested = Math.round(baseStake * multiplier / 100) * 100;
      return Math.min(suggested, playerData.preferences.preferredStakeRange.max);
    }

    // Quick matchup analysis for recommendations
    async function analyzeMatchup(homeTeam, awayTeam, league) {
      try {
        // Search for teams
        const homeSearch = await searchTeam(homeTeam);
        const awaySearch = await searchTeam(awayTeam);

        if (homeSearch.totalFound === 0 || awaySearch.totalFound === 0) {
          return null;
        }

        const home = homeSearch.results[0];
        const away = awaySearch.results[0];

        // Get basic stats
        const homeUrl = buildUrl(home.sport, home.league, `teams/${home.id}`);
        const awayUrl = buildUrl(away.sport, away.league, `teams/${away.id}`);

        const [homeRes, awayRes] = await Promise.all([
          fetch(homeUrl).then(r => r.json()).catch(() => null),
          fetch(awayUrl).then(r => r.json()).catch(() => null),
        ]);

        if (!homeRes?.team || !awayRes?.team) return null;

        // Extract records
        const homeRecord = homeRes.team.record?.items?.[0];
        const awayRecord = awayRes.team.record?.items?.[0];

        const homeStats = {};
        const awayStats = {};
        (homeRecord?.stats || []).forEach(s => { homeStats[s.name] = s.value; });
        (awayRecord?.stats || []).forEach(s => { awayStats[s.name] = s.value; });

        const homeWinPct = homeStats.winPercent || 0.5;
        const awayWinPct = awayStats.winPercent || 0.5;

        // Calculate probabilities (home advantage factor)
        const homeAdvantage = 0.05;
        let homeProb = (homeWinPct + homeAdvantage) / (homeWinPct + awayWinPct + homeAdvantage);
        let awayProb = 1 - homeProb;

        // Determine favorite
        const favorite = homeProb > awayProb ? 'home' : 'away';
        const favoriteProb = Math.max(homeProb, awayProb) * 100;
        const favoriteTeam = favorite === 'home' ? homeTeam : awayTeam;
        const favoriteOdds = probabilityToDecimalOdds(Math.max(homeProb, awayProb));

        // Confidence based on data quality and probability difference
        let confidence = 'Medium';
        if (favoriteProb > 65 && homeRecord && awayRecord) confidence = 'High';
        if (favoriteProb < 55 || !homeRecord || !awayRecord) confidence = 'Low';

        return {
          homeTeam,
          awayTeam,
          homeWinPct: (homeWinPct * 100).toFixed(1) + '%',
          awayWinPct: (awayWinPct * 100).toFixed(1) + '%',
          homeProb: (homeProb * 100).toFixed(1) + '%',
          awayProb: (awayProb * 100).toFixed(1) + '%',
          favorite: favoriteTeam,
          favoriteProb: favoriteProb.toFixed(1),
          favoriteOdds,
          confidence,
          homeRecord: homeRecord?.summary || 'N/A',
          awayRecord: awayRecord?.summary || 'N/A',
        };

      } catch (e) {
        console.log('Matchup analysis error:', e);
        return null;
      }
    }

    function probabilityToDecimalOdds(prob) {
      return (1 / prob).toFixed(2);
    }

    function generateRecommendationReason(analysis, profile, favoriteTeamInvolved, isProfitableTeam) {
      const reasons = [];
      
      if (favoriteTeamInvolved) {
        reasons.push(`â­ Your favorite team is playing!`);
      }

      if (isProfitableTeam) {
        reasons.push(`ğŸ“ˆ You have a good track record betting on ${analysis.favorite}`);
      }
      
      if (parseFloat(analysis.favoriteProb) > 65) {
        reasons.push(`${analysis.favorite} has a strong ${analysis.favoriteProb}% win probability`);
      }
      
      if (analysis.confidence === 'High') {
        reasons.push('High confidence based on season data');
      }

      if (analysis.homeRecord && analysis.homeRecord !== 'N/A') {
        reasons.push(`Form: ${analysis.homeTeam} (${analysis.homeRecord}) vs ${analysis.awayTeam} (${analysis.awayRecord})`);
      }

      if (reasons.length === 0) {
        reasons.push('Based on current team statistics');
      }

      return reasons.join('. ');
    }

    // Get personalized suggestions for a specific league
    async function getLeagueSuggestions(leagueInput) {
      const resolved = resolveLeague(leagueInput);
      if (!resolved) {
        return { error: `Unknown league: ${leagueInput}` };
      }

      // Track this league view
      const leagueName = ALL_SPORTS[resolved.sport]?.leagues[resolved.league] || leagueInput;
      trackLeagueView(resolved.league, leagueName);

      const gamesData = await fetchGames(leagueInput);
      if (gamesData.error) return gamesData;

      const suggestions = [];
      const rgWarnings = checkResponsibleGamblingStatus();

      // Analyze upcoming games for best opportunities
      for (const game of (gamesData.upcomingGames || []).slice(0, 8)) {
        if (!game.homeTeam || !game.awayTeam) continue;

        const analysis = await analyzeMatchup(game.homeTeam.name, game.awayTeam.name, resolved.league);
        
        if (analysis) {
          // Track team views
          trackTeamView(game.homeTeam.name, resolved.league);
          trackTeamView(game.awayTeam.name, resolved.league);

          // Check personalization factors
          const favoriteTeamInvolved = playerData.preferences.favoriteTeams.some(
            t => t.name === game.homeTeam.name || t.name === game.awayTeam.name
          );

          suggestions.push({
            match: `${game.awayTeam.name} @ ${game.homeTeam.name}`,
            startTime: game.startTime,
            venue: game.venue,
            analysis,
            suggestedBet: analysis.favorite,
            odds: analysis.favoriteOdds,
            confidence: analysis.confidence,
            winProbability: analysis.favoriteProb + '%',
            favoriteTeamInvolved,
            suggestedStake: calculateSuggestedStake(analysis.confidence, parseFloat(analysis.favoriteProb)),
          });
        }
      }

      // Sort by confidence, then favorite team, then probability
      suggestions.sort((a, b) => {
        if (a.favoriteTeamInvolved && !b.favoriteTeamInvolved) return -1;
        if (b.favoriteTeamInvolved && !a.favoriteTeamInvolved) return 1;
        if (a.confidence === 'High' && b.confidence !== 'High') return -1;
        if (b.confidence === 'High' && a.confidence !== 'High') return 1;
        return parseFloat(b.winProbability) - parseFloat(a.winProbability);
      });

      return {
        league: leagueInput,
        leagueName: gamesData.leagueName,
        totalUpcoming: gamesData.upcomingGames?.length || 0,
        suggestions: suggestions.slice(0, 6),
        playerFavorite: playerData.preferences.favoriteLeagues.some(l => l.id === resolved.league),
        warnings: rgWarnings,
        playerContext: {
          riskTolerance: playerData.preferences.riskTolerance,
          preferredStake: playerData.preferences.preferredStakeRange.average,
          favoriteTeamsInLeague: playerData.preferences.favoriteTeams.filter(t => t.league === resolved.league),
        },
        disclaimer: 'âš ï¸ These are statistical suggestions based on team performance. Gambling involves risk - never bet more than you can afford to lose.',
      };
    }

    // ============================================
    // TEAM ANALYTICS FUNCTIONS
    // ============================================

    async function fetchTeamStats(teamName, leagueInput = null) {
      // First, search for the team
      const searchResults = await searchTeam(teamName);
      
      if (searchResults.totalFound === 0) {
        return { 
          error: `Team "${teamName}" not found`,
          hint: 'Try the full team name like "Manchester United" or "Los Angeles Lakers"',
        };
      }

      // Use first result or filter by league
      let team = searchResults.results[0];
      if (leagueInput) {
        const resolved = resolveLeague(leagueInput);
        if (resolved) {
          const match = searchResults.results.find(t => t.sport === resolved.sport && t.league === resolved.league);
          if (match) team = match;
        }
      }

      const url = buildUrl(team.sport, team.league, `teams/${team.id}`);
      
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        
        const data = await response.json();
        const teamData = data.team;
        
        // Get record and stats
        const record = teamData.record?.items?.[0];
        const stats = {};
        (record?.stats || []).forEach(s => { stats[s.name] = s.value; });

        return {
          team: {
            name: teamData.displayName,
            abbreviation: teamData.abbreviation,
            logo: teamData.logos?.[0]?.href,
            sport: team.sport,
            league: team.league,
            leagueName: ALL_SPORTS[team.sport]?.leagues[team.league],
          },
          record: {
            overall: record?.summary || 'N/A',
            wins: stats.wins || 0,
            losses: stats.losses || 0,
            winPercentage: stats.winPercent ? (stats.winPercent * 100).toFixed(1) + '%' : 'N/A',
            pointsFor: stats.pointsFor || stats.avgPointsFor || 'N/A',
            pointsAgainst: stats.pointsAgainst || stats.avgPointsAgainst || 'N/A',
          },
          standings: teamData.standingSummary || 'N/A',
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        return { error: error.message, team: teamName };
      }
    }

    async function fetchHeadToHead(team1Name, team2Name, leagueInput = null) {
      const team1Stats = await fetchTeamStats(team1Name, leagueInput);
      const team2Stats = await fetchTeamStats(team2Name, leagueInput);

      if (team1Stats.error) return { error: `Team 1: ${team1Stats.error}` };
      if (team2Stats.error) return { error: `Team 2: ${team2Stats.error}` };

      const probability = calculateMatchProbability(team1Stats, team2Stats);

      return {
        team1: {
          name: team1Stats.team.name,
          record: team1Stats.record.overall,
          winPct: team1Stats.record.winPercentage,
        },
        team2: {
          name: team2Stats.team.name,
          record: team2Stats.record.overall,
          winPct: team2Stats.record.winPercentage,
        },
        analysis: probability,
        fetchedAt: new Date().toISOString(),
      };
    }

    async function fetchLeagueStandings(leagueInput) {
      const resolved = resolveLeague(leagueInput);
      if (!resolved) {
        return { error: `Unknown league: ${leagueInput}` };
      }

      const url = buildStandingsUrl(resolved.sport, resolved.league);
      if (!url) return { error: `Standings not available for ${leagueInput}` };

      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        
        const data = await response.json();
        const standings = [];

        // Parse standings - structure varies by sport
        const groups = data.children || [data];
        for (const group of groups) {
          const groupName = group.name || '';
          const entries = group.standings?.entries || [];
          
          for (const entry of entries) {
            const team = entry.team;
            const stats = {};
            (entry.stats || []).forEach(s => { stats[s.name] = s.value; });
            
            standings.push({
              group: groupName,
              rank: stats.playoffSeed || stats.rank || 'N/A',
              team: team.displayName,
              played: stats.gamesPlayed || stats.played || 'N/A',
              wins: stats.wins || 0,
              draws: stats.ties || stats.draws || 0,
              losses: stats.losses || 0,
              points: stats.points || 'N/A',
              winPct: stats.winPercent ? (stats.winPercent * 100).toFixed(1) + '%' : 'N/A',
              goalsFor: stats.pointsFor || stats.goalsFor || 'N/A',
              goalsAgainst: stats.pointsAgainst || stats.goalsAgainst || 'N/A',
            });
          }
        }

        return {
          league: leagueInput,
          leagueName: ALL_SPORTS[resolved.sport]?.leagues[resolved.league],
          standings: standings.slice(0, 25),
          totalTeams: standings.length,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        return { error: error.message, league: leagueInput };
      }
    }

    // ============================================
    // PROBABILITY CALCULATION ENGINE
    // ============================================

    function calculateMatchProbability(team1Stats, team2Stats) {
      // Extract key metrics
      const t1 = {
        winPct: parseFloat(team1Stats.record.winPercentage) / 100 || 0.5,
        form: parseFormPercentage(team1Stats.form.last10),
        ppg: parseFloat(team1Stats.record.pointsFor) || 100,
        papg: parseFloat(team1Stats.record.pointsAgainst) || 100,
      };
      
      const t2 = {
        winPct: parseFloat(team2Stats.record.winPercentage) / 100 || 0.5,
        form: parseFormPercentage(team2Stats.form.last10),
        ppg: parseFloat(team2Stats.record.pointsFor) || 100,
        papg: parseFloat(team2Stats.record.pointsAgainst) || 100,
      };

      // Calculate various probability factors
      
      // 1. Win percentage factor (40% weight)
      const winPctFactor = t1.winPct / (t1.winPct + t2.winPct);
      
      // 2. Recent form factor (30% weight)
      const formFactor = t1.form / (t1.form + t2.form + 0.001);
      
      // 3. Offensive/Defensive efficiency (30% weight)
      const t1Efficiency = t1.ppg / (t1.papg + 0.001);
      const t2Efficiency = t2.ppg / (t2.papg + 0.001);
      const efficiencyFactor = t1Efficiency / (t1Efficiency + t2Efficiency);

      // Weighted probability
      const team1Prob = (winPctFactor * 0.4) + (formFactor * 0.3) + (efficiencyFactor * 0.3);
      const team2Prob = 1 - team1Prob;

      // Convert to odds
      const team1Odds = probabilityToAmericanOdds(team1Prob);
      const team2Odds = probabilityToAmericanOdds(team2Prob);
      const team1Decimal = (1 / team1Prob).toFixed(2);
      const team2Decimal = (1 / team2Prob).toFixed(2);

      // Confidence level based on data quality
      const confidence = calculateConfidence(team1Stats, team2Stats);

      return {
        team1Probability: (team1Prob * 100).toFixed(1) + '%',
        team2Probability: (team2Prob * 100).toFixed(1) + '%',
        impliedOdds: {
          team1: {
            american: team1Odds,
            decimal: team1Decimal,
          },
          team2: {
            american: team2Odds,
            decimal: team2Decimal,
          },
        },
        factors: {
          seasonRecord: {
            team1: team1Stats.record.winPercentage,
            team2: team2Stats.record.winPercentage,
            weight: '40%',
          },
          recentForm: {
            team1: team1Stats.form.last10,
            team2: team2Stats.form.last10,
            weight: '30%',
          },
          efficiency: {
            team1: `${t1.ppg.toFixed(1)} PPG / ${t1.papg.toFixed(1)} PAPG`,
            team2: `${t2.ppg.toFixed(1)} PPG / ${t2.papg.toFixed(1)} PAPG`,
            weight: '30%',
          },
        },
        confidence: confidence,
        disclaimer: 'âš ï¸ These probabilities are estimates based on available statistics. Gambling involves risk and past performance does not guarantee future results.',
      };
    }

    function parseFormPercentage(form) {
      if (!form || form === 'N/A') return 0.5;
      const parts = form.split('-');
      if (parts.length !== 2) return 0.5;
      const wins = parseInt(parts[0]) || 0;
      const total = wins + (parseInt(parts[1]) || 0);
      return total > 0 ? wins / total : 0.5;
    }

    function probabilityToAmericanOdds(prob) {
      if (prob >= 0.5) {
        const odds = Math.round(-(prob / (1 - prob)) * 100);
        return odds;
      } else {
        const odds = Math.round(((1 - prob) / prob) * 100);
        return '+' + odds;
      }
    }

    function calculateConfidence(team1Stats, team2Stats) {
      let score = 0;
      
      // Check data availability
      if (team1Stats.record.winPercentage !== 'N/A') score += 25;
      if (team2Stats.record.winPercentage !== 'N/A') score += 25;
      if (team1Stats.form.recentGames.length >= 5) score += 15;
      if (team2Stats.form.recentGames.length >= 5) score += 15;
      if (team1Stats.record.pointsFor !== 'N/A') score += 10;
      if (team2Stats.record.pointsFor !== 'N/A') score += 10;

      if (score >= 80) return 'High';
      if (score >= 50) return 'Medium';
      return 'Low';
    }

    // Calculate payout
    function calculatePayout(odds, stake) {
      let profit;
      if (odds > 0) {
        profit = (stake * odds) / 100;
      } else {
        profit = (stake * 100) / Math.abs(odds);
      }
      
      const impliedProb = odds > 0 
        ? 100 / (odds + 100) 
        : Math.abs(odds) / (Math.abs(odds) + 100);

      return {
        odds: odds,
        stake: stake,
        profit: profit.toFixed(2),
        totalReturn: (stake + profit).toFixed(2),
        impliedProbability: (impliedProb * 100).toFixed(1) + '%',
      };
    }

    // ============================================
    // BWANABET API FUNCTIONS
    // ============================================

    async function fetchBwanabetOdds(sport = 'all') {
      const endpoint = BWANABET_CONFIG.endpoints.odds[sport] || BWANABET_CONFIG.endpoints.odds.all;
      const url = BWANABET_CONFIG.baseUrl + endpoint;
      
      console.log(`ğŸ² Fetching odds from bwanabet: ${url}`);
      
      try {
        const headers = { ...BWANABET_CONFIG.headers };
        
        // Add auth header if configured
        if (BWANABET_CONFIG.auth.apiKey && BWANABET_CONFIG.auth.authHeader) {
          headers[BWANABET_CONFIG.auth.authHeader] = BWANABET_CONFIG.auth.apiKey;
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: headers,
          mode: 'cors', // May need to adjust based on bwanabet's CORS policy
        });

        if (!response.ok) {
          throw new Error(`Bwanabet API error: ${response.status}`);
        }

        const data = await response.json();
        
        return {
          source: 'bwanabet.com',
          sport: sport,
          data: data,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        console.error('Bwanabet odds fetch error:', error);
        
        // Return mock/fallback data for demo purposes
        return {
          source: 'bwanabet.com',
          sport: sport,
          error: error.message,
          note: 'Could not fetch from bwanabet.com. Check CORS settings or API endpoint configuration.',
          // Fallback demo data
          fallbackData: {
            message: 'Configure BWANABET_CONFIG with correct API endpoints to fetch live odds.',
            exampleOdds: [
              { match: 'Team A vs Team B', homeOdds: 1.85, drawOdds: 3.40, awayOdds: 4.20 },
              { match: 'Team C vs Team D', homeOdds: 2.10, drawOdds: 3.25, awayOdds: 3.50 },
            ]
          },
          fetchedAt: new Date().toISOString(),
        };
      }
    }

    async function fetchBwanabetCasinoGames(category = 'all') {
      let endpoint;
      switch(category) {
        case 'slots': endpoint = BWANABET_CONFIG.endpoints.casino.slots; break;
        case 'live': endpoint = BWANABET_CONFIG.endpoints.casino.liveDealer; break;
        case 'table': endpoint = BWANABET_CONFIG.endpoints.casino.tableGames; break;
        case 'jackpots': endpoint = BWANABET_CONFIG.endpoints.casino.jackpots; break;
        default: endpoint = BWANABET_CONFIG.endpoints.casino.games;
      }
      
      const url = BWANABET_CONFIG.baseUrl + endpoint;
      console.log(`ğŸ° Fetching casino games from bwanabet: ${url}`);
      
      try {
        const headers = { ...BWANABET_CONFIG.headers };
        
        if (BWANABET_CONFIG.auth.apiKey && BWANABET_CONFIG.auth.authHeader) {
          headers[BWANABET_CONFIG.auth.authHeader] = BWANABET_CONFIG.auth.apiKey;
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: headers,
          mode: 'cors',
        });

        if (!response.ok) {
          throw new Error(`Bwanabet Casino API error: ${response.status}`);
        }

        const data = await response.json();
        
        return {
          source: 'bwanabet.com',
          category: category,
          games: data,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        console.error('Bwanabet casino fetch error:', error);
        
        // Return fallback casino data
        return {
          source: 'bwanabet.com',
          category: category,
          error: error.message,
          note: 'Could not fetch from bwanabet.com. Check API endpoint configuration.',
          // Fallback demo data showing what structure we expect
          fallbackData: {
            message: 'Configure BWANABET_CONFIG with correct API endpoints to fetch live casino games.',
            exampleGames: [
              { name: 'Blackjack Classic', category: 'table', rtp: '99.5%', provider: 'Evolution' },
              { name: 'European Roulette', category: 'table', rtp: '97.3%', provider: 'Pragmatic' },
              { name: 'Mega Fortune', category: 'slots', rtp: '96.6%', jackpot: true },
              { name: 'Live Baccarat', category: 'live', rtp: '98.9%', provider: 'Evolution' },
            ]
          },
          fetchedAt: new Date().toISOString(),
        };
      }
    }

    async function fetchBwanabetLiveBetting() {
      const url = BWANABET_CONFIG.baseUrl + BWANABET_CONFIG.endpoints.liveBetting;
      console.log(`âš¡ Fetching live betting from bwanabet: ${url}`);
      
      try {
        const headers = { ...BWANABET_CONFIG.headers };
        
        if (BWANABET_CONFIG.auth.apiKey && BWANABET_CONFIG.auth.authHeader) {
          headers[BWANABET_CONFIG.auth.authHeader] = BWANABET_CONFIG.auth.apiKey;
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: headers,
          mode: 'cors',
        });

        if (!response.ok) {
          throw new Error(`Bwanabet Live API error: ${response.status}`);
        }

        const data = await response.json();
        
        return {
          source: 'bwanabet.com',
          type: 'live_betting',
          events: data,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        console.error('Bwanabet live betting fetch error:', error);
        
        return {
          source: 'bwanabet.com',
          type: 'live_betting',
          error: error.message,
          note: 'Could not fetch live betting data. Check API configuration.',
          fallbackData: {
            message: 'Configure BWANABET_CONFIG to fetch live betting events.',
          },
          fetchedAt: new Date().toISOString(),
        };
      }
    }

    // ============================================
    // TOOL DEFINITIONS FOR CLAUDE
    // ============================================

    const tools = [
      {
        name: 'get_player_profile',
        description: 'Get the current player\'s profile including their favorite leagues, teams, viewing history, and preferences. Use this to personalize recommendations.',
        input_schema: {
          type: 'object',
          properties: {},
          required: [],
        },
      },
      {
        name: 'update_player_preferences',
        description: 'Update the player\'s preferences like favorite leagues, teams, risk tolerance, etc.',
        input_schema: {
          type: 'object',
          properties: {
            favoriteLeagues: {
              type: 'array',
              items: { type: 'string' },
              description: 'List of favorite league IDs (e.g., ["eng.1", "esp.1"])',
            },
            favoriteTeams: {
              type: 'array',
              items: { type: 'object' },
              description: 'List of favorite teams [{name, league}]',
            },
            riskTolerance: {
              type: 'string',
              enum: ['low', 'medium', 'high'],
              description: 'Player\'s risk tolerance for betting suggestions',
            },
          },
          required: [],
        },
      },
      {
        name: 'get_recommendations',
        description: 'Generate personalized betting recommendations based on the player\'s favorite leagues and viewing history. Returns matches with high win probability.',
        input_schema: {
          type: 'object',
          properties: {},
          required: [],
        },
      },
      {
        name: 'get_league_suggestions',
        description: 'Get smart betting suggestions for a specific league. Analyzes upcoming matches and identifies games where one team has a statistical advantage.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league to get suggestions for (e.g., "Premier League", "La Liga")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'get_games',
        description: 'Fetch live, upcoming, and completed games for ANY sport or league worldwide. Supports 100+ leagues including Premier League, La Liga, Serie A, Bundesliga, Champions League, NBA, NFL, MLB, NHL, UFC, F1, Cricket IPL, and many more.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league name (e.g., "Premier League", "NBA", "La Liga", "Champions League", "UFC", "F1", "IPL")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'list_leagues',
        description: 'List all available sports and leagues. Use this when users ask what sports/leagues are available or want to browse options.',
        input_schema: {
          type: 'object',
          properties: {
            sport: {
              type: 'string',
              description: 'Optional: filter by sport (soccer, basketball, football, baseball, hockey, tennis, golf, mma, boxing, rugby, cricket, racing, esports)',
            }
          },
          required: [],
        },
      },
      {
        name: 'search_team',
        description: 'Search for a team by name across all leagues. Use this to find team information when the user mentions a team name.',
        input_schema: {
          type: 'object',
          properties: {
            team_name: {
              type: 'string',
              description: 'The team name to search for (e.g., "Manchester United", "Lakers", "Real Madrid")',
            }
          },
          required: ['team_name'],
        },
      },
      {
        name: 'get_league_teams',
        description: 'Get all teams in a specific league. Use this when users want to see all teams in a competition.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league name (e.g., "Premier League", "NBA", "Serie A")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'get_team_stats',
        description: 'Fetch detailed statistics for a specific team including record, win percentage, recent form, and roster.',
        input_schema: {
          type: 'object',
          properties: {
            team_name: {
              type: 'string',
              description: 'The team name',
            },
            league: {
              type: 'string',
              description: 'Optional: specify the league if team name is ambiguous',
            }
          },
          required: ['team_name'],
        },
      },
      {
        name: 'get_head_to_head',
        description: 'Compare two teams and calculate win probabilities based on their statistics.',
        input_schema: {
          type: 'object',
          properties: {
            team1: {
              type: 'string',
              description: 'First team name',
            },
            team2: {
              type: 'string',
              description: 'Second team name',
            },
            league: {
              type: 'string',
              description: 'Optional: specify league',
            }
          },
          required: ['team1', 'team2'],
        },
      },
      {
        name: 'get_standings',
        description: 'Fetch current league standings/table with team rankings.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league name (e.g., "Premier League", "NBA", "La Liga")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'get_bwanabet_odds',
        description: 'Fetch betting odds from bwanabet.com for any sport.',
        input_schema: {
          type: 'object',
          properties: {
            sport: {
              type: 'string',
              description: 'The sport to get odds for',
            }
          },
          required: ['sport'],
        },
      },
      {
        name: 'get_bwanabet_casino_games',
        description: 'Fetch casino games from bwanabet.com.',
        input_schema: {
          type: 'object',
          properties: {
            category: {
              type: 'string',
              description: 'Category: all, slots, table, live, jackpots',
            }
          },
          required: ['category'],
        },
      },
      {
        name: 'calculate_bet_payout',
        description: 'Calculate potential payout for a bet.',
        input_schema: {
          type: 'object',
          properties: {
            odds: {
              type: 'number',
              description: 'The odds (American or Decimal)',
            },
            stake: {
              type: 'number',
              description: 'Bet amount',
            },
          },
          required: ['odds', 'stake'],
        },
      },
    ];

    // Execute tool calls
    async function executeTool(toolName, toolInput) {
      console.log(`ğŸ”§ Executing tool: ${toolName}`, toolInput);
      
      switch (toolName) {
        case 'get_player_profile':
          return getPlayerSummaryForAI();
        case 'update_player_preferences':
          return updatePlayerPreferences(toolInput);
        case 'get_recommendations':
          return await generateRecommendations();
        case 'get_league_suggestions':
          return await getLeagueSuggestions(toolInput.league);
        case 'get_games':
          return await fetchGames(toolInput.league);
        case 'list_leagues':
          return listAvailableLeagues(toolInput.sport);
        case 'search_team':
          return await searchTeam(toolInput.team_name);
        case 'get_league_teams':
          return await fetchLeagueTeams(toolInput.league);
        case 'get_team_stats':
          return await fetchTeamStats(toolInput.team_name, toolInput.league);
        case 'get_head_to_head':
          return await fetchHeadToHead(toolInput.team1, toolInput.team2, toolInput.league);
        case 'get_standings':
          return await fetchLeagueStandings(toolInput.league);
        case 'get_bwanabet_odds':
          return await fetchBwanabetOdds(toolInput.sport);
        case 'get_bwanabet_casino_games':
          return await fetchBwanabetCasinoGames(toolInput.category);
        case 'calculate_bet_payout':
          return calculatePayout(toolInput.odds, toolInput.stake);
        default:
          return { error: `Unknown tool: ${toolName}` };
      }
    }

    // ============================================
    // SYSTEM PROMPT
    // ============================================

    const SYSTEM_PROMPT = `You are BetAssist, an AI sports betting assistant with FULL ACCESS to the player's database profile. You use this data to provide highly personalized betting recommendations.

## ğŸ‘¤ PLAYER DATA ACCESS

You have access to comprehensive player data via \`get_player_profile\`:

### Profile Data You Can See:
- **Basic Info**: Username, country, account age
- **Preferences**: Favorite leagues, teams, risk tolerance, preferred odds range
- **Betting History**: Total bets, win rate, net profit, biggest wins, current streak
- **Learned Patterns**: Profitable teams, unprofitable patterns, best bet types
- **Behavior**: Most viewed leagues, suggestion acceptance rate
- **Responsible Gambling**: Risk score, limits, any warning flags
- **Financial**: Balance context, daily limits remaining

### How to Use Player Data:

1. **ALWAYS start by checking player profile** for personalization
2. **Prioritize their favorite leagues** in recommendations
3. **Consider their risk tolerance**:
   - Low risk â†’ Only suggest odds â‰¤1.80
   - Medium risk â†’ Odds 1.40-3.00
   - High risk â†’ Can suggest higher odds
4. **Use their betting history**:
   - Recommend teams they've profited on
   - Avoid teams they've lost money on
   - Suggest their successful bet types
5. **Respect limits**: Don't suggest if daily limits reached
6. **Suggested stakes**: Based on their average stake size

## ğŸ¯ PERSONALIZATION FLOW

When player asks for suggestions:

\`\`\`
1. Call get_player_profile
2. Check responsible gambling status
3. If limits reached â†’ Inform player, no suggestions
4. Get their favorite leagues
5. Call get_recommendations or get_league_suggestions
6. Present tailored suggestions with:
   - â­ Highlight if favorite team involved
   - ğŸ“ˆ Note if profitable history with team
   - ğŸ’° Suggest stake based on their average
\`\`\`

## ğŸ“Š RECOMMENDATION TOOLS

| Tool | Use For |
|------|---------|
| \`get_player_profile\` | Get full player context first |
| \`get_recommendations\` | Personalized picks across favorites |
| \`get_league_suggestions\` | Best bets for specific league |
| \`update_player_preferences\` | When player states preferences |

## ğŸ’¬ EXAMPLE PERSONALIZED RESPONSE

"Based on your profile:
- You're a **medium risk** bettor
- Your win rate on **Manchester City** is 72%
- You prefer odds around **1.50-2.50**

ğŸ¯ **Today's Picks for You:**

1. â­ **Man City vs Brighton** (Your team!)
   - Pick: Manchester City
   - Odds: 1.45
   - Your history: 8 wins / 11 bets on City
   - Suggested stake: KES 500

2. **Arsenal vs Wolves**
   - Pick: Arsenal
   - Odds: 1.65
   - Win probability: 68%
   - Suggested stake: KES 400

ğŸ“Š Your daily limit: KES 3,800 remaining
ğŸ”¥ You're on a 2-win streak!"

## âš ï¸ RESPONSIBLE GAMBLING

1. **Check risk flags** before every recommendation
2. If \`chasingLosses\` or \`increasingStakes\` flags â†’ Be supportive, suggest break
3. If daily limit reached â†’ No suggestions, inform player
4. **Always** include gambling risk disclaimer
5. Support line: 1-800-522-4700

## ğŸŒ SPORTS COVERAGE

100+ leagues: Premier League, La Liga, Serie A, Bundesliga, Champions League, NBA, NFL, MLB, NHL, UFC, F1, Cricket, Rugby, Tennis, and more!

## ğŸ’¬ CONVERSATION STYLE

- Personalize based on player data
- Use their name if available
- Reference their betting history
- Celebrate their wins, be supportive on losses
- Always bold **key recommendations** and **probabilities**`;

    // ============================================
    // CLAUDE API WITH TOOL CALLING
    // ============================================

    async function callClaudeWithTools(userMessage) {
      conversationHistory.push({
        role: 'user',
        content: userMessage
      });

      console.log('ğŸ“¤ Sending message to Claude API...');
      console.log('ğŸ“ Message:', userMessage);

      try {
        let response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': API_KEY,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true'
          },
          body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 2048,
            system: SYSTEM_PROMPT,
            tools: tools,
            messages: conversationHistory
          })
        });

        console.log('ğŸ“¥ Response status:', response.status);

        if (!response.ok) {
          const error = await response.json();
          console.error('âŒ API Error:', error);
          throw new Error(error.error?.message || `API request failed with status ${response.status}`);
        }

        let data = await response.json();
        console.log('âœ… Response received:', data.stop_reason);
        
        // Handle tool use loop
        while (data.stop_reason === 'tool_use') {
          const toolUseBlocks = data.content.filter(block => block.type === 'tool_use');
          
          // Add assistant's response (with tool calls) to history
          conversationHistory.push({
            role: 'assistant',
            content: data.content
          });

          // Execute tools and collect results
          const toolResults = [];
          for (const toolUse of toolUseBlocks) {
            updateTypingStatus(`Fetching ${toolUse.input.sport?.toUpperCase() || 'data'}...`);
            
            const result = await executeTool(toolUse.name, toolUse.input);
            console.log(`ğŸ“Š Tool result:`, result);
            
            toolResults.push({
              type: 'tool_result',
              tool_use_id: toolUse.id,
              content: JSON.stringify(result, null, 2)
            });
          }

          // Add tool results to history
          conversationHistory.push({
            role: 'user',
            content: toolResults
          });

          updateTypingStatus('Generating response...');

          // Continue conversation with tool results
          response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'x-api-key': API_KEY,
              'anthropic-version': '2023-06-01',
              'anthropic-dangerous-direct-browser-access': 'true'
            },
            body: JSON.stringify({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 2048,
              system: SYSTEM_PROMPT,
              tools: tools,
              messages: conversationHistory
            })
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error?.message || 'API request failed');
          }

          data = await response.json();
        }

        // Extract final text response
        const textContent = data.content
          .filter(block => block.type === 'text')
          .map(block => block.text)
          .join('\n');

        // Add final response to history
        conversationHistory.push({
          role: 'assistant',
          content: textContent
        });

        // Keep history manageable
        if (conversationHistory.length > 30) {
          conversationHistory = conversationHistory.slice(-30);
        }

        return textContent;

      } catch (error) {
        console.error('Claude API error:', error);
        conversationHistory.pop(); // Remove failed message
        
        if (error.message.includes('Invalid API Key') || error.message.includes('authentication')) {
          return 'âŒ **Invalid API Key**\n\nPlease check your API key and try again.';
        }
        
        return `âŒ **Error**\n\n${error.message}`;
      }
    }

    // ============================================
    // UI FUNCTIONS
    // ============================================

    function updateTypingStatus(status) {
      document.getElementById('typingStatus').textContent = status;
    }

    function clearChat() {
      conversationHistory = [];
      document.getElementById('messages').innerHTML = '';
      addMessage(`ğŸ”„ **Chat cleared!**\n\nHow can I help you? Ask me about live games, odds, or betting!`, false);
    }

    async function sendMessage() {
      if (isProcessing) return;
      
      const input = document.getElementById('messageInput');
      const message = input.value.trim();
      
      if (!message) return;
      
      input.value = '';
      addMessage(message, true);
      
      isProcessing = true;
      document.getElementById('sendButton').disabled = true;
      document.getElementById('typingIndicator').classList.remove('hidden');
      updateTypingStatus('Thinking...');
      
      try {
        const response = await callClaudeWithTools(message);
        addMessage(response, false);
      } catch (error) {
        console.error('âŒ Error in sendMessage:', error);
        addMessage(`âŒ **Error**\n\n${error.message}\n\nPlease check the browser console for details.`, false);
      } finally {
        isProcessing = false;
        document.getElementById('sendButton').disabled = false;
        document.getElementById('typingIndicator').classList.add('hidden');
        updateTypingStatus('');
      }
    }

    function askQuestion(question) {
      document.getElementById('messageInput').value = question;
      sendMessage();
    }

    function addMessage(text, isUser) {
      const container = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `flex ${isUser ? 'justify-end' : 'justify-start'} message-appear`;
      
      messageDiv.innerHTML = `
        <div class="max-w-[90%] rounded-2xl px-4 py-3 ${
          isUser 
            ? 'bg-gradient-to-r from-amber-500 to-orange-500 text-white rounded-br-sm'
            : 'bg-slate-800 text-slate-100 rounded-bl-sm border border-slate-700'
        }">
          ${!isUser ? `
            <div class="flex items-center gap-2 mb-2 pb-2 border-b border-slate-600">
              <div class="w-6 h-6 rounded-full bg-gradient-to-r from-amber-400 to-orange-500 flex items-center justify-center">
                <span class="text-xs">ğŸ¯</span>
              </div>
              <span class="text-xs font-medium text-amber-400">BetAssist AI</span>
              <span class="text-xs text-slate-500">â€¢ Live Data</span>
            </div>
          ` : ''}
          <div class="text-sm whitespace-pre-wrap leading-relaxed">${formatText(text)}</div>
        </div>
      `;
      
      container.appendChild(messageDiv);
      messageDiv.scrollIntoView({ behavior: 'smooth' });
    }

    function formatText(text) {
      return text
        // Bold
        .replace(/\*\*(.*?)\*\*/g, '<strong class="text-amber-300">$1</strong>')
        // Links
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" class="text-amber-400 hover:underline">$1</a>')
        // Line breaks
        .replace(/\n/g, '<br>');
    }

    function addWelcomeMessage() {
      // Get player summary
      const profile = getPlayerSummaryForAI();
      const isReturning = profile.behavior.totalInteractions > 0;
      const hasFavorites = profile.preferences.favoriteLeagues.length > 0;
      const hasHistory = profile.performance.totalBets > 0;

      let welcomeText = `ğŸ‘‹ **Welcome${isReturning ? ' back' : ''} to BetAssist!**\n\n`;

      // Personalized greeting for returning players
      if (hasFavorites) {
        const favLeagueNames = profile.preferences.favoriteLeagues.map(l => l.name).slice(0, 3).join(', ');
        welcomeText += `ğŸ¯ I remember you like **${favLeagueNames}**!\n\n`;
      }

      // Show performance summary if they have history
      if (hasHistory) {
        welcomeText += `ğŸ“Š **Your Stats:**\n`;
        welcomeText += `â€¢ Win Rate: ${profile.performance.winRate}\n`;
        welcomeText += `â€¢ Total Bets: ${profile.performance.totalBets}\n`;
        if (profile.performance.currentStreak.count > 0) {
          welcomeText += `â€¢ Current Streak: ${profile.performance.currentStreak.count} ${profile.performance.currentStreak.type}s ğŸ”¥\n`;
        }
        welcomeText += `\n`;
      }

      // Personalized suggestions
      if (hasFavorites || hasHistory) {
        welcomeText += `**Quick Actions:**\n`;
        welcomeText += `â€¢ "Give me recommendations" - Personalized picks just for you\n`;
        welcomeText += `â€¢ "Premier League suggestions" - Best bets for any league\n`;
        welcomeText += `â€¢ "My profile" - View your preferences & stats\n\n`;
      } else {
        welcomeText += `I provide **personalized betting suggestions** based on your preferences and betting history! ğŸ¯\n\n`;
        welcomeText += `**Get Started:**\n`;
        welcomeText += `â€¢ Tell me your favorite leagues (e.g., "I like Premier League")\n`;
        welcomeText += `â€¢ Ask for suggestions: "Premier League tips"\n`;
        welcomeText += `â€¢ Set your preferences: "I prefer low risk bets"\n\n`;
      }

      welcomeText += `**I cover 100+ leagues worldwide!** âš½ğŸ€ğŸˆğŸ¾\n\n`;
      welcomeText += `What would you like to explore today?`;

      addMessage(welcomeText, false);
    }

    // ============================================
    // INITIALIZATION
    // ============================================

    // Initialize the app
    async function initializeApp() {
      // Initialize Supabase first
      await initSupabase();
      
      // Load player data (from Supabase or localStorage)
      playerData = await loadPlayerData();
      console.log('ğŸ‘¤ Player data loaded:', playerData.profile.username || 'Guest');
      
      // Show welcome message
      addWelcomeMessage();
      
      // Show connection status
      if (supabaseClient && currentPlayerId) {
        console.log('ğŸ—„ï¸ Connected to Supabase database');
      } else {
        console.log('ğŸ“¦ Running in demo mode (localStorage)');
      }
    }

    window.onload = async function() {
      console.log('ğŸš€ BetAssist AI Starting...');
      console.log('ğŸ”‘ API Key configured:', API_KEY ? 'Yes (' + API_KEY.substring(0, 15) + '...)' : 'No');
      
      // Use the hardcoded API key
      API_KEY = HARDCODED_API_KEY;
      
      if (!API_KEY || !API_KEY.startsWith('sk-ant-')) {
        console.error('âŒ No valid API key found!');
        document.getElementById('messages').innerHTML = `
          <div class="bg-red-500/20 border border-red-500 rounded-xl p-4 text-red-200">
            <strong>âš ï¸ API Key Required</strong><br>
            Please add your Claude API key in the code:<br>
            <code class="text-xs bg-slate-800 px-2 py-1 rounded mt-2 inline-block">const HARDCODED_API_KEY = 'sk-ant-api03-...';</code>
          </div>
        `;
        return;
      }
      
      console.log('âœ… API Key valid');
      
      try {
        await initializeApp();
        console.log('ğŸ‰ BetAssist AI Ready!');
      } catch (error) {
        console.error('âŒ Initialization failed:', error);
        document.getElementById('messages').innerHTML = `
          <div class="bg-red-500/20 border border-red-500 rounded-xl p-4 text-red-200">
            <strong>âš ï¸ Initialization Error</strong><br>
            ${error.message}<br>
            <small>Check browser console for details</small>
          </div>
        `;
      }
    };
  </script>
</body>
</html>
