<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BetAssist AI - Personalized Sports Betting Assistant</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes typing-dot {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.5; }
      30% { transform: translateY(-4px); opacity: 1; }
    }
    .typing-dot { animation: typing-dot 1.4s infinite ease-in-out; }
    .typing-dot:nth-child(1) { animation-delay: 0s; }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes message-appear {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .message-appear { animation: message-appear 0.3s ease-out; }
    
    .chat-scroll::-webkit-scrollbar { width: 6px; }
    .chat-scroll::-webkit-scrollbar-track { background: transparent; }
    .chat-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }

    .game-card {
      background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
    }
    
    /* Clickable recommendation buttons */
    .quick-action {
      display: inline-block;
      padding: 8px 16px;
      margin: 4px;
      background: linear-gradient(135deg, #1e3a5f 0%, #0f172a 100%);
      border: 1px solid #3b82f6;
      border-radius: 20px;
      color: #60a5fa;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .quick-action:hover {
      background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
      color: white;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }
    .quick-action:active {
      transform: translateY(0);
    }
    .quick-actions-container {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #334155;
    }
  </style>
</head>
<body class="bg-slate-900 min-h-screen">

  <!-- Main App -->
  <div id="mainApp">
    <!-- Header -->
    <div class="fixed top-0 left-0 right-0 bg-slate-800 border-b border-slate-700 px-4 py-3 z-40">
      <div class="max-w-2xl mx-auto flex items-center justify-between">
        <div class="flex items-center gap-3">
          <div class="w-10 h-10 rounded-xl bg-gradient-to-br from-amber-400 to-orange-500 flex items-center justify-center">
            <span class="text-xl">üéØ</span>
          </div>
          <div>
            <h1 class="font-bold text-white">BetAssist AI</h1>
            <div class="flex items-center gap-1">
              <div class="w-2 h-2 rounded-full bg-emerald-400 animate-pulse"></div>
              <span class="text-xs text-slate-400">Personalized Sports Betting AI</span>
            </div>
          </div>
        </div>
        <div class="flex gap-2">
          <button onclick="clearChat()" class="text-slate-400 hover:text-white p-2 rounded-lg hover:bg-slate-700" title="Clear chat">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <!-- Chat Container -->
    <div class="max-w-2xl mx-auto pt-20 pb-40 px-4">
      <div id="messages" class="space-y-4"></div>
      
      <!-- Typing Indicator -->
      <div id="typingIndicator" class="hidden flex items-center gap-2 p-4">
        <div class="w-8 h-8 rounded-full bg-gradient-to-r from-amber-400 to-orange-500 flex items-center justify-center">
          <span class="text-sm">üéØ</span>
        </div>
        <div class="flex gap-1">
          <div class="w-2 h-2 bg-slate-400 rounded-full typing-dot"></div>
          <div class="w-2 h-2 bg-slate-400 rounded-full typing-dot"></div>
          <div class="w-2 h-2 bg-slate-400 rounded-full typing-dot"></div>
        </div>
        <span id="typingStatus" class="text-xs text-slate-400 ml-2"></span>
      </div>
    </div>

    <!-- Input Area -->
    <div class="fixed bottom-0 left-0 right-0 bg-slate-900 border-t border-slate-700 p-4">
      <div class="max-w-2xl mx-auto">
        <!-- Quick Actions -->
        <div class="flex gap-2 mb-3 overflow-x-auto pb-2">
          <button onclick="askQuestion('Give me your best picks')" class="quick-btn">üéØ Top Picks</button>
          <button onclick="askQuestion('Premier League tips')" class="quick-btn">‚öΩ EPL</button>
          <button onclick="askQuestion('La Liga tips')" class="quick-btn">üá™üá∏ La Liga</button>
          <button onclick="askQuestion('NBA tips')" class="quick-btn">üèÄ NBA</button>
          <button onclick="askQuestion('Show me casino games')" class="quick-btn">üé∞ Casino</button>
          <button onclick="askQuestion('What betting strategies do you recommend?')" class="quick-btn">üìä Strategies</button>
          <button onclick="askQuestion('What bonuses do I have?')" class="quick-btn">üéÅ Bonuses</button>
        </div>
        <style>.quick-btn { @apply flex-shrink-0 px-3 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-xs text-slate-200 whitespace-nowrap transition-all; }</style>
        
        <!-- Input -->
        <div class="flex gap-3">
          <input 
            type="text" 
            id="messageInput" 
            placeholder="Ask about live games, odds, betting, casino..." 
            class="flex-1 bg-slate-800 text-white placeholder-slate-400 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-amber-500 border border-slate-700"
            onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); }"
          >
          <button 
            onclick="sendMessage()" 
            id="sendButton"
            class="px-6 py-3 bg-gradient-to-r from-amber-500 to-orange-500 hover:from-amber-600 hover:to-orange-600 text-white font-semibold rounded-xl transition-all disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Send
          </button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // ============================================
    // ‚öôÔ∏è CONFIGURATION - ADD YOUR API KEYS HERE
    // ============================================
    
    // üîë CLAUDE API KEY - Now stored in Supabase Edge Function (more secure!)
    // You'll set this in Supabase secrets, not here
    const HARDCODED_API_KEY = 'not-needed-using-proxy';
    
    // ============================================
    // üóÑÔ∏è SUPABASE DATABASE (OPTIONAL - for testing)
    // ============================================
    
    const SUPABASE_CONFIG = {
      url: 'https://dumjacmxefrxzcccsyxj.supabase.co',
      anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImR1bWphY214ZWZyeHpjY2NzeXhqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg0NjgwNTgsImV4cCI6MjA4NDA0NDA1OH0.lpzyMwI9Vds91FXm2oxK9Q8OpOYy-uSs3pWKdcx3Rd8',
      enabled: true,
      // Edge Function URL for Claude API proxy
      claudeProxyUrl: 'https://dumjacmxefrxzcccsyxj.supabase.co/functions/v1/claude-proxy',
    };

    // Supabase client instance
    let supabaseClient = null;
    let currentPlayerId = null;

    // ============================================
    // üêõ BUG FIXES - Caching, Rate Limiting, etc.
    // ============================================
    
    // API Response Cache (prevents redundant API calls)
    const apiCache = new Map();
    const CACHE_TTL = 60000; // 1 minute cache
    
    // Rate limiting for messages
    let lastMessageTime = 0;
    const MESSAGE_COOLDOWN = 1500; // 1.5 seconds between messages
    
    // Debounced save
    let saveTimeout = null;
    const SAVE_DEBOUNCE = 5000; // 5 seconds
    
    // Session tracking
    const sessionStart = Date.now();
    let sessionWarningShown = false;

    // Cache helper functions
    function getCachedData(key) {
      const cached = apiCache.get(key);
      if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
        console.log(`üì¶ Cache hit: ${key}`);
        return cached.data;
      }
      return null;
    }

    function setCachedData(key, data) {
      apiCache.set(key, { data, timestamp: Date.now() });
      // Clean old cache entries (keep max 50)
      if (apiCache.size > 50) {
        const oldestKey = apiCache.keys().next().value;
        apiCache.delete(oldestKey);
      }
    }

    // Retry helper for API calls
    async function fetchWithRetry(url, options = {}, maxRetries = 3) {
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          const response = await fetch(url, options);
          if (response.ok) return response;
          if (response.status >= 500 && attempt < maxRetries) {
            console.log(`‚ö†Ô∏è Retry ${attempt}/${maxRetries} for ${url}`);
            await new Promise(r => setTimeout(r, 1000 * attempt));
            continue;
          }
          return response; // Return non-ok response for caller to handle
        } catch (error) {
          if (attempt === maxRetries) throw error;
          console.log(`‚ö†Ô∏è Network error, retry ${attempt}/${maxRetries}`);
          await new Promise(r => setTimeout(r, 1000 * attempt));
        }
      }
    }

    // Truncate large results for Claude API
    function truncateForClaude(result, maxItems = 10) {
      if (result.allGames && result.allGames.length > maxItems) {
        const total = result.allGames.length;
        result.allGames = result.allGames.slice(0, maxItems);
        result.liveGames = result.liveGames?.slice(0, 5) || [];
        result.upcomingGames = result.upcomingGames?.slice(0, maxItems) || [];
        result.completedGames = result.completedGames?.slice(0, 3) || [];
        result._truncated = true;
        result._note = `Showing ${maxItems} of ${total} games. Ask for more details if needed.`;
      }
      if (result.teams && result.teams.length > 20) {
        result.teams = result.teams.slice(0, 20);
        result._truncated = true;
      }
      return result;
    }

    // Check if user is online
    function isOnline() {
      return navigator.onLine;
    }

    // Initialize Supabase connection
    async function initSupabase() {
      if (SUPABASE_CONFIG.enabled && SUPABASE_CONFIG.url && SUPABASE_CONFIG.anonKey) {
        try {
          supabaseClient = window.supabase.createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);
          console.log('‚úÖ Supabase client created');
          
          // Try to get or create test player
          await ensureTestPlayer();
          return true;
        } catch (e) {
          console.error('‚ùå Supabase connection failed:', e);
          console.log('üì¶ Falling back to localStorage');
          supabaseClient = null;
        }
      } else {
        console.log('üì¶ Supabase not configured - using localStorage');
      }
      return false;
    }

    // Ensure we have a test player in Supabase
    async function ensureTestPlayer() {
      if (!supabaseClient) return;
      
      // Check for existing player in localStorage
      const savedPlayerId = localStorage.getItem('betassist_player_id');
      
      if (savedPlayerId) {
        // Verify player exists in Supabase
        try {
          const { data, error } = await supabaseClient
            .from('players')
            .select('id')
            .eq('id', savedPlayerId)
            .single();
          
          if (data && !error) {
            currentPlayerId = savedPlayerId;
            console.log('üë§ Loaded existing player:', currentPlayerId);
            return;
          }
        } catch (e) {
          console.log('Could not verify player, will create new one');
        }
      }
      
      // Create new player using RPC function
      try {
        const { data, error } = await supabaseClient.rpc('create_player_with_defaults', {
          p_username: 'player_' + Date.now(),
          p_country: 'Kenya',
          p_currency: 'ZMW'
        });
        
        if (error) {
          console.error('‚ùå Supabase RPC error:', error);
          console.log('‚ö†Ô∏è Make sure you ran the SQL schema in Supabase!');
          console.log('üì¶ Falling back to localStorage');
          supabaseClient = null;
          return;
        }
        
        if (data) {
          currentPlayerId = data;
          localStorage.setItem('betassist_player_id', data);
          console.log('üë§ Created new player:', currentPlayerId);
        }
      } catch (e) {
        console.error('‚ùå Failed to create player:', e);
        console.log('üì¶ Falling back to localStorage');
        supabaseClient = null;
      }
    }
    
    // ============================================
    // üåç COMPREHENSIVE SPORTS COVERAGE - ALL LEAGUES
    // ============================================
    
    const ALL_SPORTS = {
      // ========== SOCCER / FOOTBALL - 60+ LEAGUES ==========
      soccer: {
        name: 'Soccer/Football',
        leagues: {
          // ENGLAND
          'eng.1': 'Premier League', 'eng.2': 'Championship', 'eng.3': 'League One', 'eng.4': 'League Two', 'eng.fa': 'FA Cup', 'eng.league_cup': 'EFL Cup',
          // SPAIN
          'esp.1': 'La Liga', 'esp.2': 'La Liga 2', 'esp.copa_del_rey': 'Copa del Rey',
          // GERMANY
          'ger.1': 'Bundesliga', 'ger.2': '2. Bundesliga', 'ger.dfb_pokal': 'DFB Pokal',
          // ITALY
          'ita.1': 'Serie A', 'ita.2': 'Serie B', 'ita.coppa_italia': 'Coppa Italia',
          // FRANCE
          'fra.1': 'Ligue 1', 'fra.2': 'Ligue 2', 'fra.coupe_de_france': 'Coupe de France',
          // OTHER EUROPE
          'ned.1': 'Eredivisie', 'por.1': 'Primeira Liga', 'bel.1': 'Belgian Pro League', 'sco.1': 'Scottish Premiership',
          'tur.1': 'S√ºper Lig', 'rus.1': 'Russian Premier League', 'ukr.1': 'Ukrainian Premier League',
          'gre.1': 'Super League Greece', 'sui.1': 'Swiss Super League', 'aut.1': 'Austrian Bundesliga',
          'den.1': 'Danish Superliga', 'nor.1': 'Eliteserien', 'swe.1': 'Allsvenskan', 'pol.1': 'Ekstraklasa',
          'cze.1': 'Czech First League', 'cro.1': 'HNL', 'ser.1': 'Serbian SuperLiga', 'rom.1': 'Liga I',
          // SOUTH AMERICA
          'arg.1': 'Liga Profesional', 'bra.1': 'Brasileir√£o', 'bra.2': 'S√©rie B', 'col.1': 'Liga BetPlay',
          'chi.1': 'Primera Divisi√≥n Chile', 'ecu.1': 'Liga Pro', 'per.1': 'Liga 1 Peru', 'uru.1': 'Primera Divisi√≥n Uruguay',
          'par.1': 'Primera Divisi√≥n Paraguay', 'ven.1': 'Primera Divisi√≥n Venezuela', 'bol.1': 'Divisi√≥n Profesional',
          // NORTH/CENTRAL AMERICA
          'usa.1': 'MLS', 'usa.nwsl': 'NWSL', 'mex.1': 'Liga MX', 'mex.2': 'Liga de Expansi√≥n',
          'crc.1': 'Primera Divisi√≥n Costa Rica', 'hon.1': 'Liga Nacional Honduras',
          // ASIA
          'jpn.1': 'J1 League', 'jpn.2': 'J2 League', 'kor.1': 'K League 1', 'chn.1': 'Chinese Super League',
          'ind.1': 'Indian Super League', 'tha.1': 'Thai League', 'idn.1': 'Liga 1 Indonesia', 'mys.1': 'Malaysia Super League',
          'sau.1': 'Saudi Pro League', 'uae.1': 'UAE Pro League', 'qat.1': 'Qatar Stars League', 'irn.1': 'Persian Gulf Pro League',
          // OCEANIA
          'aus.1': 'A-League', 'nzl.1': 'New Zealand Football Championship',
          // AFRICA
          'rsa.1': 'PSL South Africa', 'egy.1': 'Egyptian Premier League', 'mar.1': 'Botola Pro', 
          'tun.1': 'Tunisian Ligue 1', 'nga.1': 'NPFL Nigeria', 'gha.1': 'Ghana Premier League', 'ken.1': 'Kenyan Premier League',
          // INTERNATIONAL COMPETITIONS
          'uefa.champions': 'UEFA Champions League', 'uefa.europa': 'UEFA Europa League', 'uefa.europa.conf': 'Conference League',
          'conmebol.libertadores': 'Copa Libertadores', 'conmebol.sudamericana': 'Copa Sudamericana',
          'concacaf.champions': 'CONCACAF Champions Cup', 'afc.champions': 'AFC Champions League', 'caf.champions': 'CAF Champions League',
          // INTERNATIONAL TEAMS
          'fifa.world': 'FIFA World Cup', 'fifa.worldq.uefa': 'World Cup Qual - UEFA', 'fifa.worldq.conmebol': 'World Cup Qual - CONMEBOL',
          'fifa.worldq.concacaf': 'World Cup Qual - CONCACAF', 'fifa.worldq.afc': 'World Cup Qual - AFC', 'fifa.worldq.caf': 'World Cup Qual - CAF',
          'uefa.euro': 'UEFA Euro', 'uefa.euro_qual': 'Euro Qualifiers', 'uefa.nations': 'UEFA Nations League',
          'conmebol.america': 'Copa America', 'concacaf.gold': 'CONCACAF Gold Cup', 'concacaf.nations': 'CONCACAF Nations League',
          'caf.nations': 'Africa Cup of Nations', 'afc.asian_cup': 'AFC Asian Cup',
          'fifa.friendly': 'International Friendlies', 'fifa.cwc': 'FIFA Club World Cup',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/soccer',
      },

      // ========== BASKETBALL ==========
      basketball: {
        name: 'Basketball',
        leagues: {
          'nba': 'NBA', 'wnba': 'WNBA', 'nba-g-league': 'NBA G League',
          'mens-college-basketball': 'NCAA Men\'s Basketball', 'womens-college-basketball': 'NCAA Women\'s Basketball',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/basketball',
      },

      // ========== AMERICAN FOOTBALL ==========
      football: {
        name: 'American Football',
        leagues: {
          'nfl': 'NFL', 'college-football': 'NCAA Football', 'xfl': 'XFL', 'cfl': 'CFL', 'ufl': 'UFL',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/football',
      },

      // ========== BASEBALL ==========
      baseball: {
        name: 'Baseball',
        leagues: {
          'mlb': 'MLB', 'college-baseball': 'NCAA Baseball',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/baseball',
      },

      // ========== ICE HOCKEY ==========
      hockey: {
        name: 'Ice Hockey',
        leagues: {
          'nhl': 'NHL', 'mens-college-hockey': 'NCAA Hockey',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/hockey',
      },

      // ========== TENNIS ==========
      tennis: {
        name: 'Tennis',
        leagues: {
          'atp': 'ATP Tour', 'wta': 'WTA Tour',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/tennis',
      },

      // ========== GOLF ==========
      golf: {
        name: 'Golf',
        leagues: {
          'pga': 'PGA Tour', 'lpga': 'LPGA Tour', 'euro': 'DP World Tour', 'liv': 'LIV Golf',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/golf',
      },

      // ========== MMA / COMBAT SPORTS ==========
      mma: {
        name: 'MMA',
        leagues: {
          'ufc': 'UFC', 'pfl': 'PFL', 'bellator': 'Bellator', 'one': 'ONE Championship',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/mma',
      },

      // ========== BOXING ==========
      boxing: {
        name: 'Boxing',
        leagues: {
          'boxing': 'Professional Boxing',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/boxing',
      },

      // ========== RUGBY ==========
      rugby: {
        name: 'Rugby',
        leagues: {
          'super-rugby': 'Super Rugby', 'six-nations': 'Six Nations', 'premiership': 'English Premiership',
          'top14': 'Top 14', 'urc': 'United Rugby Championship', 'mlr': 'Major League Rugby',
          'world-cup': 'Rugby World Cup',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/rugby',
      },

      // ========== CRICKET ==========
      cricket: {
        name: 'Cricket',
        leagues: {
          'ipl': 'IPL', 'bbl': 'Big Bash League', 'psl': 'Pakistan Super League', 'cpl': 'Caribbean Premier League',
          'hundred': 'The Hundred', 'sa20': 'SA20', 'ilt20': 'ILT20',
          't20-world-cup': 'T20 World Cup', 'odi-world-cup': 'ODI World Cup', 'wtc': 'World Test Championship',
          'the-ashes': 'The Ashes', 'icc-test': 'ICC Test Matches', 'icc-odi': 'ICC ODI Matches', 'icc-t20': 'ICC T20 Matches',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/cricket',
      },

      // ========== RACING ==========
      racing: {
        name: 'Racing',
        leagues: {
          'f1': 'Formula 1', 'nascar-cup': 'NASCAR Cup Series', 'nascar-xfinity': 'NASCAR Xfinity', 
          'indycar': 'IndyCar', 'motogp': 'MotoGP', 'wrc': 'World Rally Championship',
          'formula-e': 'Formula E', 'v8-supercars': 'V8 Supercars',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/racing',
      },

      // ========== ESPORTS ==========
      esports: {
        name: 'Esports',
        leagues: {
          'lol': 'League of Legends', 'csgo': 'Counter-Strike', 'dota2': 'Dota 2', 
          'valorant': 'Valorant', 'overwatch': 'Overwatch', 'rocket-league': 'Rocket League',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/esports',
      },

      // ========== AUSTRALIAN RULES ==========
      afl: {
        name: 'Australian Rules Football',
        leagues: {
          'afl': 'AFL',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/australian-football',
      },

      // ========== LACROSSE ==========
      lacrosse: {
        name: 'Lacrosse',
        leagues: {
          'pll': 'Premier Lacrosse League', 'nll': 'National Lacrosse League',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/lacrosse',
      },
    };

    // ============================================
    // DYNAMIC URL BUILDERS
    // ============================================
    
    function buildUrl(sport, league, endpoint = 'scoreboard') {
      const sportConfig = ALL_SPORTS[sport];
      if (!sportConfig) return null;
      return `${sportConfig.baseUrl}/${league}/${endpoint}`;
    }

    function buildTeamsUrl(sport, league) {
      return buildUrl(sport, league, 'teams');
    }

    function buildStandingsUrl(sport, league) {
      const sportConfig = ALL_SPORTS[sport];
      if (!sportConfig) return null;
      return `https://site.api.espn.com/apis/v2/sports/${sport}/${league}/standings`;
    }

    // ============================================
    // LEAGUE ALIASES FOR NATURAL LANGUAGE
    // ============================================
    
    const LEAGUE_ALIASES = {
      // Soccer
      'premier league': { sport: 'soccer', league: 'eng.1' },
      'epl': { sport: 'soccer', league: 'eng.1' },
      'la liga': { sport: 'soccer', league: 'esp.1' },
      'serie a': { sport: 'soccer', league: 'ita.1' },
      'bundesliga': { sport: 'soccer', league: 'ger.1' },
      'ligue 1': { sport: 'soccer', league: 'fra.1' },
      'champions league': { sport: 'soccer', league: 'uefa.champions' },
      'europa league': { sport: 'soccer', league: 'uefa.europa' },
      'mls': { sport: 'soccer', league: 'usa.1' },
      'liga mx': { sport: 'soccer', league: 'mex.1' },
      'brasileirao': { sport: 'soccer', league: 'bra.1' },
      'j league': { sport: 'soccer', league: 'jpn.1' },
      'saudi league': { sport: 'soccer', league: 'sau.1' },
      'eredivisie': { sport: 'soccer', league: 'ned.1' },
      'world cup': { sport: 'soccer', league: 'fifa.world' },
      'copa america': { sport: 'soccer', league: 'conmebol.america' },
      'euros': { sport: 'soccer', league: 'uefa.euro' },
      'afcon': { sport: 'soccer', league: 'caf.nations' },
      // Basketball
      'nba': { sport: 'basketball', league: 'nba' },
      'wnba': { sport: 'basketball', league: 'wnba' },
      'ncaa basketball': { sport: 'basketball', league: 'mens-college-basketball' },
      'march madness': { sport: 'basketball', league: 'mens-college-basketball' },
      // Football
      'nfl': { sport: 'football', league: 'nfl' },
      'college football': { sport: 'football', league: 'college-football' },
      'ncaa football': { sport: 'football', league: 'college-football' },
      // Baseball
      'mlb': { sport: 'baseball', league: 'mlb' },
      // Hockey
      'nhl': { sport: 'hockey', league: 'nhl' },
      // Tennis
      'atp': { sport: 'tennis', league: 'atp' },
      'wta': { sport: 'tennis', league: 'wta' },
      // Golf
      'pga': { sport: 'golf', league: 'pga' },
      'lpga': { sport: 'golf', league: 'lpga' },
      // MMA
      'ufc': { sport: 'mma', league: 'ufc' },
      // Racing
      'f1': { sport: 'racing', league: 'f1' },
      'formula 1': { sport: 'racing', league: 'f1' },
      'nascar': { sport: 'racing', league: 'nascar-cup' },
      'motogp': { sport: 'racing', league: 'motogp' },
      'indycar': { sport: 'racing', league: 'indycar' },
      // Cricket
      'ipl': { sport: 'cricket', league: 'ipl' },
      'big bash': { sport: 'cricket', league: 'bbl' },
      't20 world cup': { sport: 'cricket', league: 't20-world-cup' },
      // Rugby
      'six nations': { sport: 'rugby', league: 'six-nations' },
      'super rugby': { sport: 'rugby', league: 'super-rugby' },
      // AFL
      'afl': { sport: 'afl', league: 'afl' },
    };

    // Resolve league from user input
    function resolveLeague(input) {
      const lower = input.toLowerCase().trim();
      
      // Check direct alias
      if (LEAGUE_ALIASES[lower]) {
        return LEAGUE_ALIASES[lower];
      }
      
      // Check partial matches
      for (const [alias, config] of Object.entries(LEAGUE_ALIASES)) {
        if (lower.includes(alias) || alias.includes(lower)) {
          return config;
        }
      }
      
      // Check ALL_SPORTS leagues
      for (const [sport, config] of Object.entries(ALL_SPORTS)) {
        for (const [leagueId, leagueName] of Object.entries(config.leagues)) {
          if (leagueName.toLowerCase().includes(lower) || lower.includes(leagueName.toLowerCase())) {
            return { sport, league: leagueId };
          }
        }
      }
      
      return null;
    }

    // ============================================
    // üé∞ BWANABET.COM CONFIGURATION
    // ============================================
    // üëá CONFIGURE YOUR BWANABET API ENDPOINTS BELOW üëá
    
    const BWANABET_CONFIG = {
      // Base URL for bwanabet API
      baseUrl: 'https://bwanabet.com',
      
      // API endpoints - UPDATE THESE with actual bwanabet endpoints
      endpoints: {
        // Odds endpoints
        odds: {
          soccer: '/api/odds/soccer',      // Example: Update with real endpoint
          basketball: '/api/odds/basketball',
          football: '/api/odds/football',
          tennis: '/api/odds/tennis',
          all: '/api/odds/all',
        },
        // Casino endpoints
        casino: {
          games: '/api/casino/games',
          slots: '/api/casino/slots',
          liveDealer: '/api/casino/live-dealer',
          tableGames: '/api/casino/table-games',
          jackpots: '/api/casino/jackpots',
        },
        // Live betting
        liveBetting: '/api/live/events',
      },
      
      // Authentication (if required)
      auth: {
        apiKey: '',           // Add API key if needed
        authHeader: '',       // e.g., 'Authorization' or 'X-API-Key'
      },
      
      // Request headers
      headers: {
        'Content-Type': 'application/json',
        // Add any required headers here
      },
    };

    // ============================================
    // DYNAMIC GAMES FETCHER - ANY SPORT, ANY LEAGUE
    // ============================================

    async function fetchGames(sportOrLeague, leagueId = null) {
      let sport, league;
      
      // Try to resolve from alias first
      const resolved = resolveLeague(sportOrLeague);
      if (resolved) {
        sport = resolved.sport;
        league = resolved.league;
      } else if (leagueId) {
        sport = sportOrLeague;
        league = leagueId;
      } else {
        // Try direct sport lookup with default league
        if (ALL_SPORTS[sportOrLeague]) {
          sport = sportOrLeague;
          league = Object.keys(ALL_SPORTS[sportOrLeague].leagues)[0];
        } else {
          return { 
            error: `Unknown sport/league: ${sportOrLeague}`,
            hint: 'Try "Premier League", "NBA", "La Liga", "UFC", "Champions League", etc.',
            availableSports: Object.keys(ALL_SPORTS),
          };
        }
      }

      // Check cache first
      const cacheKey = `games_${sport}_${league}`;
      const cached = getCachedData(cacheKey);
      if (cached) return cached;

      const url = buildUrl(sport, league, 'scoreboard');
      if (!url) {
        return { error: `Could not build URL for ${sport}/${league}` };
      }

      console.log(`üèüÔ∏è Fetching games from: ${url}`);

      try {
        const response = await fetchWithRetry(url);
        if (!response.ok) throw new Error(`ESPN API error: ${response.status}`);
        
        const data = await response.json();
        const leagueName = ALL_SPORTS[sport]?.leagues[league] || league;
        
        // Transform ESPN data
        const games = (data.events || []).map(event => {
          const competition = event.competitions?.[0];
          const homeTeam = competition?.competitors?.find(c => c.homeAway === 'home');
          const awayTeam = competition?.competitors?.find(c => c.homeAway === 'away');
          
          return {
            id: event.id,
            name: event.name,
            shortName: event.shortName,
            status: {
              state: event.status?.type?.state,
              detail: event.status?.type?.detail,
              clock: event.status?.displayClock,
            },
            homeTeam: homeTeam ? {
              name: homeTeam.team?.displayName,
              abbreviation: homeTeam.team?.abbreviation,
              score: homeTeam.score || '0',
              logo: homeTeam.team?.logo,
            } : null,
            awayTeam: awayTeam ? {
              name: awayTeam.team?.displayName,
              abbreviation: awayTeam.team?.abbreviation,
              score: awayTeam.score || '0',
              logo: awayTeam.team?.logo,
            } : null,
            venue: competition?.venue?.fullName,
            broadcast: competition?.broadcasts?.[0]?.names?.[0],
            startTime: event.date,
          };
        });

        const liveGames = games.filter(g => g.status.state === 'in');
        const upcomingGames = games.filter(g => g.status.state === 'pre');
        const completedGames = games.filter(g => g.status.state === 'post');

        const result = {
          sport: sport,
          league: league,
          leagueName: leagueName,
          totalGames: games.length,
          liveGames,
          upcomingGames,
          completedGames,
          allGames: games,
          fetchedAt: new Date().toISOString(),
        };

        // Cache the result
        setCachedData(cacheKey, result);
        return result;

      } catch (error) {
        console.error('Fetch error:', error);
        return { error: error.message, sport, league };
      }
    }

    // Fetch all teams in a league
    async function fetchLeagueTeams(sportOrLeague, leagueId = null) {
      let sport, league;
      
      const resolved = resolveLeague(sportOrLeague);
      if (resolved) {
        sport = resolved.sport;
        league = resolved.league;
      } else if (leagueId) {
        sport = sportOrLeague;
        league = leagueId;
      } else {
        return { error: `Unknown league: ${sportOrLeague}` };
      }

      // Check cache first
      const cacheKey = `teams_${sport}_${league}`;
      const cached = getCachedData(cacheKey);
      if (cached) return cached;

      const url = buildTeamsUrl(sport, league);
      if (!url) return { error: `Could not build teams URL` };

      try {
        const response = await fetchWithRetry(url);
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        
        const data = await response.json();
        const teams = (data.sports?.[0]?.leagues?.[0]?.teams || []).map(t => ({
          id: t.team.id,
          name: t.team.displayName,
          abbreviation: t.team.abbreviation,
          logo: t.team.logos?.[0]?.href,
        }));

        const result = {
          sport,
          league,
          leagueName: ALL_SPORTS[sport]?.leagues[league],
          teams,
          totalTeams: teams.length,
          fetchedAt: new Date().toISOString(),
        };

        // Cache for longer (5 min) since teams don't change often
        apiCache.set(cacheKey, { data: result, timestamp: Date.now() });
        return result;

      } catch (error) {
        return { error: error.message, sport, league };
      }
    }

    // Search for a team by name across all leagues
    async function searchTeam(teamName) {
      const searchLower = teamName.toLowerCase();
      const results = [];
      
      // Search common leagues
      const searchLeagues = [
        { sport: 'basketball', league: 'nba' },
        { sport: 'football', league: 'nfl' },
        { sport: 'baseball', league: 'mlb' },
        { sport: 'hockey', league: 'nhl' },
        { sport: 'soccer', league: 'eng.1' },
        { sport: 'soccer', league: 'esp.1' },
        { sport: 'soccer', league: 'ger.1' },
        { sport: 'soccer', league: 'ita.1' },
        { sport: 'soccer', league: 'fra.1' },
        { sport: 'soccer', league: 'usa.1' },
      ];

      for (const { sport, league } of searchLeagues) {
        try {
          const url = buildTeamsUrl(sport, league);
          const response = await fetch(url);
          if (!response.ok) continue;
          
          const data = await response.json();
          const teams = data.sports?.[0]?.leagues?.[0]?.teams || [];
          
          for (const t of teams) {
            const name = t.team.displayName?.toLowerCase() || '';
            const abbr = t.team.abbreviation?.toLowerCase() || '';
            if (name.includes(searchLower) || abbr === searchLower || searchLower.includes(name.split(' ').pop())) {
              results.push({
                id: t.team.id,
                name: t.team.displayName,
                abbreviation: t.team.abbreviation,
                sport,
                league,
                leagueName: ALL_SPORTS[sport]?.leagues[league],
                logo: t.team.logos?.[0]?.href,
              });
            }
          }
        } catch (e) {
          continue;
        }
        
        // Limit search to avoid too many requests
        if (results.length >= 5) break;
      }

      return {
        query: teamName,
        results,
        totalFound: results.length,
      };
    }

    // List all available leagues
    function listAvailableLeagues(sportFilter = null) {
      const leagues = [];
      
      for (const [sport, config] of Object.entries(ALL_SPORTS)) {
        if (sportFilter && sport !== sportFilter) continue;
        
        for (const [leagueId, leagueName] of Object.entries(config.leagues)) {
          leagues.push({
            sport,
            sportName: config.name,
            leagueId,
            leagueName,
          });
        }
      }

      return {
        totalLeagues: leagues.length,
        totalSports: sportFilter ? 1 : Object.keys(ALL_SPORTS).length,
        leagues: sportFilter ? leagues : leagues.slice(0, 50), // Limit for readability
        allSports: Object.entries(ALL_SPORTS).map(([id, c]) => ({ id, name: c.name, leagueCount: Object.keys(c.leagues).length })),
      };
    }

    // ============================================
    // STATE
    // ============================================
    
    let conversationHistory = [];
    let isProcessing = false;

    // ============================================
    // üë§ PLAYER DATABASE SCHEMA & PROFILE SYSTEM
    // ============================================

    // Comprehensive player data model (simulates database)
    const DEFAULT_PLAYER_DATA = {
      // === BASIC PROFILE ===
      profile: {
        id: 'player_' + Date.now(),
        username: '',
        country: '',
        city: '',
        language: 'en',
        currency: 'ZMW',
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        createdAt: new Date().toISOString(),
        lastLogin: new Date().toISOString(),
        accountStatus: 'active',
      },

      // === BETTING PREFERENCES ===
      preferences: {
        favoriteSports: [],
        favoriteLeagues: [],
        favoriteTeams: [],
        preferredBetTypes: [],
        preferredOddsFormat: 'decimal',
        preferredStakeRange: { min: 100, max: 5000, average: 500 },
        riskTolerance: 'medium',
        preferredOddsRange: { min: 1.30, max: 5.00 },
        notifications: { matchReminders: true, betSuggestions: true, results: true },
      },

      // === BETTING HISTORY ===
      bettingHistory: {
        lifetime: {
          totalBets: 0,
          totalStaked: 0,
          totalWinnings: 0,
          netProfit: 0,
          winRate: 0,
          averageOdds: 0,
          averageStake: 0,
          biggestWin: 0,
          biggestLoss: 0,
          currentStreak: { type: null, count: 0 },
        },
        bySport: {},
        byBetType: {},
        byLeague: {},
        byTeam: {},
        recentBets: [],
        pendingBets: [],
      },

      // === BEHAVIORAL DATA ===
      behavior: {
        activity: {
          loginFrequency: 'new',
          sessionsThisWeek: 0,
          averageSessionDuration: 0,
          peakActivityTimes: [],
          peakActivityDays: [],
          preferredDevice: 'unknown',
        },
        browsing: {
          leagueViews: {},
          teamViews: {},
          recentSearches: [],
          viewedMatches: [],
        },
        engagement: {
          suggestionsViewed: 0,
          suggestionsAccepted: 0,
          suggestionsDismissed: 0,
        },
      },

      // === FINANCIAL DATA ===
      financial: {
        balance: { available: 0, bonus: 0, pending: 0 },
        limits: {
          dailyDeposit: { set: null, used: 0 },
          dailyLoss: { set: null, used: 0 },
          singleBetMax: null,
        },
        averageDeposit: 0,
      },

      // === RESPONSIBLE GAMBLING ===
      responsibleGambling: {
        riskScore: 1,
        riskFactors: [],
        selfControls: {
          depositLimits: false,
          lossLimits: false,
          sessionTimeLimit: null,
        },
        flags: {
          chasingLosses: false,
          increasingStakes: false,
          lateNightBetting: false,
        },
      },

      // === AI PERSONALIZATION ===
      aiPersonalization: {
        learnedPreferences: {
          profitableTeams: [],
          unprofitableTeams: [],
          profitableBetTypes: [],
          unprofitableBetTypes: [],
          profitableLeagues: [],
          optimalOddsRange: { min: 1.50, max: 3.00 },
        },
        recommendations: {
          accepted: [],
          rejected: [],
          dismissed: [],
          acceptanceRate: 0,
        },
        bestTimeToEngage: null,
        preferredMessageStyle: 'detailed',
      },
    };

    // Load player data from Supabase or localStorage
    async function loadPlayerData() {
      // If Supabase is configured and connected
      if (supabaseClient && currentPlayerId) {
        try {
          console.log('üì• Fetching player data from Supabase...');
          const { data, error } = await supabaseClient.rpc('get_player_ai_profile', {
            p_player_id: currentPlayerId
          });
          
          if (error) {
            console.error('‚ùå Supabase RPC error:', error);
            console.log('‚ö†Ô∏è The get_player_ai_profile function may not exist in your database.');
            console.log('üì¶ Falling back to localStorage');
          } else if (data) {
            console.log('‚úÖ Loaded player data from Supabase');
            return transformSupabaseData(data);
          }
        } catch (e) {
          console.error('‚ùå Supabase load error:', e);
          console.log('üì¶ Falling back to localStorage');
        }
      }
      
      // Fallback to localStorage
      try {
        const saved = localStorage.getItem('betassist_player_data');
        if (saved) {
          console.log('üì¶ Loaded player data from localStorage');
          const data = JSON.parse(saved);
          return deepMerge(DEFAULT_PLAYER_DATA, data);
        }
      } catch (e) {
        console.log('Could not load player data from localStorage');
      }
      
      console.log('üÜï Using default player data');
      return JSON.parse(JSON.stringify(DEFAULT_PLAYER_DATA));
    }

    // Transform Supabase data to match our schema
    function transformSupabaseData(supabaseData) {
      return {
        profile: {
          id: supabaseData.profile?.id || '',
          username: supabaseData.profile?.username || '',
          country: supabaseData.profile?.country || '',
          city: supabaseData.profile?.city || '',
          language: supabaseData.profile?.language || 'en',
          currency: supabaseData.profile?.currency || 'ZMW',
          timezone: supabaseData.profile?.timezone || '',
          createdAt: supabaseData.profile?.created_at || new Date().toISOString(),
          lastLogin: supabaseData.profile?.last_login || new Date().toISOString(),
          accountStatus: supabaseData.profile?.account_status || 'active',
        },
        preferences: {
          favoriteSports: supabaseData.preferences?.favorite_sports || [],
          favoriteLeagues: supabaseData.preferences?.favorite_leagues || [],
          favoriteTeams: supabaseData.preferences?.favorite_teams || [],
          preferredBetTypes: supabaseData.preferences?.preferred_bet_types || [],
          preferredOddsFormat: supabaseData.preferences?.odds_format || 'decimal',
          preferredStakeRange: {
            min: supabaseData.preferences?.preferred_stake_min || 100,
            max: supabaseData.preferences?.preferred_stake_max || 5000,
            average: supabaseData.preferences?.preferred_stake_avg || 500,
          },
          riskTolerance: supabaseData.preferences?.risk_tolerance || 'medium',
          preferredOddsRange: {
            min: supabaseData.preferences?.preferred_odds_min || 1.30,
            max: supabaseData.preferences?.preferred_odds_max || 5.00,
          },
        },
        bettingHistory: {
          lifetime: {
            totalBets: supabaseData.stats?.total_bets || 0,
            totalStaked: supabaseData.stats?.total_staked || 0,
            totalWinnings: supabaseData.stats?.total_winnings || 0,
            netProfit: supabaseData.stats?.net_profit || 0,
            winRate: supabaseData.stats?.win_rate || 0,
            averageOdds: supabaseData.stats?.average_odds || 0,
            averageStake: supabaseData.stats?.average_stake || 0,
            biggestWin: supabaseData.stats?.biggest_win || 0,
            biggestLoss: supabaseData.stats?.biggest_loss || 0,
            currentStreak: {
              type: supabaseData.stats?.current_streak_type || null,
              count: supabaseData.stats?.current_streak_count || 0,
            },
          },
          recentBets: supabaseData.recentBets || [],
          bySport: {},
          byLeague: {},
        },
        behavior: {
          activity: {
            loginFrequency: supabaseData.behavior?.login_frequency || 'new',
            sessionsThisWeek: supabaseData.behavior?.sessions_this_week || 0,
          },
          browsing: {
            leagueViews: supabaseData.behavior?.league_views || {},
            teamViews: supabaseData.behavior?.team_views || {},
            recentSearches: supabaseData.behavior?.recent_searches || [],
          },
          engagement: {
            suggestionsViewed: supabaseData.behavior?.suggestions_viewed || 0,
            suggestionsAccepted: supabaseData.behavior?.suggestions_accepted || 0,
            suggestionsDismissed: supabaseData.behavior?.suggestions_dismissed || 0,
          },
        },
        financial: {
          balance: {
            available: supabaseData.financial?.balance_available || 0,
            bonus: supabaseData.financial?.balance_bonus || 0,
            pending: supabaseData.financial?.balance_pending || 0,
          },
          limits: {
            dailyDeposit: { 
              set: supabaseData.financial?.daily_deposit_limit, 
              used: supabaseData.financial?.daily_deposit_used || 0 
            },
            dailyLoss: { 
              set: supabaseData.financial?.daily_loss_limit, 
              used: supabaseData.financial?.daily_loss_used || 0 
            },
          },
        },
        responsibleGambling: {
          riskScore: supabaseData.responsibleGambling?.risk_score || 1,
          riskFactors: supabaseData.responsibleGambling?.risk_factors || [],
          selfControls: {
            depositLimits: supabaseData.responsibleGambling?.deposit_limits_enabled || false,
            lossLimits: supabaseData.responsibleGambling?.loss_limits_enabled || false,
            sessionTimeLimit: supabaseData.responsibleGambling?.session_time_limit,
          },
          flags: {
            chasingLosses: supabaseData.responsibleGambling?.chasing_losses_flag || false,
            increasingStakes: supabaseData.responsibleGambling?.increasing_stakes_flag || false,
            lateNightBetting: supabaseData.responsibleGambling?.late_night_betting_flag || false,
          },
        },
        aiPersonalization: {
          learnedPreferences: {
            profitableTeams: supabaseData.aiData?.profitable_teams || [],
            unprofitableTeams: supabaseData.aiData?.unprofitable_teams || [],
            profitableBetTypes: supabaseData.aiData?.profitable_bet_types || [],
            unprofitableBetTypes: supabaseData.aiData?.unprofitable_bet_types || [],
            profitableLeagues: supabaseData.aiData?.profitable_leagues || [],
            optimalOddsRange: {
              min: supabaseData.aiData?.optimal_odds_min || 1.50,
              max: supabaseData.aiData?.optimal_odds_max || 3.00,
            },
          },
          recommendations: {
            accepted: supabaseData.aiData?.accepted_recommendations || [],
            rejected: supabaseData.aiData?.rejected_recommendations || [],
            dismissed: supabaseData.aiData?.dismissed_recommendations || [],
            acceptanceRate: supabaseData.aiData?.acceptance_rate || 0,
          },
        },
      };
    }

    // Save player data to Supabase or localStorage
    async function savePlayerData() {
      // If Supabase is configured
      if (supabaseClient && currentPlayerId) {
        try {
          // Update preferences
          await supabaseClient.from('player_preferences').update({
            favorite_sports: playerData.preferences.favoriteSports,
            favorite_leagues: playerData.preferences.favoriteLeagues,
            favorite_teams: playerData.preferences.favoriteTeams,
            risk_tolerance: playerData.preferences.riskTolerance,
            preferred_stake_avg: playerData.preferences.preferredStakeRange.average,
            updated_at: new Date().toISOString(),
          }).eq('player_id', currentPlayerId);
          
          // Update behavior
          await supabaseClient.from('player_behavior').update({
            league_views: playerData.behavior.browsing.leagueViews,
            team_views: playerData.behavior.browsing.teamViews,
            suggestions_viewed: playerData.behavior.engagement.suggestionsViewed,
            suggestions_accepted: playerData.behavior.engagement.suggestionsAccepted,
            suggestions_dismissed: playerData.behavior.engagement.suggestionsDismissed,
            updated_at: new Date().toISOString(),
          }).eq('player_id', currentPlayerId);
          
          // Update AI data
          await supabaseClient.from('player_ai_data').update({
            profitable_teams: playerData.aiPersonalization.learnedPreferences.profitableTeams,
            unprofitable_teams: playerData.aiPersonalization.learnedPreferences.unprofitableTeams,
            accepted_recommendations: playerData.aiPersonalization.recommendations.accepted,
            rejected_recommendations: playerData.aiPersonalization.recommendations.rejected,
            dismissed_recommendations: playerData.aiPersonalization.recommendations.dismissed,
            acceptance_rate: playerData.aiPersonalization.recommendations.acceptanceRate,
            updated_at: new Date().toISOString(),
          }).eq('player_id', currentPlayerId);
          
          console.log('üì§ Saved to Supabase');
          return;
        } catch (e) {
          console.error('Supabase save error:', e);
        }
      }
      
      // Fallback to localStorage
      try {
        playerData.profile.lastLogin = new Date().toISOString();
        localStorage.setItem('betassist_player_data', JSON.stringify(playerData));
      } catch (e) {
        console.log('Could not save player data');
      }
    }

    // Debounced version of savePlayerData - prevents too many saves
    function debouncedSavePlayerData() {
      if (saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        savePlayerData();
      }, SAVE_DEBOUNCE);
    }

    // Record a bet to Supabase
    async function recordBetToSupabase(betData) {
      if (!supabaseClient || !currentPlayerId) return;
      
      try {
        await supabaseClient.from('bets').insert({
          player_id: currentPlayerId,
          sport: betData.sport,
          league: betData.league,
          league_name: betData.leagueName,
          match_name: betData.matchName,
          bet_type: betData.betType,
          selection: betData.selection,
          odds: betData.odds,
          stake: betData.stake,
          status: betData.status || 'pending',
        });
        console.log('üìù Bet recorded to Supabase');
      } catch (e) {
        console.error('Error recording bet:', e);
      }
    }

    // Deep merge helper
    function deepMerge(target, source) {
      const result = { ...target };
      for (const key in source) {
        if (source[key] instanceof Object && key in target) {
          result[key] = deepMerge(target[key], source[key]);
        } else {
          result[key] = source[key];
        }
      }
      return result;
    }

    // Current player data (loaded during initialization)
    let playerData = JSON.parse(JSON.stringify(DEFAULT_PLAYER_DATA));

    // ============================================
    // üìä PLAYER DATA TRACKING FUNCTIONS
    // ============================================

    // Track league view
    function trackLeagueView(leagueId, leagueName) {
      if (!playerData.behavior.browsing.leagueViews[leagueId]) {
        playerData.behavior.browsing.leagueViews[leagueId] = { name: leagueName, views: 0, lastViewed: null };
      }
      playerData.behavior.browsing.leagueViews[leagueId].views++;
      playerData.behavior.browsing.leagueViews[leagueId].lastViewed = new Date().toISOString();

      // Auto-add to favorites after 3 views
      if (playerData.behavior.browsing.leagueViews[leagueId].views >= 3) {
        const exists = playerData.preferences.favoriteLeagues.find(l => l.id === leagueId);
        if (!exists) {
          playerData.preferences.favoriteLeagues.push({ id: leagueId, name: leagueName, addedAt: new Date().toISOString() });
        }
      }
      debouncedSavePlayerData();
    }

    // Track team view
    function trackTeamView(teamName, leagueId) {
      const key = `${teamName}|${leagueId}`;
      if (!playerData.behavior.browsing.teamViews[key]) {
        playerData.behavior.browsing.teamViews[key] = { team: teamName, league: leagueId, views: 0, lastViewed: null };
      }
      playerData.behavior.browsing.teamViews[key].views++;
      playerData.behavior.browsing.teamViews[key].lastViewed = new Date().toISOString();

      // Auto-add to favorites after 3 views
      if (playerData.behavior.browsing.teamViews[key].views >= 3) {
        const exists = playerData.preferences.favoriteTeams.find(t => t.name === teamName);
        if (!exists) {
          playerData.preferences.favoriteTeams.push({ name: teamName, league: leagueId, addedAt: new Date().toISOString() });
        }
      }
      debouncedSavePlayerData();
    }

    // Record a bet (for history tracking)
    function recordBet(betData) {
      playerData.bettingHistory.recentBets.unshift({
        ...betData,
        id: 'bet_' + Date.now(),
        date: new Date().toISOString(),
      });
      
      // Keep only last 100 bets
      playerData.bettingHistory.recentBets = playerData.bettingHistory.recentBets.slice(0, 100);
      
      // Update lifetime stats
      const lifetime = playerData.bettingHistory.lifetime;
      lifetime.totalBets++;
      lifetime.totalStaked += betData.stake;
      
      if (betData.status === 'won') {
        lifetime.totalWinnings += betData.payout;
        lifetime.netProfit += betData.profit;
        if (betData.profit > lifetime.biggestWin) lifetime.biggestWin = betData.profit;
      } else if (betData.status === 'lost') {
        lifetime.netProfit -= betData.stake;
        if (betData.stake > lifetime.biggestLoss) lifetime.biggestLoss = betData.stake;
      }
      
      lifetime.winRate = playerData.bettingHistory.recentBets.filter(b => b.status === 'won').length / 
                         playerData.bettingHistory.recentBets.filter(b => b.status !== 'pending').length || 0;
      
      savePlayerData();
    }

    // Track suggestion interaction
    function trackSuggestionInteraction(suggestionId, action) {
      playerData.behavior.engagement.suggestionsViewed++;
      
      if (action === 'accepted') {
        playerData.behavior.engagement.suggestionsAccepted++;
        playerData.aiPersonalization.recommendations.accepted.push(suggestionId);
      } else if (action === 'rejected') {
        playerData.aiPersonalization.recommendations.rejected.push(suggestionId);
      } else if (action === 'dismissed') {
        playerData.behavior.engagement.suggestionsDismissed++;
        playerData.aiPersonalization.recommendations.dismissed.push(suggestionId);
      }
      
      // Calculate acceptance rate
      const total = playerData.behavior.engagement.suggestionsViewed;
      const accepted = playerData.behavior.engagement.suggestionsAccepted;
      playerData.aiPersonalization.recommendations.acceptanceRate = total > 0 ? accepted / total : 0;
      
      debouncedSavePlayerData();
    }

    // Update player preferences
    function updatePlayerPreferences(updates) {
      playerData.preferences = deepMerge(playerData.preferences, updates);
      debouncedSavePlayerData();
      return playerData.preferences;
    }

    // Update player profile
    function updatePlayerProfile(updates) {
      playerData.profile = { ...playerData.profile, ...updates };
      debouncedSavePlayerData();
      return playerData.profile;
    }

    // ============================================
    // üéØ AI ANALYSIS FUNCTIONS
    // ============================================

    // Get comprehensive player summary for AI
    function getPlayerSummaryForAI() {
      const topLeagues = Object.entries(playerData.behavior.browsing.leagueViews)
        .sort((a, b) => b[1].views - a[1].views)
        .slice(0, 5)
        .map(([id, data]) => ({ id, name: data.name, views: data.views }));

      const topTeams = Object.entries(playerData.behavior.browsing.teamViews)
        .sort((a, b) => b[1].views - a[1].views)
        .slice(0, 5)
        .map(([key, data]) => ({ name: data.team, league: data.league, views: data.views }));

      return {
        // Profile
        profile: {
          username: playerData.profile.username || 'Player',
          country: playerData.profile.country,
          accountAge: playerData.profile.createdAt,
          lastLogin: playerData.profile.lastLogin,
        },
        
        // Preferences
        preferences: {
          favoriteLeagues: playerData.preferences.favoriteLeagues,
          favoriteTeams: playerData.preferences.favoriteTeams,
          favoriteSports: playerData.preferences.favoriteSports,
          riskTolerance: playerData.preferences.riskTolerance,
          preferredBetTypes: playerData.preferences.preferredBetTypes,
          preferredOddsRange: playerData.preferences.preferredOddsRange,
          preferredStake: playerData.preferences.preferredStakeRange,
        },
        
        // Betting Performance
        performance: {
          totalBets: playerData.bettingHistory.lifetime.totalBets,
          winRate: (playerData.bettingHistory.lifetime.winRate * 100).toFixed(1) + '%',
          netProfit: playerData.bettingHistory.lifetime.netProfit,
          averageStake: playerData.bettingHistory.lifetime.averageStake || playerData.preferences.preferredStakeRange.average,
          currentStreak: playerData.bettingHistory.lifetime.currentStreak,
          biggestWin: playerData.bettingHistory.lifetime.biggestWin,
        },
        
        // Learned Patterns
        patterns: {
          profitableTeams: playerData.aiPersonalization.learnedPreferences.profitableTeams,
          unprofitableTeams: playerData.aiPersonalization.learnedPreferences.unprofitableTeams,
          profitableBetTypes: playerData.aiPersonalization.learnedPreferences.profitableBetTypes,
          profitableLeagues: playerData.aiPersonalization.learnedPreferences.profitableLeagues,
          optimalOddsRange: playerData.aiPersonalization.learnedPreferences.optimalOddsRange,
        },
        
        // Behavior
        behavior: {
          mostViewedLeagues: topLeagues,
          mostViewedTeams: topTeams,
          suggestionAcceptanceRate: (playerData.aiPersonalization.recommendations.acceptanceRate * 100).toFixed(0) + '%',
          totalInteractions: Object.values(playerData.behavior.browsing.leagueViews).reduce((a, b) => a + b.views, 0),
        },
        
        // Responsible Gambling Status
        responsibleGambling: {
          riskScore: playerData.responsibleGambling.riskScore,
          hasLimits: playerData.responsibleGambling.selfControls.depositLimits || playerData.responsibleGambling.selfControls.lossLimits,
          flags: playerData.responsibleGambling.flags,
        },
        
        // Financial Context
        financial: {
          balance: playerData.financial.balance.available,
          dailyLimitRemaining: playerData.financial.limits.dailyDeposit.set 
            ? playerData.financial.limits.dailyDeposit.set - playerData.financial.limits.dailyDeposit.used 
            : 'No limit set',
        },
      };
    }

    // Check if we should show responsible gambling warning
    function checkResponsibleGamblingStatus() {
      const rg = playerData.responsibleGambling;
      const warnings = [];
      
      // Check loss limit
      if (playerData.financial.limits.dailyLoss.set) {
        const remaining = playerData.financial.limits.dailyLoss.set - playerData.financial.limits.dailyLoss.used;
        if (remaining <= 0) {
          warnings.push({ type: 'limit_reached', message: 'You have reached your daily loss limit.' });
        } else if (remaining < playerData.financial.limits.dailyLoss.set * 0.2) {
          warnings.push({ type: 'limit_close', message: `Only ${remaining} remaining of your daily loss limit.` });
        }
      }
      
      // Check for concerning patterns
      if (rg.flags.chasingLosses) {
        warnings.push({ type: 'pattern', message: 'We noticed you may be chasing losses. Consider taking a break.' });
      }
      
      if (rg.riskScore >= 7) {
        warnings.push({ type: 'risk', message: 'Please gamble responsibly. Support: 1-800-522-4700' });
      }
      
      return warnings;
    }

    // Find league name from ID
    function findLeagueName(leagueId) {
      for (const [sport, config] of Object.entries(ALL_SPORTS)) {
        if (config.leagues[leagueId]) {
          return config.leagues[leagueId];
        }
      }
      return leagueId;
    }

    // ============================================
    // üéØ SMART RECOMMENDATIONS ENGINE
    // ============================================

    async function generateRecommendations() {
      const playerSummary = getPlayerSummaryForAI();
      const rgWarnings = checkResponsibleGamblingStatus();
      const recommendations = [];

      // Check responsible gambling first
      if (rgWarnings.some(w => w.type === 'limit_reached')) {
        return {
          playerProfile: playerSummary,
          recommendations: [],
          warning: rgWarnings[0].message,
          message: 'No suggestions available - daily limit reached. Please gamble responsibly.',
        };
      }

      // Get leagues to analyze (favorites first, then most viewed)
      let leaguesToAnalyze = playerData.preferences.favoriteLeagues.map(l => l.id);
      
      // Add most viewed leagues not already in favorites
      const topViewed = Object.entries(playerData.behavior.browsing.leagueViews)
        .sort((a, b) => b[1].views - a[1].views)
        .slice(0, 3)
        .map(([league]) => league);
      
      for (const league of topViewed) {
        if (!leaguesToAnalyze.includes(league)) {
          leaguesToAnalyze.push(league);
        }
      }

      // Default to popular leagues if no history
      if (leaguesToAnalyze.length === 0) {
        leaguesToAnalyze = ['eng.1', 'esp.1', 'nba', 'nfl'];
      }

      // Analyze each league for good betting opportunities
      for (const leagueId of leaguesToAnalyze.slice(0, 4)) {
        try {
          const resolved = resolveLeague(leagueId) || { sport: 'soccer', league: leagueId };
          const gamesData = await fetchGames(leagueId);
          
          if (gamesData.error || !gamesData.upcomingGames) continue;

          // Analyze upcoming games
          for (const game of gamesData.upcomingGames.slice(0, 5)) {
            if (!game.homeTeam || !game.awayTeam) continue;

            // Check if dismissed
            const recId = `rec_${game.id}`;
            if (playerData.aiPersonalization.recommendations.dismissed.includes(recId)) continue;

            // Get team stats for analysis
            const analysis = await analyzeMatchup(game.homeTeam.name, game.awayTeam.name, resolved.league);
            
            if (analysis && analysis.confidence !== 'Low') {
              // Check if favorite team involved
              const favoriteTeamInvolved = playerData.preferences.favoriteTeams.some(
                t => t.name === game.homeTeam.name || t.name === game.awayTeam.name
              );

              // Check if in player's profitable patterns
              const isProfitableTeam = playerData.aiPersonalization.learnedPreferences.profitableTeams.some(
                t => t.team === analysis.favorite
              );

              recommendations.push({
                id: recId,
                type: 'match_recommendation',
                league: leagueId,
                leagueName: gamesData.leagueName,
                match: {
                  home: game.homeTeam.name,
                  away: game.awayTeam.name,
                  startTime: game.startTime,
                  venue: game.venue,
                },
                analysis: analysis,
                personalization: {
                  favoriteTeamInvolved,
                  isProfitableTeam,
                  matchesRiskTolerance: checkRiskTolerance(analysis.favoriteOdds),
                  matchesOddsPreference: checkOddsPreference(parseFloat(analysis.favoriteOdds)),
                },
                reason: generateRecommendationReason(analysis, playerSummary, favoriteTeamInvolved, isProfitableTeam),
                suggestedStake: calculateSuggestedStake(analysis.confidence, parseFloat(analysis.favoriteProb)),
              });
            }
          }
        } catch (e) {
          console.log(`Could not analyze league ${leagueId}:`, e);
        }
      }

      // Sort by personalization score and confidence
      recommendations.sort((a, b) => {
        // Prioritize favorite teams
        if (a.personalization.favoriteTeamInvolved && !b.personalization.favoriteTeamInvolved) return -1;
        if (b.personalization.favoriteTeamInvolved && !a.personalization.favoriteTeamInvolved) return 1;
        
        // Then by confidence
        if (a.analysis.confidence === 'High' && b.analysis.confidence !== 'High') return -1;
        if (b.analysis.confidence === 'High' && a.analysis.confidence !== 'High') return 1;
        
        // Then by probability
        return parseFloat(b.analysis.favoriteProb) - parseFloat(a.analysis.favoriteProb);
      });

      return {
        playerProfile: playerSummary,
        recommendations: recommendations.slice(0, 10),
        warnings: rgWarnings,
        generatedAt: new Date().toISOString(),
        basedOn: leaguesToAnalyze.map(l => findLeagueName(l)),
      };
    }

    // Check if odds match player's risk tolerance
    function checkRiskTolerance(odds) {
      const decimalOdds = parseFloat(odds);
      const tolerance = playerData.preferences.riskTolerance;
      
      switch (tolerance) {
        case 'low': return decimalOdds <= 1.80;
        case 'medium': return decimalOdds >= 1.40 && decimalOdds <= 3.00;
        case 'high': return decimalOdds >= 2.00;
        default: return true;
      }
    }

    // Check if odds are in player's preferred range
    function checkOddsPreference(odds) {
      const range = playerData.preferences.preferredOddsRange;
      return odds >= range.min && odds <= range.max;
    }

    // Calculate suggested stake based on confidence and probability
    function calculateSuggestedStake(confidence, probability) {
      const baseStake = playerData.preferences.preferredStakeRange.average || 500;
      
      let multiplier = 1;
      if (confidence === 'High' && probability > 65) multiplier = 1.2;
      if (confidence === 'Low') multiplier = 0.5;
      
      const suggested = Math.round(baseStake * multiplier / 100) * 100;
      return Math.min(suggested, playerData.preferences.preferredStakeRange.max);
    }

    // Quick matchup analysis for recommendations
    async function analyzeMatchup(homeTeam, awayTeam, league) {
      try {
        // Search for teams
        const homeSearch = await searchTeam(homeTeam);
        const awaySearch = await searchTeam(awayTeam);

        if (homeSearch.totalFound === 0 || awaySearch.totalFound === 0) {
          return null;
        }

        const home = homeSearch.results[0];
        const away = awaySearch.results[0];

        // Get basic stats
        const homeUrl = buildUrl(home.sport, home.league, `teams/${home.id}`);
        const awayUrl = buildUrl(away.sport, away.league, `teams/${away.id}`);

        const [homeRes, awayRes] = await Promise.all([
          fetch(homeUrl).then(r => r.json()).catch(() => null),
          fetch(awayUrl).then(r => r.json()).catch(() => null),
        ]);

        if (!homeRes?.team || !awayRes?.team) return null;

        // Extract records
        const homeRecord = homeRes.team.record?.items?.[0];
        const awayRecord = awayRes.team.record?.items?.[0];

        const homeStats = {};
        const awayStats = {};
        (homeRecord?.stats || []).forEach(s => { homeStats[s.name] = s.value; });
        (awayRecord?.stats || []).forEach(s => { awayStats[s.name] = s.value; });

        const homeWinPct = homeStats.winPercent || 0.5;
        const awayWinPct = awayStats.winPercent || 0.5;

        // Calculate probabilities (home advantage factor)
        const homeAdvantage = 0.05;
        let homeProb = (homeWinPct + homeAdvantage) / (homeWinPct + awayWinPct + homeAdvantage);
        let awayProb = 1 - homeProb;

        // Determine favorite
        const favorite = homeProb > awayProb ? 'home' : 'away';
        const favoriteProb = Math.max(homeProb, awayProb) * 100;
        const favoriteTeam = favorite === 'home' ? homeTeam : awayTeam;
        const favoriteOdds = probabilityToDecimalOdds(Math.max(homeProb, awayProb));

        // Confidence based on data quality and probability difference
        let confidence = 'Medium';
        if (favoriteProb > 65 && homeRecord && awayRecord) confidence = 'High';
        if (favoriteProb < 55 || !homeRecord || !awayRecord) confidence = 'Low';

        return {
          homeTeam,
          awayTeam,
          homeWinPct: (homeWinPct * 100).toFixed(1) + '%',
          awayWinPct: (awayWinPct * 100).toFixed(1) + '%',
          homeProb: (homeProb * 100).toFixed(1) + '%',
          awayProb: (awayProb * 100).toFixed(1) + '%',
          favorite: favoriteTeam,
          favoriteProb: favoriteProb.toFixed(1),
          favoriteOdds,
          confidence,
          homeRecord: homeRecord?.summary || 'N/A',
          awayRecord: awayRecord?.summary || 'N/A',
        };

      } catch (e) {
        console.log('Matchup analysis error:', e);
        return null;
      }
    }

    function probabilityToDecimalOdds(prob) {
      return (1 / prob).toFixed(2);
    }

    function generateRecommendationReason(analysis, profile, favoriteTeamInvolved, isProfitableTeam) {
      const reasons = [];
      
      if (favoriteTeamInvolved) {
        reasons.push(`‚≠ê Your favorite team is playing!`);
      }

      if (isProfitableTeam) {
        reasons.push(`üìà You have a good track record betting on ${analysis.favorite}`);
      }
      
      if (parseFloat(analysis.favoriteProb) > 65) {
        reasons.push(`${analysis.favorite} has a strong ${analysis.favoriteProb}% win probability`);
      }
      
      if (analysis.confidence === 'High') {
        reasons.push('High confidence based on season data');
      }

      if (analysis.homeRecord && analysis.homeRecord !== 'N/A') {
        reasons.push(`Form: ${analysis.homeTeam} (${analysis.homeRecord}) vs ${analysis.awayTeam} (${analysis.awayRecord})`);
      }

      if (reasons.length === 0) {
        reasons.push('Based on current team statistics');
      }

      return reasons.join('. ');
    }

    // Get personalized suggestions for a specific league
    async function getLeagueSuggestions(leagueInput) {
      const resolved = resolveLeague(leagueInput);
      if (!resolved) {
        return { error: `Unknown league: ${leagueInput}` };
      }

      // Track this league view
      const leagueName = ALL_SPORTS[resolved.sport]?.leagues[resolved.league] || leagueInput;
      trackLeagueView(resolved.league, leagueName);

      const gamesData = await fetchGames(leagueInput);
      if (gamesData.error) return gamesData;

      const suggestions = [];
      const rgWarnings = checkResponsibleGamblingStatus();

      // Analyze upcoming games for best opportunities
      for (const game of (gamesData.upcomingGames || []).slice(0, 8)) {
        if (!game.homeTeam || !game.awayTeam) continue;

        const analysis = await analyzeMatchup(game.homeTeam.name, game.awayTeam.name, resolved.league);
        
        if (analysis) {
          // Track team views
          trackTeamView(game.homeTeam.name, resolved.league);
          trackTeamView(game.awayTeam.name, resolved.league);

          // Check personalization factors
          const favoriteTeamInvolved = playerData.preferences.favoriteTeams.some(
            t => t.name === game.homeTeam.name || t.name === game.awayTeam.name
          );

          suggestions.push({
            match: `${game.awayTeam.name} @ ${game.homeTeam.name}`,
            startTime: game.startTime,
            venue: game.venue,
            analysis,
            suggestedBet: analysis.favorite,
            odds: analysis.favoriteOdds,
            confidence: analysis.confidence,
            winProbability: analysis.favoriteProb + '%',
            favoriteTeamInvolved,
            suggestedStake: calculateSuggestedStake(analysis.confidence, parseFloat(analysis.favoriteProb)),
          });
        }
      }

      // Sort by confidence, then favorite team, then probability
      suggestions.sort((a, b) => {
        if (a.favoriteTeamInvolved && !b.favoriteTeamInvolved) return -1;
        if (b.favoriteTeamInvolved && !a.favoriteTeamInvolved) return 1;
        if (a.confidence === 'High' && b.confidence !== 'High') return -1;
        if (b.confidence === 'High' && a.confidence !== 'High') return 1;
        return parseFloat(b.winProbability) - parseFloat(a.winProbability);
      });

      return {
        league: leagueInput,
        leagueName: gamesData.leagueName,
        totalUpcoming: gamesData.upcomingGames?.length || 0,
        suggestions: suggestions.slice(0, 6),
        playerFavorite: playerData.preferences.favoriteLeagues.some(l => l.id === resolved.league),
        warnings: rgWarnings,
        playerContext: {
          riskTolerance: playerData.preferences.riskTolerance,
          preferredStake: playerData.preferences.preferredStakeRange.average,
          favoriteTeamsInLeague: playerData.preferences.favoriteTeams.filter(t => t.league === resolved.league),
        },
        disclaimer: '‚ö†Ô∏è These are statistical suggestions based on team performance. Gambling involves risk - never bet more than you can afford to lose.',
      };
    }

    // ============================================
    // TEAM ANALYTICS FUNCTIONS
    // ============================================

    async function fetchTeamStats(teamName, leagueInput = null) {
      // First, search for the team
      const searchResults = await searchTeam(teamName);
      
      if (searchResults.totalFound === 0) {
        return { 
          error: `Team "${teamName}" not found`,
          hint: 'Try the full team name like "Manchester United" or "Los Angeles Lakers"',
        };
      }

      // Use first result or filter by league
      let team = searchResults.results[0];
      if (leagueInput) {
        const resolved = resolveLeague(leagueInput);
        if (resolved) {
          const match = searchResults.results.find(t => t.sport === resolved.sport && t.league === resolved.league);
          if (match) team = match;
        }
      }

      const url = buildUrl(team.sport, team.league, `teams/${team.id}`);
      
      try {
        const response = await fetchWithRetry(url);
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        
        const data = await response.json();
        const teamData = data.team;
        
        // Get record and stats
        const record = teamData.record?.items?.[0];
        const stats = {};
        (record?.stats || []).forEach(s => { stats[s.name] = s.value; });

        // Calculate form from recent results if available, otherwise use season record
        const wins = stats.wins || 0;
        const losses = stats.losses || 0;
        const totalGames = wins + losses;
        const last10Wins = Math.min(wins, 10);
        const last10Losses = Math.min(losses, 10 - last10Wins);

        return {
          team: {
            name: teamData.displayName,
            abbreviation: teamData.abbreviation,
            logo: teamData.logos?.[0]?.href,
            sport: team.sport,
            league: team.league,
            leagueName: ALL_SPORTS[team.sport]?.leagues[team.league],
          },
          record: {
            overall: record?.summary || 'N/A',
            wins: wins,
            losses: losses,
            winPercentage: stats.winPercent ? (stats.winPercent * 100).toFixed(1) + '%' : (totalGames > 0 ? ((wins/totalGames)*100).toFixed(1) + '%' : 'N/A'),
            pointsFor: stats.pointsFor || stats.avgPointsFor || 'N/A',
            pointsAgainst: stats.pointsAgainst || stats.avgPointsAgainst || 'N/A',
          },
          form: {
            last10: totalGames > 0 ? `${last10Wins}-${last10Losses}` : 'N/A',
            streak: stats.streak || 'N/A',
          },
          standings: teamData.standingSummary || 'N/A',
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        return { error: error.message, team: teamName };
      }
    }

    async function fetchHeadToHead(team1Name, team2Name, leagueInput = null) {
      const team1Stats = await fetchTeamStats(team1Name, leagueInput);
      const team2Stats = await fetchTeamStats(team2Name, leagueInput);

      if (team1Stats.error) return { error: `Team 1: ${team1Stats.error}` };
      if (team2Stats.error) return { error: `Team 2: ${team2Stats.error}` };

      const probability = calculateMatchProbability(team1Stats, team2Stats);

      return {
        team1: {
          name: team1Stats?.team?.name || team1Name,
          record: team1Stats?.record?.overall || 'N/A',
          winPct: team1Stats?.record?.winPercentage || 'N/A',
        },
        team2: {
          name: team2Stats?.team?.name || team2Name,
          record: team2Stats?.record?.overall || 'N/A',
          winPct: team2Stats?.record?.winPercentage || 'N/A',
        },
        analysis: probability,
        fetchedAt: new Date().toISOString(),
      };
    }

    async function fetchLeagueStandings(leagueInput) {
      const resolved = resolveLeague(leagueInput);
      if (!resolved) {
        return { error: `Unknown league: ${leagueInput}` };
      }

      const url = buildStandingsUrl(resolved.sport, resolved.league);
      if (!url) return { error: `Standings not available for ${leagueInput}` };

      try {
        const response = await fetchWithRetry(url);
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        
        const data = await response.json();
        const standings = [];

        // Parse standings - structure varies by sport
        const groups = data.children || [data];
        for (const group of groups) {
          const groupName = group.name || '';
          const entries = group.standings?.entries || [];
          
          for (const entry of entries) {
            const team = entry.team;
            const stats = {};
            (entry.stats || []).forEach(s => { stats[s.name] = s.value; });
            
            standings.push({
              group: groupName,
              rank: stats.playoffSeed || stats.rank || 'N/A',
              team: team.displayName,
              played: stats.gamesPlayed || stats.played || 'N/A',
              wins: stats.wins || 0,
              draws: stats.ties || stats.draws || 0,
              losses: stats.losses || 0,
              points: stats.points || 'N/A',
              winPct: stats.winPercent ? (stats.winPercent * 100).toFixed(1) + '%' : 'N/A',
              goalsFor: stats.pointsFor || stats.goalsFor || 'N/A',
              goalsAgainst: stats.pointsAgainst || stats.goalsAgainst || 'N/A',
            });
          }
        }

        return {
          league: leagueInput,
          leagueName: ALL_SPORTS[resolved.sport]?.leagues[resolved.league],
          standings: standings.slice(0, 25),
          totalTeams: standings.length,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        return { error: error.message, league: leagueInput };
      }
    }

    // ============================================
    // PROBABILITY CALCULATION ENGINE
    // ============================================

    function calculateMatchProbability(team1Stats, team2Stats) {
      // Extra safety: if either stats object is null/undefined, return default values
      if (!team1Stats || !team2Stats) {
        return {
          team1Probability: '50.0%',
          team2Probability: '50.0%',
          impliedOdds: {
            team1: { american: '-100', decimal: '2.00' },
            team2: { american: '-100', decimal: '2.00' },
          },
          factors: {
            seasonRecord: { team1: 'N/A', team2: 'N/A', weight: '40%' },
            recentForm: { team1: 'N/A', team2: 'N/A', weight: '30%' },
            efficiency: { team1: 'N/A', team2: 'N/A', weight: '30%' },
          },
          confidence: 'Low',
          disclaimer: '‚ö†Ô∏è Insufficient data for probability calculation.',
        };
      }

      try {
        // Safely access nested properties with defaults
        const getFormLast10 = (stats) => stats?.form?.last10 || 'N/A';
        const getWinPct = (stats) => {
          const pct = stats?.record?.winPercentage;
          if (!pct || pct === 'N/A') return 0.5;
          return parseFloat(pct) / 100 || 0.5;
        };
        const getPoints = (stats, type) => {
          const val = stats?.record?.[type];
          if (!val || val === 'N/A') return 100;
          return parseFloat(val) || 100;
        };

        // Extract key metrics with safe defaults
        const t1 = {
          winPct: getWinPct(team1Stats),
          form: parseFormPercentage(getFormLast10(team1Stats)),
          ppg: getPoints(team1Stats, 'pointsFor'),
          papg: getPoints(team1Stats, 'pointsAgainst'),
        };
        
        const t2 = {
          winPct: getWinPct(team2Stats),
          form: parseFormPercentage(getFormLast10(team2Stats)),
          ppg: getPoints(team2Stats, 'pointsFor'),
          papg: getPoints(team2Stats, 'pointsAgainst'),
        };

      // Calculate various probability factors
      
      // 1. Win percentage factor (40% weight)
      const winPctFactor = t1.winPct / (t1.winPct + t2.winPct);
      
      // 2. Recent form factor (30% weight)
      const formFactor = t1.form / (t1.form + t2.form + 0.001);
      
      // 3. Offensive/Defensive efficiency (30% weight)
      const t1Efficiency = t1.ppg / (t1.papg + 0.001);
      const t2Efficiency = t2.ppg / (t2.papg + 0.001);
      const efficiencyFactor = t1Efficiency / (t1Efficiency + t2Efficiency);

      // Weighted probability
      const team1Prob = (winPctFactor * 0.4) + (formFactor * 0.3) + (efficiencyFactor * 0.3);
      const team2Prob = 1 - team1Prob;

      // Convert to odds
      const team1Odds = probabilityToAmericanOdds(team1Prob);
      const team2Odds = probabilityToAmericanOdds(team2Prob);
      const team1Decimal = (1 / team1Prob).toFixed(2);
      const team2Decimal = (1 / team2Prob).toFixed(2);

      // Confidence level based on data quality
      const confidence = calculateConfidence(team1Stats, team2Stats);

      return {
        team1Probability: (team1Prob * 100).toFixed(1) + '%',
        team2Probability: (team2Prob * 100).toFixed(1) + '%',
        impliedOdds: {
          team1: {
            american: team1Odds,
            decimal: team1Decimal,
          },
          team2: {
            american: team2Odds,
            decimal: team2Decimal,
          },
        },
        factors: {
          seasonRecord: {
            team1: team1Stats?.record?.winPercentage || 'N/A',
            team2: team2Stats?.record?.winPercentage || 'N/A',
            weight: '40%',
          },
          recentForm: {
            team1: team1Stats?.form?.last10 || 'N/A',
            team2: team2Stats?.form?.last10 || 'N/A',
            weight: '30%',
          },
          efficiency: {
            team1: `${t1.ppg.toFixed(1)} PPG / ${t1.papg.toFixed(1)} PAPG`,
            team2: `${t2.ppg.toFixed(1)} PPG / ${t2.papg.toFixed(1)} PAPG`,
            weight: '30%',
          },
        },
        confidence: confidence,
        disclaimer: '‚ö†Ô∏è These probabilities are estimates based on available statistics. Gambling involves risk and past performance does not guarantee future results.',
      };
      } catch (e) {
        console.error('Error in calculateMatchProbability:', e);
        return {
          team1Probability: '50.0%',
          team2Probability: '50.0%',
          impliedOdds: {
            team1: { american: '-100', decimal: '2.00' },
            team2: { american: '-100', decimal: '2.00' },
          },
          factors: {
            seasonRecord: { team1: 'N/A', team2: 'N/A', weight: '40%' },
            recentForm: { team1: 'N/A', team2: 'N/A', weight: '30%' },
            efficiency: { team1: 'N/A', team2: 'N/A', weight: '30%' },
          },
          confidence: 'Low',
          disclaimer: '‚ö†Ô∏è Error calculating probabilities.',
        };
      }
    }

    function parseFormPercentage(form) {
      if (!form || form === 'N/A') return 0.5;
      const parts = form.split('-');
      if (parts.length !== 2) return 0.5;
      const wins = parseInt(parts[0]) || 0;
      const total = wins + (parseInt(parts[1]) || 0);
      return total > 0 ? wins / total : 0.5;
    }

    function probabilityToAmericanOdds(prob) {
      if (prob >= 0.5) {
        const odds = Math.round(-(prob / (1 - prob)) * 100);
        return odds;
      } else {
        const odds = Math.round(((1 - prob) / prob) * 100);
        return '+' + odds;
      }
    }

    function calculateConfidence(team1Stats, team2Stats) {
      // Safety check
      if (!team1Stats || !team2Stats) return 'Low';
      
      let score = 0;
      
      try {
        // Check data availability with safe access
        if (team1Stats?.record?.winPercentage && team1Stats.record.winPercentage !== 'N/A') score += 25;
        if (team2Stats?.record?.winPercentage && team2Stats.record.winPercentage !== 'N/A') score += 25;
        if (team1Stats?.form?.last10 && team1Stats.form.last10 !== 'N/A') score += 15;
        if (team2Stats?.form?.last10 && team2Stats.form.last10 !== 'N/A') score += 15;
        if (team1Stats?.record?.pointsFor && team1Stats.record.pointsFor !== 'N/A') score += 10;
        if (team2Stats?.record?.pointsFor && team2Stats.record.pointsFor !== 'N/A') score += 10;
      } catch (e) {
        console.error('Error in calculateConfidence:', e);
        return 'Low';
      }

      if (score >= 80) return 'High';
      if (score >= 50) return 'Medium';
      return 'Low';
    }

    // Calculate payout
    function calculatePayout(odds, stake) {
      let profit;
      if (odds > 0) {
        profit = (stake * odds) / 100;
      } else {
        profit = (stake * 100) / Math.abs(odds);
      }
      
      const impliedProb = odds > 0 
        ? 100 / (odds + 100) 
        : Math.abs(odds) / (Math.abs(odds) + 100);

      return {
        odds: odds,
        stake: stake,
        profit: profit.toFixed(2),
        totalReturn: (stake + profit).toFixed(2),
        impliedProbability: (impliedProb * 100).toFixed(1) + '%',
      };
    }

    // ============================================
    // BWANABET API FUNCTIONS
    // ============================================

    async function fetchBwanabetOdds(sport = 'all') {
      const endpoint = BWANABET_CONFIG.endpoints.odds[sport] || BWANABET_CONFIG.endpoints.odds.all;
      const url = BWANABET_CONFIG.baseUrl + endpoint;
      
      console.log(`üé≤ Fetching odds from bwanabet: ${url}`);
      
      try {
        const headers = { ...BWANABET_CONFIG.headers };
        
        // Add auth header if configured
        if (BWANABET_CONFIG.auth.apiKey && BWANABET_CONFIG.auth.authHeader) {
          headers[BWANABET_CONFIG.auth.authHeader] = BWANABET_CONFIG.auth.apiKey;
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: headers,
          mode: 'cors', // May need to adjust based on bwanabet's CORS policy
        });

        if (!response.ok) {
          throw new Error(`Bwanabet API error: ${response.status}`);
        }

        const data = await response.json();
        
        return {
          source: 'bwanabet.com',
          sport: sport,
          data: data,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        console.error('Bwanabet odds fetch error:', error);
        
        // Return mock/fallback data for demo purposes
        return {
          source: 'bwanabet.com',
          sport: sport,
          error: error.message,
          note: 'Could not fetch from bwanabet.com. Check CORS settings or API endpoint configuration.',
          // Fallback demo data
          fallbackData: {
            message: 'Configure BWANABET_CONFIG with correct API endpoints to fetch live odds.',
            exampleOdds: [
              { match: 'Team A vs Team B', homeOdds: 1.85, drawOdds: 3.40, awayOdds: 4.20 },
              { match: 'Team C vs Team D', homeOdds: 2.10, drawOdds: 3.25, awayOdds: 3.50 },
            ]
          },
          fetchedAt: new Date().toISOString(),
        };
      }
    }

    async function fetchBwanabetCasinoGames(category = 'all') {
      let endpoint;
      switch(category) {
        case 'slots': endpoint = BWANABET_CONFIG.endpoints.casino.slots; break;
        case 'live': endpoint = BWANABET_CONFIG.endpoints.casino.liveDealer; break;
        case 'table': endpoint = BWANABET_CONFIG.endpoints.casino.tableGames; break;
        case 'jackpots': endpoint = BWANABET_CONFIG.endpoints.casino.jackpots; break;
        default: endpoint = BWANABET_CONFIG.endpoints.casino.games;
      }
      
      const url = BWANABET_CONFIG.baseUrl + endpoint;
      console.log(`üé∞ Fetching casino games from bwanabet: ${url}`);
      
      try {
        const headers = { ...BWANABET_CONFIG.headers };
        
        if (BWANABET_CONFIG.auth.apiKey && BWANABET_CONFIG.auth.authHeader) {
          headers[BWANABET_CONFIG.auth.authHeader] = BWANABET_CONFIG.auth.apiKey;
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: headers,
          mode: 'cors',
        });

        if (!response.ok) {
          throw new Error(`Bwanabet Casino API error: ${response.status}`);
        }

        const data = await response.json();
        
        return {
          source: 'bwanabet.com',
          category: category,
          games: data,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        console.error('Bwanabet casino fetch error:', error);
        
        // Return fallback casino data
        return {
          source: 'bwanabet.com',
          category: category,
          error: error.message,
          note: 'Could not fetch from bwanabet.com. Check API endpoint configuration.',
          // Fallback demo data showing what structure we expect
          fallbackData: {
            message: 'Configure BWANABET_CONFIG with correct API endpoints to fetch live casino games.',
            exampleGames: [
              { name: 'Blackjack Classic', category: 'table', rtp: '99.5%', provider: 'Evolution' },
              { name: 'European Roulette', category: 'table', rtp: '97.3%', provider: 'Pragmatic' },
              { name: 'Mega Fortune', category: 'slots', rtp: '96.6%', jackpot: true },
              { name: 'Live Baccarat', category: 'live', rtp: '98.9%', provider: 'Evolution' },
            ]
          },
          fetchedAt: new Date().toISOString(),
        };
      }
    }

    async function fetchBwanabetLiveBetting() {
      const url = BWANABET_CONFIG.baseUrl + BWANABET_CONFIG.endpoints.liveBetting;
      console.log(`‚ö° Fetching live betting from bwanabet: ${url}`);
      
      try {
        const headers = { ...BWANABET_CONFIG.headers };
        
        if (BWANABET_CONFIG.auth.apiKey && BWANABET_CONFIG.auth.authHeader) {
          headers[BWANABET_CONFIG.auth.authHeader] = BWANABET_CONFIG.auth.apiKey;
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: headers,
          mode: 'cors',
        });

        if (!response.ok) {
          throw new Error(`Bwanabet Live API error: ${response.status}`);
        }

        const data = await response.json();
        
        return {
          source: 'bwanabet.com',
          type: 'live_betting',
          events: data,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        console.error('Bwanabet live betting fetch error:', error);
        
        return {
          source: 'bwanabet.com',
          type: 'live_betting',
          error: error.message,
          note: 'Could not fetch live betting data. Check API configuration.',
          fallbackData: {
            message: 'Configure BWANABET_CONFIG to fetch live betting events.',
          },
          fetchedAt: new Date().toISOString(),
        };
      }
    }

    // ============================================
    // TOOL DEFINITIONS FOR CLAUDE
    // ============================================

    const tools = [
      {
        name: 'get_player_profile',
        description: 'Get the current player\'s profile including their favorite leagues, teams, viewing history, and preferences. Use this to personalize recommendations.',
        input_schema: {
          type: 'object',
          properties: {},
          required: [],
        },
      },
      {
        name: 'update_player_preferences',
        description: 'Update the player\'s preferences like favorite leagues, teams, risk tolerance, etc.',
        input_schema: {
          type: 'object',
          properties: {
            favoriteLeagues: {
              type: 'array',
              items: { type: 'string' },
              description: 'List of favorite league IDs (e.g., ["eng.1", "esp.1"])',
            },
            favoriteTeams: {
              type: 'array',
              items: { type: 'object' },
              description: 'List of favorite teams [{name, league}]',
            },
            riskTolerance: {
              type: 'string',
              enum: ['low', 'medium', 'high'],
              description: 'Player\'s risk tolerance for betting suggestions',
            },
          },
          required: [],
        },
      },
      {
        name: 'get_recommendations',
        description: 'Generate personalized betting recommendations based on the player\'s favorite leagues and viewing history. Returns matches with high win probability.',
        input_schema: {
          type: 'object',
          properties: {},
          required: [],
        },
      },
      {
        name: 'get_league_suggestions',
        description: 'Get smart betting suggestions for a specific league. Analyzes upcoming matches and identifies games where one team has a statistical advantage.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league to get suggestions for (e.g., "Premier League", "La Liga")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'get_games',
        description: 'Fetch live, upcoming, and completed games for ANY sport or league worldwide. Supports 100+ leagues including Premier League, La Liga, Serie A, Bundesliga, Champions League, NBA, NFL, MLB, NHL, UFC, F1, Cricket IPL, and many more.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league name (e.g., "Premier League", "NBA", "La Liga", "Champions League", "UFC", "F1", "IPL")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'list_leagues',
        description: 'List all available sports and leagues. Use this when users ask what sports/leagues are available or want to browse options.',
        input_schema: {
          type: 'object',
          properties: {
            sport: {
              type: 'string',
              description: 'Optional: filter by sport (soccer, basketball, football, baseball, hockey, tennis, golf, mma, boxing, rugby, cricket, racing, esports)',
            }
          },
          required: [],
        },
      },
      {
        name: 'search_team',
        description: 'Search for a team by name across all leagues. Use this to find team information when the user mentions a team name.',
        input_schema: {
          type: 'object',
          properties: {
            team_name: {
              type: 'string',
              description: 'The team name to search for (e.g., "Manchester United", "Lakers", "Real Madrid")',
            }
          },
          required: ['team_name'],
        },
      },
      {
        name: 'get_league_teams',
        description: 'Get all teams in a specific league. Use this when users want to see all teams in a competition.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league name (e.g., "Premier League", "NBA", "Serie A")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'get_team_stats',
        description: 'Fetch detailed statistics for a specific team including record, win percentage, recent form, and roster.',
        input_schema: {
          type: 'object',
          properties: {
            team_name: {
              type: 'string',
              description: 'The team name',
            },
            league: {
              type: 'string',
              description: 'Optional: specify the league if team name is ambiguous',
            }
          },
          required: ['team_name'],
        },
      },
      {
        name: 'get_head_to_head',
        description: 'Compare two teams and calculate win probabilities based on their statistics.',
        input_schema: {
          type: 'object',
          properties: {
            team1: {
              type: 'string',
              description: 'First team name',
            },
            team2: {
              type: 'string',
              description: 'Second team name',
            },
            league: {
              type: 'string',
              description: 'Optional: specify league',
            }
          },
          required: ['team1', 'team2'],
        },
      },
      {
        name: 'get_standings',
        description: 'Fetch current league standings/table with team rankings.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league name (e.g., "Premier League", "NBA", "La Liga")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'get_bwanabet_odds',
        description: 'Fetch betting odds from bwanabet.com for any sport.',
        input_schema: {
          type: 'object',
          properties: {
            sport: {
              type: 'string',
              description: 'The sport to get odds for',
            }
          },
          required: ['sport'],
        },
      },
      {
        name: 'get_bwanabet_casino_games',
        description: 'Fetch casino games from bwanabet.com.',
        input_schema: {
          type: 'object',
          properties: {
            category: {
              type: 'string',
              description: 'Category: all, slots, table, live, jackpots',
            }
          },
          required: ['category'],
        },
      },
      {
        name: 'calculate_bet_payout',
        description: 'Calculate potential payout for a bet.',
        input_schema: {
          type: 'object',
          properties: {
            odds: {
              type: 'number',
              description: 'The odds (American or Decimal)',
            },
            stake: {
              type: 'number',
              description: 'Bet amount',
            },
          },
          required: ['odds', 'stake'],
        },
      },
    ];

    // Execute tool calls
    async function executeTool(toolName, toolInput) {
      console.log(`üîß Executing tool: ${toolName}`, toolInput);
      
      let result;
      
      switch (toolName) {
        case 'get_player_profile':
          result = getPlayerSummaryForAI();
          break;
        case 'update_player_preferences':
          result = updatePlayerPreferences(toolInput);
          break;
        case 'get_recommendations':
          result = await generateRecommendations();
          break;
        case 'get_league_suggestions':
          result = await getLeagueSuggestions(toolInput.league);
          break;
        case 'get_games':
          result = await fetchGames(toolInput.league);
          break;
        case 'list_leagues':
          result = listAvailableLeagues(toolInput.sport);
          break;
        case 'search_team':
          result = await searchTeam(toolInput.team_name);
          break;
        case 'get_league_teams':
          result = await fetchLeagueTeams(toolInput.league);
          break;
        case 'get_team_stats':
          result = await fetchTeamStats(toolInput.team_name, toolInput.league);
          break;
        case 'get_head_to_head':
          result = await fetchHeadToHead(toolInput.team1, toolInput.team2, toolInput.league);
          break;
        case 'get_standings':
          result = await fetchLeagueStandings(toolInput.league);
          break;
        case 'get_bwanabet_odds':
          result = await fetchBwanabetOdds(toolInput.sport);
          break;
        case 'get_bwanabet_casino_games':
          result = await fetchBwanabetCasinoGames(toolInput.category);
          break;
        case 'calculate_bet_payout':
          result = calculatePayout(toolInput.odds, toolInput.stake);
          break;
        default:
          result = { error: `Unknown tool: ${toolName}` };
      }
      
      // Truncate large results to save tokens and improve response time
      return truncateForClaude(result);
    }

    // ============================================
    // SYSTEM PROMPT
    // ============================================

    const SYSTEM_PROMPT = `You are BetAssist, a friendly betting assistant for Bwanabet. You help users with sports betting and casino games.

## üéØ YOUR PERSONALITY

- **Always call the user "Bwana"** (e.g., "Hey Bwana!", "Looking good Bwana!")
- **Sound human and friendly** - NOT robotic or AI-like
- **Keep responses SHORT** - 2-4 sentences max, then offer "Want more details?"
- **Use emojis naturally** but don't overdo it üéØ‚öΩüí∞
- **Never say** "I'm an AI" or "As an AI assistant" - just be helpful
- **Never say** "I provide personalized betting suggestions based on your preferences"

## üí∞ CURRENCY

- **ONLY use Zambian Kwacha (ZMW)** for all amounts
- Format: ZMW 500, ZMW 1,000, etc.

## üë§ PLAYER DATA ACCESS

You have access to player data via \`get_player_profile\`:
- Favorite leagues & teams
- Betting history & win rate
- Risk tolerance
- Bonuses available
- Daily limits

## üéÅ BONUSES - ALWAYS REMIND!

When greeting or giving suggestions, remind Bwana of available bonuses:
- "Don't forget you've got a bonus waiting! üéÅ"
- "Your bonus balance could boost this bet, Bwana!"
- Check player profile for bonus amounts

## üé≤ STRATEGIES

You can offer betting strategies when asked! Topics include:
- **Sports**: Value betting, bankroll management, form analysis, in-play tips
- **Casino**: Martingale, Paroli, bankroll limits, game-specific tips

**ALWAYS add disclaimer**: "Just remember Bwana - no strategy guarantees wins. Gamble responsibly! üôè"

## üìù RESPONSE FORMAT

**Keep it short!** Example:

‚ùå Wrong (too long):
"Based on your comprehensive betting history and analysis of current form, I've identified several opportunities across multiple leagues that align with your risk profile..."

‚úÖ Right (short & friendly):
"Hey Bwana! üî• Got a hot pick for you - Liverpool looking strong today at 1.85 odds. Your kind of bet! Want me to break down the stats?"

## üéØ WHEN GIVING MATCH SUGGESTIONS - ALWAYS SHOW 5 BET OPTIONS!

**CRITICAL: When recommending bets for a match, ALWAYS provide 5 DIFFERENT bet types**, not just match winner. This gives Bwana variety and better chances!

**Format for match recommendations:**

"Hey Bwana! üî• Here's **[Home] vs [Away]** - my top 5 picks:

1Ô∏è‚É£ **Match Result**: [Team] to win @ [odds] - [confidence]% confidence
2Ô∏è‚É£ **Double Chance**: [Team] or Draw @ [odds] - [confidence]% (safer option!)
3Ô∏è‚É£ **Goals**: Over/Under 2.5 @ [odds] - [confidence]% based on league avg
4Ô∏è‚É£ **BTTS**: Both Teams to Score - Yes @ [odds] - [confidence]%
5Ô∏è‚É£ **Corners**: Over 9.5 corners @ [odds] - [confidence]%

üí° **My top pick**: [Best value option with reason]
üí∞ Suggested stake: ZMW [amount]

Want details on corners, cards, or other markets? üìä"

**Available bet types to mix and match:**
- Match Result (1X2)
- Double Chance (1X, X2, 12)
- Over/Under Goals (1.5, 2.5, 3.5)
- Both Teams to Score (BTTS)
- Corners (Over/Under 8.5, 9.5, 10.5)
- Cards (Over/Under 2.5, 3.5 cards)
- First Half Result
- Handicap
- Clean Sheet
- First Goal / Last Goal

**Confidence levels based on data:**
- 70%+ = High confidence üî•
- 55-69% = Medium confidence ‚úÖ
- Below 55% = Risky but value üé≤

## üé∞ CASINO GAMES

Also help with casino games:
- Slots, Roulette, Blackjack, Poker
- Explain games simply
- Offer strategies WITH disclaimers
- Remind about bonuses

## ‚ö†Ô∏è RESPONSIBLE GAMBLING

- If player is on a losing streak, be supportive
- If limits reached, inform them kindly
- Never push bets
- Support line: 1-800-522-4700

## üåç COVERAGE

100+ leagues: Premier League, La Liga, Serie A, Bundesliga, Champions League, NBA, NFL, MLB, NHL, UFC, F1, Cricket & more!

## ‚ö° SPEED - RESPOND FAST!

**IMPORTANT: Only use tools when absolutely necessary!**

Answer these WITHOUT tools (instant response):
- Greetings: "Hey Bwana!" "How are you?"
- Strategy questions: "What's the best betting strategy?"
- Casino explanations: "How do I play blackjack?"
- General questions: "What sports do you cover?"
- Encouragement: "I lost my bet" ‚Üí Be supportive
- Bonuses: "What bonuses do I have?" ‚Üí Check profile memory

Only use tools for:
- Specific live game data: "What's the score of the Liverpool game?"
- Today's matches: "What games are on today?"
- Specific recommendations: "Give me EPL picks"
- Team stats: "How is Manchester United doing?"

Remember: Be Bwana's helpful friend, always show 5 bet options, sound human! üéØ`;

    // ============================================
    // CLAUDE API WITH TOOL CALLING
    // ============================================

    // Helper function to call Claude via Supabase proxy
    async function callClaudeProxy(messages, system, tools) {
      const response = await fetch(SUPABASE_CONFIG.claudeProxyUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${SUPABASE_CONFIG.anonKey}`,
        },
        body: JSON.stringify({ messages, system, tools })
      });

      if (!response.ok) {
        const error = await response.json();
        console.error('‚ùå Proxy Error:', error);
        throw new Error(error.error?.message || `Proxy request failed with status ${response.status}`);
      }

      return await response.json();
    }

    async function callClaudeWithTools(userMessage) {
      conversationHistory.push({
        role: 'user',
        content: userMessage
      });

      console.log('üì§ Sending message via Supabase proxy...');
      console.log('üìù Message:', userMessage);

      try {
        let data = await callClaudeProxy(conversationHistory, SYSTEM_PROMPT, tools);
        console.log('‚úÖ Response received:', data.stop_reason);
        
        // Handle tool use loop
        while (data.stop_reason === 'tool_use') {
          const toolUseBlocks = data.content.filter(block => block.type === 'tool_use');
          
          // Add assistant's response (with tool calls) to history
          conversationHistory.push({
            role: 'assistant',
            content: data.content
          });

          // ‚ö° SPEED: Execute ALL tools in PARALLEL instead of sequentially
          updateTypingStatus('Typing...');
          console.log(`‚ö° Executing ${toolUseBlocks.length} tools in parallel...`);
          
          const toolPromises = toolUseBlocks.map(async (toolUse) => {
            const result = await executeTool(toolUse.name, toolUse.input);
            console.log(`üìä Tool ${toolUse.name} complete`);
            return {
              type: 'tool_result',
              tool_use_id: toolUse.id,
              content: JSON.stringify(result, null, 2)
            };
          });

          // Wait for ALL tools to complete at once
          const toolResults = await Promise.all(toolPromises);

          // Add tool results to history
          conversationHistory.push({
            role: 'user',
            content: toolResults
          });

          updateTypingStatus('Typing...');

          // Continue conversation with tool results
          data = await callClaudeProxy(conversationHistory, SYSTEM_PROMPT, tools);
        }

        // Extract final text response
        const textContent = data.content
          .filter(block => block.type === 'text')
          .map(block => block.text)
          .join('\n');

        // Add final response to history
        conversationHistory.push({
          role: 'assistant',
          content: textContent
        });

        // Keep history manageable
        if (conversationHistory.length > 30) {
          conversationHistory = conversationHistory.slice(-30);
        }

        return textContent;

      } catch (error) {
        console.error('Claude API error:', error);
        conversationHistory.pop(); // Remove failed message
        
        if (error.message.includes('Invalid API Key') || error.message.includes('authentication')) {
          return '‚ùå **Invalid API Key**\n\nPlease check your API key and try again.';
        }
        
        return `‚ùå **Error**\n\n${error.message}`;
      }
    }

    // ============================================
    // UI FUNCTIONS
    // ============================================

    function updateTypingStatus(status) {
      document.getElementById('typingStatus').textContent = status;
    }

    function clearChat() {
      conversationHistory = [];
      document.getElementById('messages').innerHTML = '';
      addMessage(`üîÑ **Chat cleared!**\n\nHow can I help you? Ask me about live games, odds, or betting!`, false);
    }

    async function sendMessage() {
      if (isProcessing) return;
      
      // Check if online
      if (!isOnline()) {
        addMessage("üì∂ You're offline, Bwana! Check your internet connection and try again.", false, [
          { text: 'üîÑ Retry', action: 'hi' },
        ]);
        return;
      }
      
      // Rate limiting - prevent spam
      const now = Date.now();
      if (now - lastMessageTime < MESSAGE_COOLDOWN) {
        console.log('‚è≥ Please wait before sending another message');
        return;
      }
      lastMessageTime = now;
      
      const input = document.getElementById('messageInput');
      const message = input.value.trim();
      
      if (!message) return;
      
      input.value = '';
      addMessage(message, true);
      
      // ‚ö° INSTANT RESPONSES - No API call needed for simple messages!
      const instantResult = getInstantResponse(message);
      if (instantResult) {
        console.log('‚ö° Instant response (no API call)');
        setTimeout(() => {
          addMessage(instantResult.response, false, instantResult.quickActions || []);
        }, 300); // Small delay feels natural
        return;
      }
      
      // Check session time and remind user to take breaks
      const sessionMinutes = (now - sessionStart) / 60000;
      if (sessionMinutes > 60 && !sessionWarningShown) {
        sessionWarningShown = true;
        setTimeout(() => {
          addMessage("‚è∞ Hey Bwana, you've been here over an hour! Remember to take breaks and gamble responsibly. üôè", false, [
            { text: '‚úÖ Got it', action: 'thanks' },
            { text: 'üéØ More tips', action: 'give me tips' },
          ]);
        }, 500);
      }
      
      isProcessing = true;
      document.getElementById('sendButton').disabled = true;
      document.getElementById('typingIndicator').classList.remove('hidden');
      updateTypingStatus('Typing...');
      
      try {
        const response = await callClaudeWithTools(message);
        // Detect topic from user message to provide relevant quick actions
        const detectedTopic = detectMessageTopic(message);
        const defaultActions = getContextualQuickActions(detectedTopic);
        addMessage(response, false, defaultActions);
      } catch (error) {
        console.error('‚ùå Error in sendMessage:', error);
        addMessage(`‚ùå **Error**\n\n${error.message}\n\nPlease check the browser console for details.`, false, [
          { text: 'üîÑ Try again', action: message },
          { text: '‚ùì Help', action: 'help' },
        ]);
      } finally {
        isProcessing = false;
        document.getElementById('sendButton').disabled = false;
        document.getElementById('typingIndicator').classList.add('hidden');
        updateTypingStatus('');
      }
    }

    // ‚ö° INSTANT RESPONSES - Handle common messages without API calls
    // ============================================
    // üé∞ CASINO GAME STRATEGIES DATABASE
    // ============================================
    
    const CASINO_STRATEGIES = {
      aviator: {
        name: "Aviator",
        type: "Crash Game",
        description: "Watch the multiplier rise and cash out before the plane crashes!",
        strategies: [
          "**Low Risk Strategy**: Cash out early at 1.2x-1.5x. Small wins, but consistent.",
          "**Medium Risk**: Target 2x-3x multiplier. Good balance of risk/reward.",
          "**Auto Cash-Out**: Set automatic cash-out at your target to remove emotion.",
          "**Two Bets Strategy**: Place 2 bets - cash out one early (1.5x), let the other ride.",
          "**Martingale**: Double bet after loss, return to base after win. ‚ö†Ô∏è Risky!",
        ],
        tips: [
          "Watch the game history - but remember each round is independent!",
          "Set a budget BEFORE you start and stick to it",
          "Don't chase losses - the plane doesn't care about your previous bets",
          "Use auto cash-out to avoid panic decisions",
        ],
        rtp: "97%",
      },
      
      blackjack: {
        name: "Blackjack",
        type: "Card Game",
        description: "Beat the dealer by getting closer to 21 without going over.",
        strategies: [
          "**Basic Strategy** (memorize this!):",
          "‚Ä¢ Always split Aces and 8s",
          "‚Ä¢ Never split 10s or 5s", 
          "‚Ä¢ Double down on 11 (unless dealer shows Ace)",
          "‚Ä¢ Double down on 10 if dealer shows 2-9",
          "‚Ä¢ Stand on 17+ always",
          "‚Ä¢ Hit on soft 17 (Ace + 6)",
          "‚Ä¢ Stand on 12-16 if dealer shows 2-6, otherwise hit",
        ],
        tips: [
          "Dealer must hit on 16, stand on 17 - use this!",
          "Insurance is almost always a bad bet - skip it",
          "Don't take 'even money' on blackjack",
          "Card counting doesn't work online (shuffled each hand)",
        ],
        rtp: "99.5% with perfect strategy",
      },
      
      roulette: {
        name: "Roulette", 
        type: "Table Game",
        description: "Bet on where the ball will land on the spinning wheel.",
        strategies: [
          "**Martingale**: Double bet after each loss. ‚ö†Ô∏è Can hit table limits fast!",
          "**Reverse Martingale**: Double after wins, reset after loss.",
          "**D'Alembert**: Increase bet by 1 after loss, decrease by 1 after win.",
          "**James Bond**: Bet 70% on 19-36, 25% on 13-18, 5% on 0.",
          "**Column Betting**: Bet on 2 columns for 64% coverage.",
        ],
        tips: [
          "European Roulette (single 0) has better odds than American (double 00)",
          "Outside bets (red/black, odd/even) have ~48% win chance",
          "Inside bets pay more but hit less often",
          "The wheel has no memory - each spin is independent!",
        ],
        rtp: "European: 97.3% | American: 94.7%",
      },
      
      slots: {
        name: "Slots",
        type: "Video Slots",
        description: "Spin the reels and match symbols to win!",
        strategies: [
          "**Bankroll Management**: Set bet size to 1-2% of your bankroll",
          "**High RTP Slots**: Look for games with 96%+ RTP",
          "**Volatility Choice**: Low = frequent small wins, High = rare big wins",
          "**Max Bet for Jackpots**: Some progressives require max bet to qualify",
          "**Bonus Hunting**: Use free spins bonuses to extend playtime",
        ],
        tips: [
          "Check the paytable before playing - know the best symbols",
          "Set win/loss limits before you start",
          "Slots are pure luck - no skill involved",
          "Take breaks - it's easy to lose track of time and money",
        ],
        rtp: "Varies: 92-98% (check each game)",
      },
      
      poker: {
        name: "Poker (Casino/Video)",
        type: "Card Game",
        description: "Make the best 5-card hand to win.",
        strategies: [
          "**Starting Hands**: Only play strong hands (pairs, high cards, suited connectors)",
          "**Position Matters**: Play tighter early, looser in late position",
          "**Jacks or Better Strategy**:",
          "‚Ä¢ Keep any paying hand",
          "‚Ä¢ Keep 4 to a flush or straight",
          "‚Ä¢ Keep high pairs (J+)",
          "‚Ä¢ Keep 3 to a royal flush",
        ],
        tips: [
          "Video Poker has some of the best odds in the casino",
          "Always bet max coins for the royal flush bonus",
          "Learn one game well before trying others",
          "Jacks or Better is the best game for beginners",
        ],
        rtp: "Up to 99.5% with perfect play",
      },
      
      baccarat: {
        name: "Baccarat",
        type: "Card Game", 
        description: "Bet on Player, Banker, or Tie - closest to 9 wins.",
        strategies: [
          "**Always bet Banker**: 1.06% house edge (best bet in the game!)",
          "**Never bet Tie**: 14.4% house edge - terrible odds",
          "**Flat Betting**: Same bet size every hand",
          "**1-3-2-4 System**: Bet 1, 3, 2, 4 units. Reset after loss or completing sequence.",
        ],
        tips: [
          "Banker bet wins ~51% of the time (that's why there's commission)",
          "No skill involved - it's pure luck",
          "Scorecards/patterns are meaningless - each hand is independent",
          "One of the simplest and best-odds casino games",
        ],
        rtp: "Banker: 98.94% | Player: 98.76% | Tie: 85.6%",
      },
      
      crash: {
        name: "Crash Games (General)",
        type: "Crash Game",
        description: "Multiplier rises until it crashes - cash out in time!",
        strategies: [
          "**Conservative**: Auto cash-out at 1.2x-1.5x for steady small wins",
          "**Balanced**: Target 2x, accept some losses for bigger wins",
          "**Aggressive**: Go for 5x+ but expect many losses",
          "**Split Strategy**: Two bets - one safe (1.5x), one risky (5x+)",
        ],
        tips: [
          "The crash point is random - patterns don't predict future rounds",
          "Set strict loss limits before playing",
          "Auto cash-out removes emotional decisions",
          "Don't chase losses with bigger bets",
        ],
        rtp: "Usually 96-97%",
      },
      
      live_dealer: {
        name: "Live Dealer Games",
        type: "Live Casino",
        description: "Real dealers streaming in real-time!",
        strategies: [
          "Use the same strategies as regular table games",
          "**Live Blackjack**: Basic strategy still applies",
          "**Live Roulette**: European tables have better odds",
          "**Live Baccarat**: Still bet Banker!",
        ],
        tips: [
          "Games are slower - good for bankroll management",
          "Chat with dealers but stay focused on your bets",
          "Check for live casino bonuses",
          "Internet connection matters - don't play on weak WiFi",
        ],
        rtp: "Same as regular versions",
      },
    };

    // ============================================
    // üìä ADVANCED BET MARKET PREDICTIONS
    // ============================================
    
    const BET_MARKET_DATA = {
      // Average statistics by league (based on historical data)
      corners: {
        'eng.1': { avgPerMatch: 10.2, homeAvg: 5.4, awayAvg: 4.8, over95: 65, over105: 48, over115: 32 },
        'esp.1': { avgPerMatch: 9.8, homeAvg: 5.2, awayAvg: 4.6, over95: 62, over105: 45, over115: 28 },
        'ger.1': { avgPerMatch: 10.5, homeAvg: 5.6, awayAvg: 4.9, over95: 68, over105: 52, over115: 35 },
        'ita.1': { avgPerMatch: 10.8, homeAvg: 5.7, awayAvg: 5.1, over95: 70, over105: 54, over115: 38 },
        'fra.1': { avgPerMatch: 9.5, homeAvg: 5.0, awayAvg: 4.5, over95: 58, over105: 42, over115: 26 },
        'default': { avgPerMatch: 10.0, homeAvg: 5.3, awayAvg: 4.7, over95: 63, over105: 47, over115: 30 },
      },
      cards: {
        'eng.1': { yellowAvg: 3.2, redChance: 8, totalCardsAvg: 3.4, over25: 62, over35: 38, over45: 18 },
        'esp.1': { yellowAvg: 4.5, redChance: 12, totalCardsAvg: 4.8, over25: 78, over35: 55, over45: 32 },
        'ger.1': { yellowAvg: 3.8, redChance: 9, totalCardsAvg: 4.0, over25: 70, over35: 45, over45: 22 },
        'ita.1': { yellowAvg: 4.2, redChance: 11, totalCardsAvg: 4.5, over25: 75, over35: 52, over45: 28 },
        'fra.1': { yellowAvg: 3.5, redChance: 10, totalCardsAvg: 3.7, over25: 65, over35: 42, over45: 20 },
        'default': { yellowAvg: 3.8, redChance: 10, totalCardsAvg: 4.0, over25: 70, over35: 46, over45: 24 },
      },
      goals: {
        'eng.1': { avgPerMatch: 2.85, bttsYes: 52, over15: 78, over25: 55, over35: 28, cleanSheet: 25 },
        'esp.1': { avgPerMatch: 2.65, bttsYes: 48, over15: 75, over25: 50, over35: 24, cleanSheet: 28 },
        'ger.1': { avgPerMatch: 3.15, bttsYes: 55, over15: 82, over25: 62, over35: 35, cleanSheet: 22 },
        'ita.1': { avgPerMatch: 2.55, bttsYes: 45, over15: 72, over25: 48, over35: 22, cleanSheet: 30 },
        'fra.1': { avgPerMatch: 2.70, bttsYes: 50, over15: 76, over25: 52, over35: 26, cleanSheet: 26 },
        'nba': { avgPerGame: 224.5, over220: 52, over230: 35, under215: 38 },
        'nfl': { avgPerGame: 46.5, over45: 48, over50: 32, under42: 40 },
        'default': { avgPerMatch: 2.75, bttsYes: 50, over15: 76, over25: 52, over35: 26, cleanSheet: 26 },
      },
      fouls: {
        'eng.1': { avgPerMatch: 22, homeAvg: 10, awayAvg: 12 },
        'esp.1': { avgPerMatch: 26, homeAvg: 12, awayAvg: 14 },
        'ita.1': { avgPerMatch: 28, homeAvg: 13, awayAvg: 15 },
        'default': { avgPerMatch: 24, homeAvg: 11, awayAvg: 13 },
      },
      shots: {
        'eng.1': { avgOnTarget: 10.5, homeAvg: 5.8, awayAvg: 4.7 },
        'esp.1': { avgOnTarget: 9.8, homeAvg: 5.5, awayAvg: 4.3 },
        'default': { avgOnTarget: 10.0, homeAvg: 5.5, awayAvg: 4.5 },
      },
    };

    // Function to get bet market predictions
    function getBetMarketPrediction(marketType, league = 'default', homeTeam = null, awayTeam = null) {
      const leagueKey = BET_MARKET_DATA[marketType]?.[league] ? league : 'default';
      const data = BET_MARKET_DATA[marketType]?.[leagueKey];
      
      if (!data) return null;
      
      return {
        market: marketType,
        league: leagueKey,
        stats: data,
        homeTeam,
        awayTeam,
      };
    }

    // Format bet market response with clickable options
    function formatBetMarketResponse(marketType, league, homeTeam, awayTeam) {
      const prediction = getBetMarketPrediction(marketType, league, homeTeam, awayTeam);
      if (!prediction) return null;
      
      const { stats } = prediction;
      let response = '';
      let quickActions = [];
      
      switch (marketType) {
        case 'corners':
          response = `‚öΩ **Corner Kick Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += `üìä **League Average**: ${stats.avgPerMatch} corners per match\n`;
          response += `üè† Home team avg: ${stats.homeAvg} corners\n`;
          response += `‚úàÔ∏è Away team avg: ${stats.awayAvg} corners\n\n`;
          response += `**Probability Estimates**:\n`;
          response += `‚Ä¢ Over 9.5 corners: ${stats.over95}% likely\n`;
          response += `‚Ä¢ Over 10.5 corners: ${stats.over105}% likely\n`;
          response += `‚Ä¢ Over 11.5 corners: ${stats.over115}% likely\n\n`;
          response += `üí° **Tip**: High-pressing teams like Liverpool & Man City average 6+ corners per game.\n`;
          quickActions = [
            { text: 'üìä Goals predictions', action: 'goals predictions for this match' },
            { text: 'üü® Cards predictions', action: 'cards predictions for this match' },
            { text: '‚öΩ Other matches', action: 'show me other matches today' },
            { text: 'üéØ Best corner bets', action: 'which matches have most corners today' },
          ];
          break;
          
        case 'cards':
          response = `üü® **Cards Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += `üìä **League Averages**:\n`;
          response += `‚Ä¢ Yellow cards: ${stats.yellowAvg} per match\n`;
          response += `‚Ä¢ Red card chance: ${stats.redChance}%\n`;
          response += `‚Ä¢ Total cards: ${stats.totalCardsAvg} per match\n\n`;
          response += `**Probability Estimates**:\n`;
          response += `‚Ä¢ Over 2.5 cards: ${stats.over25}% likely\n`;
          response += `‚Ä¢ Over 3.5 cards: ${stats.over35}% likely\n`;
          response += `‚Ä¢ Over 4.5 cards: ${stats.over45}% likely\n\n`;
          response += `üí° **Tip**: Derbies and relegation battles have 40% more cards on average!\n`;
          quickActions = [
            { text: '‚öΩ Goals predictions', action: 'goals predictions for this match' },
            { text: 'üìê Corner predictions', action: 'corner predictions for this match' },
            { text: 'üî¥ Red card stats', action: 'which teams get most red cards' },
            { text: '‚ö° Live matches', action: 'show live matches' },
          ];
          break;
          
        case 'goals':
          response = `‚öΩ **Goals Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += `üìä **League Averages**:\n`;
          response += `‚Ä¢ Goals per match: ${stats.avgPerMatch}\n`;
          response += `‚Ä¢ Both Teams Score: ${stats.bttsYes}% of matches\n`;
          response += `‚Ä¢ Clean sheet chance: ${stats.cleanSheet}%\n\n`;
          response += `**Probability Estimates**:\n`;
          response += `‚Ä¢ Over 1.5 goals: ${stats.over15}% likely\n`;
          response += `‚Ä¢ Over 2.5 goals: ${stats.over25}% likely\n`;
          response += `‚Ä¢ Over 3.5 goals: ${stats.over35}% likely\n\n`;
          response += `üí° **Tip**: First 15 mins and last 15 mins see 35% of all goals!\n`;
          quickActions = [
            { text: 'üìê Corner predictions', action: 'corner predictions for this match' },
            { text: 'üü® Cards predictions', action: 'cards predictions for this match' },
            { text: 'üéØ BTTS tips', action: 'best both teams to score bets today' },
            { text: 'üìà High scoring matches', action: 'which matches will have most goals' },
          ];
          break;
          
        case 'shots':
          response = `üéØ **Shots Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += `üìä **League Averages**:\n`;
          response += `‚Ä¢ Shots on target: ${stats.avgOnTarget} per match\n`;
          response += `‚Ä¢ Home team avg: ${stats.homeAvg} shots on target\n`;
          response += `‚Ä¢ Away team avg: ${stats.awayAvg} shots on target\n\n`;
          response += `üí° **Tip**: Teams chasing goals in 2nd half average 60% more shots!\n`;
          quickActions = [
            { text: '‚öΩ Goals predictions', action: 'goals predictions' },
            { text: 'üìê Corner predictions', action: 'corner predictions' },
            { text: 'üî• Top attacking teams', action: 'teams with most shots on target' },
            { text: 'üèÜ League stats', action: 'show league statistics' },
          ];
          break;
          
        case 'fouls':
          response = `‚ö†Ô∏è **Fouls Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += `üìä **League Averages**:\n`;
          response += `‚Ä¢ Total fouls: ${stats.avgPerMatch} per match\n`;
          response += `‚Ä¢ Home team avg: ${stats.homeAvg} fouls\n`;
          response += `‚Ä¢ Away team avg: ${stats.awayAvg} fouls\n\n`;
          response += `üí° **Tip**: Away teams commit ~20% more fouls on average!\n`;
          quickActions = [
            { text: 'üü® Cards predictions', action: 'cards predictions' },
            { text: '‚öΩ Other markets', action: 'show all betting markets' },
            { text: 'üìä Team fouls stats', action: 'which teams commit most fouls' },
            { text: 'üéØ Recommended bets', action: 'give me betting recommendations' },
          ];
          break;
      }
      
      return { response, quickActions };
    }

    // ============================================
    // üé∞ CASINO SESSION TRACKING & RECOMMENDATIONS
    // ============================================
    
    let casinoSession = {
      startTime: null,
      currentGame: null,
      gamesPlayed: [],
      totalWins: 0,
      totalLosses: 0,
      totalSpent: 0,
      totalWon: 0,
    };

    // Simulated casino game data (would come from platform in production)
    const CASINO_GAMES_DATA = {
      games: [
        { id: 'aviator', name: 'Aviator', type: 'crash', rtp: 97, popularity: 95, currentPlayers: 234, recentWins: 12, jackpot: null },
        { id: 'starburst', name: 'Starburst', type: 'slot', rtp: 96.1, popularity: 88, currentPlayers: 156, recentWins: 8, jackpot: null },
        { id: 'book_of_dead', name: 'Book of Dead', type: 'slot', rtp: 96.2, popularity: 82, currentPlayers: 89, recentWins: 5, jackpot: null },
        { id: 'gonzo_quest', name: "Gonzo's Quest", type: 'slot', rtp: 95.9, popularity: 78, currentPlayers: 67, recentWins: 4, jackpot: null },
        { id: 'mega_moolah', name: 'Mega Moolah', type: 'slot', rtp: 88.1, popularity: 70, currentPlayers: 45, recentWins: 1, jackpot: 2500000 },
        { id: 'lightning_roulette', name: 'Lightning Roulette', type: 'live', rtp: 97.3, popularity: 85, currentPlayers: 178, recentWins: 15, jackpot: null },
        { id: 'blackjack_live', name: 'Live Blackjack', type: 'live', rtp: 99.5, popularity: 80, currentPlayers: 123, recentWins: 20, jackpot: null },
        { id: 'crazy_time', name: 'Crazy Time', type: 'live', rtp: 96.0, popularity: 92, currentPlayers: 289, recentWins: 18, jackpot: null },
        { id: 'sweet_bonanza', name: 'Sweet Bonanza', type: 'slot', rtp: 96.5, popularity: 86, currentPlayers: 134, recentWins: 9, jackpot: null },
        { id: 'gates_of_olympus', name: 'Gates of Olympus', type: 'slot', rtp: 96.5, popularity: 84, currentPlayers: 112, recentWins: 7, jackpot: null },
        { id: 'spaceman', name: 'Spaceman', type: 'crash', rtp: 96, popularity: 75, currentPlayers: 56, recentWins: 6, jackpot: null },
        { id: 'plinko', name: 'Plinko', type: 'instant', rtp: 97, popularity: 72, currentPlayers: 34, recentWins: 11, jackpot: null },
      ],
    };

    // Start casino session tracking
    function startCasinoSession(gameName) {
      if (!casinoSession.startTime) {
        casinoSession.startTime = Date.now();
      }
      casinoSession.currentGame = gameName;
      if (!casinoSession.gamesPlayed.includes(gameName)) {
        casinoSession.gamesPlayed.push(gameName);
      }
    }

    // Get session duration in minutes
    function getSessionDuration() {
      if (!casinoSession.startTime) return 0;
      return Math.floor((Date.now() - casinoSession.startTime) / 60000);
    }

    // Get casino recommendations based on user behavior
    function getCasinoRecommendations(context = {}) {
      const { 
        currentGame = null,
        sessionMinutes = getSessionDuration(),
        winRate = casinoSession.totalWins / (casinoSession.totalWins + casinoSession.totalLosses + 1),
        gamesPlayed = casinoSession.gamesPlayed,
      } = context;

      const recommendations = [];
      const games = CASINO_GAMES_DATA.games;
      
      // Find games user hasn't played
      const unplayedGames = games.filter(g => !gamesPlayed.includes(g.name));
      
      // Recommendation 1: Long session - suggest a break or change
      if (sessionMinutes >= 20) {
        const differentTypeGames = games.filter(g => {
          const currentGameData = games.find(cg => cg.name === currentGame);
          return currentGameData && g.type !== currentGameData.type && !gamesPlayed.includes(g.name);
        });
        if (differentTypeGames.length > 0) {
          const suggested = differentTypeGames.sort((a, b) => b.popularity - a.popularity)[0];
          recommendations.push({
            type: 'session_change',
            reason: `You've been playing for ${sessionMinutes} minutes`,
            game: suggested,
            message: `üéÆ **${suggested.name}** has ${suggested.currentPlayers} players online right now!`,
          });
        }
      }
      
      // Recommendation 2: Low win rate - suggest higher RTP game
      if (winRate < 0.3 && (casinoSession.totalWins + casinoSession.totalLosses) >= 5) {
        const highRtpGames = games.filter(g => g.rtp >= 96.5 && g.name !== currentGame);
        if (highRtpGames.length > 0) {
          const suggested = highRtpGames.sort((a, b) => b.rtp - a.rtp)[0];
          recommendations.push({
            type: 'better_odds',
            reason: 'Looking for a change of luck?',
            game: suggested,
            message: `üçÄ **${suggested.name}** has ${suggested.rtp}% RTP - great odds!`,
          });
        }
      }
      
      // Recommendation 3: Popular games - join the fun
      const popularGames = games
        .filter(g => g.name !== currentGame && g.currentPlayers > 100)
        .sort((a, b) => b.currentPlayers - a.currentPlayers);
      if (popularGames.length > 0) {
        recommendations.push({
          type: 'popular',
          reason: 'Join the action!',
          game: popularGames[0],
          message: `üî• **${popularGames[0].name}** - ${popularGames[0].currentPlayers} players online, ${popularGames[0].recentWins} wins in the last hour!`,
        });
      }
      
      // Recommendation 4: Recent wins on another game
      const hotGames = games
        .filter(g => g.name !== currentGame && g.recentWins >= 8)
        .sort((a, b) => b.recentWins - a.recentWins);
      if (hotGames.length > 0) {
        recommendations.push({
          type: 'hot_game',
          reason: 'Games paying out right now',
          game: hotGames[0],
          message: `üí∞ **${hotGames[0].name}** - ${hotGames[0].recentWins} wins in the last hour!`,
        });
      }
      
      // Recommendation 5: Low activity game - potential bigger wins
      const quietGames = games
        .filter(g => g.name !== currentGame && g.currentPlayers < 50 && g.rtp >= 95)
        .sort((a, b) => a.currentPlayers - b.currentPlayers);
      if (quietGames.length > 0) {
        recommendations.push({
          type: 'quiet_game',
          reason: 'Less competition',
          game: quietGames[0],
          message: `ü§´ **${quietGames[0].name}** - Only ${quietGames[0].currentPlayers} players, could be your moment!`,
        });
      }
      
      // Recommendation 6: Jackpot games
      const jackpotGames = games.filter(g => g.jackpot && g.jackpot > 1000000 && g.name !== currentGame);
      if (jackpotGames.length > 0) {
        const jp = jackpotGames[0];
        recommendations.push({
          type: 'jackpot',
          reason: 'Life-changing win potential',
          game: jp,
          message: `üèÜ **${jp.name}** - ZMW ${(jp.jackpot).toLocaleString()} jackpot waiting!`,
        });
      }
      
      // Recommendation 7: Try something new
      if (unplayedGames.length > 0 && gamesPlayed.length >= 1) {
        const newGame = unplayedGames.sort((a, b) => b.popularity - a.popularity)[0];
        recommendations.push({
          type: 'try_new',
          reason: 'Expand your horizons',
          game: newGame,
          message: `‚ú® **${newGame.name}** - Popular game you haven't tried yet!`,
        });
      }
      
      return recommendations.slice(0, 4); // Return max 4 recommendations
    }

    // Format casino recommendations with clickable options
    function formatCasinoRecommendations(currentGame = null) {
      const recs = getCasinoRecommendations({ currentGame });
      
      let response = "üé∞ **Games You Might Enjoy**:\n\n";
      
      recs.forEach((rec, i) => {
        response += `${rec.message}\n`;
      });
      
      const quickActions = recs.map(rec => ({
        text: `üéÆ ${rec.game.name}`,
        action: `tell me about ${rec.game.name}`,
      }));
      
      // Add some standard actions
      quickActions.push({ text: 'üéØ Casino strategies', action: 'casino strategies' });
      
      return { response, quickActions: quickActions.slice(0, 4) };
    }

    // ============================================
    // üîò CLICKABLE QUICK ACTIONS SYSTEM
    // ============================================
    
    // Generate quick action buttons HTML
    function generateQuickActionsHTML(actions) {
      if (!actions || actions.length === 0) return '';
      
      let html = '<div class="quick-actions-container">';
      actions.forEach(action => {
        html += `<button class="quick-action" onclick="handleQuickAction('${action.action.replace(/'/g, "\\'")}')">${action.text}</button>`;
      });
      html += '</div>';
      return html;
    }

    // Handle quick action click
    function handleQuickAction(action) {
      document.getElementById('messageInput').value = action;
      sendMessage();
    }

    // Detect the topic from user message to provide relevant quick actions
    function detectMessageTopic(message) {
      const msg = message.toLowerCase().trim();
      
      // Casino-specific keywords (high confidence)
      const casinoKeywords = ['casino', 'slot', 'slots', 'roulette', 'blackjack', 'poker', 'baccarat', 'aviator', 'crash game', 'live dealer', 'jackpot', 'spin', 'rtp', 'crazy time', 'lightning', 'starburst', 'book of dead', 'sweet bonanza', 'spaceman', 'plinko', 'mega moolah'];
      
      // Sports-specific keywords (high confidence)
      const sportsKeywords = ['match', 'team', 'league', 'premier league', 'la liga', 'serie a', 'bundesliga', 'champions league', 'nba', 'nfl', 'mlb', 'nhl', 'soccer', 'football match', 'basketball', 'tennis', 'golf', 'ufc', 'boxing', 'f1', 'formula', 'racing', 'cricket', 'rugby', 'corner', 'corners', 'goals', 'btts', 'both teams', 'score', 'standings', 'fixture', 'liverpool', 'manchester', 'arsenal', 'chelsea', 'barcelona', 'real madrid', 'lakers', 'celtics', 'warriors'];
      
      // Strategy-related keywords
      const strategyKeywords = ['strategy', 'strategies', 'how to win', 'tips', 'advice', 'bankroll', 'martingale', 'system'];
      
      // Help/general keywords
      const helpKeywords = ['help', 'what can you', 'how do i', 'explain', 'what is'];
      
      // Count matches for each category
      let casinoScore = 0;
      let sportsScore = 0;
      let strategyScore = 0;
      let helpScore = 0;
      
      casinoKeywords.forEach(k => { if (msg.includes(k)) casinoScore++; });
      sportsKeywords.forEach(k => { if (msg.includes(k)) sportsScore++; });
      strategyKeywords.forEach(k => { if (msg.includes(k)) strategyScore++; });
      helpKeywords.forEach(k => { if (msg.includes(k)) helpScore++; });
      
      // Special case: if asking about casino strategy
      if (strategyScore > 0 && casinoScore > 0) return 'strategy';
      
      // Determine the highest scoring topic
      const scores = [
        { topic: 'casino', score: casinoScore },
        { topic: 'sports', score: sportsScore },
        { topic: 'strategy', score: strategyScore },
        { topic: 'help', score: helpScore },
      ];
      
      scores.sort((a, b) => b.score - a.score);
      
      // If no clear winner or all zero, return greeting (balanced options)
      if (scores[0].score === 0) return 'greeting';
      
      return scores[0].topic;
    }

    // Get contextual quick actions based on conversation
    function getContextualQuickActions(topic, context = {}) {
      const actions = {
        greeting: [
          { text: '‚öΩ EPL tips today', action: 'give me EPL tips for today' },
          { text: 'üé∞ Casino games', action: 'show me casino games' },
          { text: 'üìä My betting stats', action: 'show my betting statistics' },
          { text: 'üéÅ My bonuses', action: 'what bonuses do I have' },
        ],
        sports: [
          { text: 'üìê Corner bets', action: 'show me corner betting options' },
          { text: 'üü® Card bets', action: 'show me cards betting options' },
          { text: '‚öΩ Goals/BTTS', action: 'show me goals and BTTS options' },
          { text: 'üéØ More bet types', action: 'what other bet types are available' },
        ],
        casino: [
          { text: 'üéÆ Popular games', action: 'show popular casino games' },
          { text: 'üìà High RTP games', action: 'show highest RTP games' },
          { text: 'üéØ Game strategies', action: 'casino game strategies' },
          { text: 'üî• Hot games now', action: 'which games are hot right now' },
        ],
        match_analysis: [
          { text: 'üìê Corners', action: 'corner predictions for this match' },
          { text: 'üü® Cards', action: 'cards predictions for this match' },
          { text: '‚öΩ Goals/BTTS', action: 'goals and BTTS predictions' },
          { text: 'üîÑ Double Chance', action: 'double chance options for this match' },
        ],
        strategy: [
          { text: 'üé∞ Slots strategy', action: 'slots strategy' },
          { text: 'üÉè Blackjack tips', action: 'blackjack strategy' },
          { text: '‚úàÔ∏è Aviator tactics', action: 'aviator strategy' },
          { text: '‚öΩ Betting systems', action: 'sports betting strategies' },
        ],
        help: [
          { text: '‚öΩ Sports betting', action: 'help with sports betting' },
          { text: 'üé∞ Casino games', action: 'help with casino games' },
          { text: 'üìä Bet types explained', action: 'explain different bet types' },
          { text: 'üí∞ Bankroll tips', action: 'bankroll management advice' },
        ],
        bet_markets: [
          { text: 'üéØ Match Result', action: 'explain match result bets' },
          { text: 'üîÑ Double Chance', action: 'explain double chance bets' },
          { text: 'üìê Corners', action: 'explain corner bets' },
          { text: 'üü® Cards', action: 'explain card bets' },
        ],
      };
      
      return actions[topic] || actions.greeting;
    }

    // Get strategy for a specific game
    function getCasinoStrategy(game) {
      const gameKey = game.toLowerCase().replace(/\s+/g, '_');
      
      // Find matching strategy
      for (const [key, data] of Object.entries(CASINO_STRATEGIES)) {
        if (key === gameKey || data.name.toLowerCase() === game.toLowerCase()) {
          return data;
        }
      }
      
      // Fuzzy match
      for (const [key, data] of Object.entries(CASINO_STRATEGIES)) {
        if (game.toLowerCase().includes(key) || key.includes(game.toLowerCase())) {
          return data;
        }
      }
      
      return null;
    }

    // Format strategy response with quick actions
    function formatStrategyResponse(strategy) {
      let response = `üé∞ **${strategy.name}** (${strategy.type})\n\n`;
      response += `${strategy.description}\n\n`;
      response += `üìä **RTP**: ${strategy.rtp}\n\n`;
      response += `**Strategies**:\n`;
      strategy.strategies.forEach(s => {
        response += `${s}\n`;
      });
      response += `\n**Pro Tips**:\n`;
      strategy.tips.forEach(t => {
        response += `‚Ä¢ ${t}\n`;
      });
      response += `\n‚ö†Ô∏è Remember Bwana - no strategy guarantees wins. Gamble responsibly! üôè`;
      return response;
    }

    // Enhanced getInstantResponse - returns { response, quickActions } or null
    function getInstantResponse(message) {
      const msg = message.toLowerCase().trim();
      let response = null;
      let quickActions = [];
      
      // ============================================
      // BET MARKET PREDICTIONS (Corners, Cards, Goals, etc.)
      // ============================================
      
      // Corner predictions
      if (msg.includes('corner') && (msg.includes('predict') || msg.includes('how many') || msg.includes('over') || msg.includes('under') || msg.includes('tip'))) {
        const result = formatBetMarketResponse('corners', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Cards predictions
      if ((msg.includes('card') || msg.includes('yellow') || msg.includes('red card') || msg.includes('booking')) && 
          (msg.includes('predict') || msg.includes('how many') || msg.includes('over') || msg.includes('tip'))) {
        const result = formatBetMarketResponse('cards', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Goals predictions
      if ((msg.includes('goal') || msg.includes('btts') || msg.includes('both teams') || msg.includes('over 2.5') || msg.includes('over 1.5')) && 
          (msg.includes('predict') || msg.includes('how many') || msg.includes('tip') || msg.includes('score'))) {
        const result = formatBetMarketResponse('goals', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Shots predictions
      if (msg.includes('shot') && (msg.includes('predict') || msg.includes('how many') || msg.includes('target'))) {
        const result = formatBetMarketResponse('shots', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Fouls predictions
      if (msg.includes('foul') && (msg.includes('predict') || msg.includes('how many'))) {
        const result = formatBetMarketResponse('fouls', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // All betting markets
      if (msg.includes('betting market') || msg.includes('all market') || msg.includes('what bets') || msg.includes('types of bet') || msg.includes('bet types') || msg.includes('other bet')) {
        response = "‚öΩ **All Betting Markets**, Bwana!\n\n" +
                   "**1Ô∏è‚É£ Match Result (1X2)**:\n‚Ä¢ Pick winner or draw - most popular!\n\n" +
                   "**2Ô∏è‚É£ Double Chance**:\n‚Ä¢ Safer option: Home/Draw, Away/Draw, or Home/Away\n\n" +
                   "**3Ô∏è‚É£ Goals Markets**:\n‚Ä¢ Over/Under 1.5, 2.5, 3.5 goals\n‚Ä¢ Both Teams to Score (BTTS) - Yes/No\n‚Ä¢ Correct Score, First/Last Goalscorer\n\n" +
                   "**4Ô∏è‚É£ Corners**:\n‚Ä¢ Over/Under 8.5, 9.5, 10.5 corners\n‚Ä¢ Team corners, First corner winner\n\n" +
                   "**5Ô∏è‚É£ Cards**:\n‚Ä¢ Over/Under 2.5, 3.5 cards\n‚Ä¢ Player to be booked, Red card in match\n\n" +
                   "**6Ô∏è‚É£ Specials**:\n‚Ä¢ Handicap, Half-time/Full-time\n‚Ä¢ Clean Sheet, Win to Nil\n\n" +
                   "Which market interests you? I'll give you predictions! üéØ";
        quickActions = [
          { text: 'üéØ Match Result tips', action: 'give me match result predictions' },
          { text: 'üîÑ Double Chance tips', action: 'give me double chance predictions' },
          { text: '‚öΩ Goals/BTTS tips', action: 'give me goals and BTTS predictions' },
          { text: 'üìê Corners tips', action: 'give me corner predictions' },
        ];
        return { response, quickActions };
      }
      
      // Explain specific bet types
      if (msg.includes('explain') && (msg.includes('double chance') || msg.includes('1x2') || msg.includes('match result'))) {
        response = "üîÑ **Double Chance Explained**, Bwana!\n\n" +
                   "Double Chance covers 2 of 3 outcomes:\n\n" +
                   "‚Ä¢ **1X** = Home Win OR Draw (you win if home doesn't lose)\n" +
                   "‚Ä¢ **X2** = Draw OR Away Win (you win if away doesn't lose)\n" +
                   "‚Ä¢ **12** = Home OR Away Win (you win if there's no draw)\n\n" +
                   "**Why use it?**\n" +
                   "‚úÖ Lower odds but much safer\n" +
                   "‚úÖ Great for tight matches\n" +
                   "‚úÖ Perfect for favorites who might draw\n\n" +
                   "Example: Liverpool vs Newcastle\n" +
                   "‚Ä¢ Liverpool to win: 1.45\n" +
                   "‚Ä¢ Liverpool or Draw (1X): 1.15 - much safer!\n\n" +
                   "Want me to find some good Double Chance bets? üéØ";
        quickActions = [
          { text: 'üîÑ Find DC bets', action: 'find good double chance bets today' },
          { text: '‚öΩ Other markets', action: 'explain other bet types' },
          { text: 'üìê Corners', action: 'explain corner bets' },
          { text: 'üü® Cards', action: 'explain card bets' },
        ];
        return { response, quickActions };
      }
      
      // Explain corner bets
      if (msg.includes('explain') && msg.includes('corner')) {
        response = "üìê **Corner Bets Explained**, Bwana!\n\n" +
                   "**Popular Corner Markets**:\n\n" +
                   "‚Ä¢ **Over/Under 9.5** - Most common line\n" +
                   "‚Ä¢ **Over/Under 10.5** - Higher risk, better odds\n" +
                   "‚Ä¢ **Team Corners** - Which team gets more\n" +
                   "‚Ä¢ **First Corner** - Who wins the first\n\n" +
                   "**What affects corners?**\n" +
                   "‚úÖ Attacking teams = more corners\n" +
                   "‚úÖ Derbies/big matches = more action\n" +
                   "‚úÖ Teams chasing goals = late corners\n\n" +
                   "**League Averages**:\n" +
                   "‚Ä¢ Premier League: ~10.2 corners/match\n" +
                   "‚Ä¢ La Liga: ~9.8 corners/match\n" +
                   "‚Ä¢ Bundesliga: ~10.5 corners/match\n\n" +
                   "Want corner predictions for today? üéØ";
        quickActions = [
          { text: 'üìê Corner tips', action: 'give me corner predictions for today' },
          { text: '‚öΩ Goals tips', action: 'explain goals bets' },
          { text: 'üü® Cards tips', action: 'explain card bets' },
          { text: 'üîÑ Double Chance', action: 'explain double chance' },
        ];
        return { response, quickActions };
      }
      
      // Explain card bets
      if (msg.includes('explain') && (msg.includes('card') || msg.includes('booking') || msg.includes('yellow') || msg.includes('red'))) {
        response = "üü® **Card Bets Explained**, Bwana!\n\n" +
                   "**Popular Card Markets**:\n\n" +
                   "‚Ä¢ **Over/Under 3.5 cards** - Total match cards\n" +
                   "‚Ä¢ **Over/Under 4.5 cards** - For fiery matches\n" +
                   "‚Ä¢ **Player to be booked** - Specific player card\n" +
                   "‚Ä¢ **Red card in match** - Usually ~10% chance\n\n" +
                   "**What causes more cards?**\n" +
                   "‚úÖ Derbies & rivalries\n" +
                   "‚úÖ Relegation battles\n" +
                   "‚úÖ Strict referees (check who's officiating!)\n" +
                   "‚úÖ La Liga/Serie A have more cards than EPL\n\n" +
                   "**League Averages**:\n" +
                   "‚Ä¢ Premier League: ~3.2 yellows/match\n" +
                   "‚Ä¢ La Liga: ~4.5 yellows/match\n" +
                   "‚Ä¢ Serie A: ~4.2 yellows/match\n\n" +
                   "Want card predictions for today? üéØ";
        quickActions = [
          { text: 'üü® Card tips', action: 'give me card predictions for today' },
          { text: 'üìê Corners', action: 'explain corner bets' },
          { text: '‚öΩ Goals/BTTS', action: 'explain goals and BTTS' },
          { text: 'üéØ All markets', action: 'show all betting markets' },
        ];
        return { response, quickActions };
      }
      
      // ============================================
      // CASINO GAME RECOMMENDATIONS
      // ============================================
      
      // Popular games request
      if (msg.includes('popular') && (msg.includes('game') || msg.includes('casino'))) {
        startCasinoSession('browsing');
        const games = CASINO_GAMES_DATA.games.sort((a, b) => b.currentPlayers - a.currentPlayers).slice(0, 5);
        response = "üî• **Most Popular Games Right Now**:\n\n";
        games.forEach((g, i) => {
          response += `${i + 1}. **${g.name}** - ${g.currentPlayers} players online\n`;
        });
        response += "\nJoin the action, Bwana! üéÆ";
        quickActions = games.slice(0, 3).map(g => ({ text: `üéÆ ${g.name}`, action: `tell me about ${g.name}` }));
        quickActions.push({ text: 'üìà High RTP games', action: 'highest RTP games' });
        return { response, quickActions };
      }
      
      // High RTP games
      if (msg.includes('high') && msg.includes('rtp') || msg.includes('best odds') && msg.includes('casino')) {
        const games = CASINO_GAMES_DATA.games.sort((a, b) => b.rtp - a.rtp).slice(0, 5);
        response = "üìà **Highest RTP Casino Games**:\n\n";
        games.forEach((g, i) => {
          response += `${i + 1}. **${g.name}** - ${g.rtp}% RTP\n`;
        });
        response += "\nüí° Higher RTP = Better long-term odds, Bwana!";
        quickActions = games.slice(0, 3).map(g => ({ text: `üéÆ ${g.name}`, action: `tell me about ${g.name}` }));
        quickActions.push({ text: 'üî• Hot games now', action: 'which games are paying out' });
        return { response, quickActions };
      }
      
      // Hot games / games paying out
      if ((msg.includes('hot') || msg.includes('paying') || msg.includes('winning')) && msg.includes('game')) {
        const games = CASINO_GAMES_DATA.games.sort((a, b) => b.recentWins - a.recentWins).slice(0, 5);
        response = "üí∞ **Games Paying Out Right Now**:\n\n";
        games.forEach((g, i) => {
          response += `${i + 1}. **${g.name}** - ${g.recentWins} wins in the last hour!\n`;
        });
        response += "\nüçÄ Lady luck might be waiting, Bwana!";
        quickActions = games.slice(0, 3).map(g => ({ text: `üéÆ ${g.name}`, action: `${g.name} strategy` }));
        quickActions.push({ text: 'üé∞ All casino games', action: 'show all casino games' });
        return { response, quickActions };
      }
      
      // Casino game recommendations based on session
      if (msg.includes('recommend') && (msg.includes('game') || msg.includes('casino')) || msg.includes('what should i play')) {
        const result = formatCasinoRecommendations(casinoSession.currentGame);
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Specific game info
      for (const game of CASINO_GAMES_DATA.games) {
        if (msg.includes(game.name.toLowerCase()) && (msg.includes('tell') || msg.includes('about') || msg.includes('info'))) {
          startCasinoSession(game.name);
          response = `üéÆ **${game.name}**\n\n`;
          response += `üìä **RTP**: ${game.rtp}%\n`;
          response += `üë• **Players Online**: ${game.currentPlayers}\n`;
          response += `üèÜ **Recent Wins**: ${game.recentWins} in the last hour\n`;
          response += `üìÅ **Type**: ${game.type.charAt(0).toUpperCase() + game.type.slice(1)}\n`;
          if (game.jackpot) {
            response += `üí∞ **Jackpot**: ZMW ${game.jackpot.toLocaleString()}\n`;
          }
          response += `\nWant to learn the strategy? üéØ`;
          
          // Find similar games
          const similarGames = CASINO_GAMES_DATA.games
            .filter(g => g.type === game.type && g.id !== game.id)
            .slice(0, 2);
          
          quickActions = [
            { text: `üìñ ${game.name} strategy`, action: `${game.name} strategy` },
          ];
          similarGames.forEach(g => {
            quickActions.push({ text: `üéÆ Try ${g.name}`, action: `tell me about ${g.name}` });
          });
          quickActions.push({ text: 'üî• Hot games', action: 'which games are hot right now' });
          return { response, quickActions };
        }
      }
      
      // ============================================
      // CASINO STRATEGY REQUESTS - INSTANT
      // ============================================
      
      const strategyKeywords = ['strategy', 'strategies', 'how to play', 'how do i play', 'tips for', 'how to win', 'best way to play'];
      const isStrategyRequest = strategyKeywords.some(k => msg.includes(k));
      const casinoGames = ['aviator', 'blackjack', 'roulette', 'slots', 'slot', 'poker', 'baccarat', 'crash', 'live dealer', 'live casino'];
      
      if (isStrategyRequest) {
        for (const game of casinoGames) {
          if (msg.includes(game)) {
            const strategy = getCasinoStrategy(game);
            if (strategy) {
              response = formatStrategyResponse(strategy);
              quickActions = [
                { text: 'üéÆ Popular games', action: 'show popular casino games' },
                { text: 'üìà High RTP games', action: 'highest RTP games' },
                { text: 'üî• Hot games now', action: 'which games are paying out' },
                { text: 'üé∞ Other strategies', action: 'casino strategies' },
              ];
              return { response, quickActions };
            }
          }
        }
        // General strategy request
        response = "Hey Bwana! üé∞ I've got strategies for:\n\n" +
               "‚úàÔ∏è **Aviator** - Crash game tactics\n" +
               "üÉè **Blackjack** - Basic strategy & tips\n" +
               "üé° **Roulette** - Betting systems\n" +
               "üé∞ **Slots** - Bankroll management\n" +
               "üé¥ **Poker** - Starting hands & odds\n" +
               "üíé **Baccarat** - Best bets\n" +
               "üì∫ **Live Dealer** - Real-time tips\n\n" +
               "Which one interests you? üéØ";
        quickActions = [
          { text: '‚úàÔ∏è Aviator', action: 'aviator strategy' },
          { text: 'üÉè Blackjack', action: 'blackjack strategy' },
          { text: 'üé° Roulette', action: 'roulette strategy' },
          { text: 'üé∞ Slots', action: 'slots strategy' },
        ];
        return { response, quickActions };
      }
      
      // Direct game mentions asking for strategy
      if (msg.includes('aviator') && (msg.includes('how') || msg.includes('tip') || msg.includes('strat') || msg.includes('win'))) {
        response = formatStrategyResponse(CASINO_STRATEGIES.aviator);
        quickActions = [
          { text: 'üéÆ Play Aviator', action: 'tell me about aviator' },
          { text: 'üí• Other crash games', action: 'show crash games' },
          { text: 'üìà High RTP games', action: 'highest RTP games' },
          { text: 'üé∞ Casino games', action: 'show casino games' },
        ];
        return { response, quickActions };
      }
      
      if (msg.includes('blackjack') && (msg.includes('how') || msg.includes('tip') || msg.includes('strat') || msg.includes('win'))) {
        response = formatStrategyResponse(CASINO_STRATEGIES.blackjack);
        quickActions = [
          { text: 'üéÆ Play Blackjack', action: 'tell me about Live Blackjack' },
          { text: 'üÉè Other card games', action: 'show card games' },
          { text: 'üì∫ Live casino', action: 'live casino games' },
          { text: 'üé∞ All games', action: 'show casino games' },
        ];
        return { response, quickActions };
      }
      
      if (msg.includes('roulette') && (msg.includes('how') || msg.includes('tip') || msg.includes('strat') || msg.includes('win'))) {
        response = formatStrategyResponse(CASINO_STRATEGIES.roulette);
        quickActions = [
          { text: 'üéÆ Play Roulette', action: 'tell me about Lightning Roulette' },
          { text: 'üì∫ Live casino', action: 'live casino games' },
          { text: 'üé≤ Table games', action: 'show table games' },
          { text: 'üé∞ All games', action: 'show casino games' },
        ];
        return { response, quickActions };
      }
      
      if ((msg.includes('slot') || msg.includes('slots')) && (msg.includes('how') || msg.includes('tip') || msg.includes('strat') || msg.includes('win'))) {
        response = formatStrategyResponse(CASINO_STRATEGIES.slots);
        quickActions = [
          { text: 'üî• Popular slots', action: 'popular slot games' },
          { text: 'üìà High RTP slots', action: 'highest RTP slots' },
          { text: 'üí∞ Jackpot slots', action: 'jackpot games' },
          { text: 'üé∞ All slots', action: 'show all slots' },
        ];
        return { response, quickActions };
      }
      
      // Casino games list
      if (msg === 'casino' || msg === 'casino games' || msg.includes('what casino games') || msg.includes('show casino') || msg.includes('all casino')) {
        response = "Hey Bwana! üé∞ Here's what you can play:\n\n" +
               "**Crash Games**:\n‚úàÔ∏è Aviator, Spaceman, Plinko\n\n" +
               "**Table Games**:\nüÉè Blackjack, Roulette, Baccarat, Poker\n\n" +
               "**Slots**:\nüé∞ Starburst, Book of Dead, Sweet Bonanza, Gates of Olympus & hundreds more!\n\n" +
               "**Live Casino**:\nüì∫ Lightning Roulette, Live Blackjack, Crazy Time\n\n" +
               "What catches your eye? üéØ";
        quickActions = [
          { text: '‚úàÔ∏è Crash games', action: 'show crash games' },
          { text: 'üé∞ Popular slots', action: 'popular slot games' },
          { text: 'üì∫ Live casino', action: 'live casino games' },
          { text: 'üéØ Game strategies', action: 'casino strategies' },
        ];
        return { response, quickActions };
      }
      
      // ============================================
      // GREETINGS & COMMON MESSAGES
      // ============================================
      
      // Greetings - INSTANT
      const greetings = ['hi', 'hello', 'hey', 'yo', 'sup', 'hola', 'howdy', 'good morning', 'good afternoon', 'good evening', 'whats up', "what's up", 'wassup'];
      if (greetings.some(g => msg === g || msg === g + '!' || msg === g + '?')) {
        const responses = [
          "Hey Bwana! üëã What can I help you with today?",
          "Yo Bwana! üéØ Ready to find some winners?",
          "Hey there Bwana! üëã Got some hot picks ready for you!",
          "What's good Bwana! üî• EPL, La Liga, NBA, Casino - what do you need?",
        ];
        response = responses[Math.floor(Math.random() * responses.length)];
        quickActions = [
          { text: '‚öΩ Sports tips', action: 'give me sports tips' },
          { text: 'üé∞ Casino games', action: 'show casino games' },
          { text: 'üìä Betting markets', action: 'explain betting markets' },
          { text: 'üéÅ My bonuses', action: 'check my bonuses' },
        ];
        return { response, quickActions };
      }
      
      // How are you - INSTANT
      if (msg.includes('how are you') || msg.includes('how r u') || msg === 'hru') {
        response = "I'm great Bwana! üéØ Ready to help you win big today!";
        quickActions = [
          { text: '‚öΩ EPL tips', action: 'EPL tips for today' },
          { text: 'üé∞ Casino', action: 'show casino games' },
          { text: 'üìä Stats', action: 'show my stats' },
          { text: 'üî• Hot picks', action: 'give me hot picks' },
        ];
        return { response, quickActions };
      }
      
      // Thanks - INSTANT
      if (msg === 'thanks' || msg === 'thank you' || msg === 'thx' || msg === 'ty') {
        response = "Anytime Bwana! üôè Good luck with your bets!";
        quickActions = [
          { text: 'üéØ More tips', action: 'give me more tips' },
          { text: 'üé∞ Try casino', action: 'show casino games' },
          { text: 'üìä Other markets', action: 'show betting markets' },
          { text: 'üëã Later!', action: 'bye' },
        ];
        return { response, quickActions };
      }
      
      // Bye - INSTANT
      if (msg === 'bye' || msg === 'goodbye' || msg === 'see you' || msg === 'later' || msg === 'cya') {
        response = "Later Bwana! üëã Good luck and gamble responsibly! Come back anytime! üéØ";
        quickActions = []; // No actions needed for goodbye
        return { response, quickActions };
      }
      
      // Help - INSTANT
      if (msg === 'help' || msg === '?' || msg === 'what can you do') {
        response = "Hey Bwana! Here's what I can help with:\n\n" +
                   "üéØ **Sports Tips** - Match predictions, corners, cards, goals\n" +
                   "üé∞ **Casino** - Games, strategies & recommendations\n" +
                   "üìä **Statistics** - Team stats, league data, probabilities\n" +
                   "üéÅ **Bonuses** - Check your available bonuses\n\n" +
                   "What interests you? üéØ";
        quickActions = [
          { text: '‚öΩ Sports tips', action: 'give me sports tips' },
          { text: 'üé∞ Casino games', action: 'show casino games' },
          { text: 'üìä Bet markets', action: 'explain betting markets' },
          { text: 'üéØ Strategies', action: 'betting strategies' },
        ];
        return { response, quickActions };
      }
      
      // Simple sport mentions
      if (msg === 'epl' || msg === 'premier league') {
        response = "Premier League, nice choice Bwana! ‚öΩ Ready for some tips?";
        quickActions = [
          { text: 'üéØ EPL tips today', action: 'EPL tips for today' },
          { text: 'üìê Corner stats', action: 'EPL corner statistics' },
          { text: '‚öΩ Goals stats', action: 'EPL goals statistics' },
          { text: 'üìä League table', action: 'EPL standings' },
        ];
        return { response, quickActions };
      }
      
      if (msg === 'nba') {
        response = "NBA action! üèÄ Let's find some winners!";
        quickActions = [
          { text: 'üéØ NBA tips today', action: 'NBA tips for today' },
          { text: 'üìä Team stats', action: 'NBA team statistics' },
          { text: 'üèÜ Standings', action: 'NBA standings' },
          { text: '‚öΩ Other sports', action: 'show other sports' },
        ];
        return { response, quickActions };
      }
      
      if (msg === 'la liga') {
        response = "La Liga - good taste Bwana! üá™üá∏";
        quickActions = [
          { text: 'üéØ La Liga tips', action: 'La Liga tips for today' },
          { text: 'üìê Corner stats', action: 'La Liga corner statistics' },
          { text: '‚öΩ Goals stats', action: 'La Liga goals statistics' },
          { text: 'üìä League table', action: 'La Liga standings' },
        ];
        return { response, quickActions };
      }
      
      // Not a simple message - needs Claude API
      return null;
    }

    function askQuestion(question) {
      document.getElementById('messageInput').value = question;
      sendMessage();
    }

    // ‚ö° SPEED: Streaming-style message display (shows text progressively)
    // Now supports quickActions for clickable recommendations
    function addMessage(text, isUser, quickActions = []) {
      const container = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `flex ${isUser ? 'justify-end' : 'justify-start'} message-appear`;
      
      const contentId = 'msg-' + Date.now();
      const actionsId = 'actions-' + Date.now();
      
      messageDiv.innerHTML = `
        <div class="max-w-[90%] rounded-2xl px-4 py-3 ${
          isUser 
            ? 'bg-gradient-to-r from-amber-500 to-orange-500 text-white rounded-br-sm'
            : 'bg-slate-800 text-slate-100 rounded-bl-sm border border-slate-700'
        }">
          ${!isUser ? `
            <div class="flex items-center gap-2 mb-2 pb-2 border-b border-slate-600">
              <div class="w-6 h-6 rounded-full bg-gradient-to-r from-amber-400 to-orange-500 flex items-center justify-center">
                <span class="text-xs">üéØ</span>
              </div>
              <span class="text-xs font-medium text-amber-400">BetAssist AI</span>
              <span class="text-xs text-slate-500">‚Ä¢ Live Data</span>
            </div>
          ` : ''}
          <div id="${contentId}" class="text-sm whitespace-pre-wrap leading-relaxed"></div>
          <div id="${actionsId}"></div>
        </div>
      `;
      
      container.appendChild(messageDiv);
      messageDiv.scrollIntoView({ behavior: 'smooth' });
      
      const contentDiv = document.getElementById(contentId);
      const actionsDiv = document.getElementById(actionsId);
      
      // Show text content
      contentDiv.innerHTML = formatText(text);
      
      // Add quick action buttons if provided (only for AI messages)
      if (!isUser && quickActions && quickActions.length > 0) {
        actionsDiv.innerHTML = generateQuickActionsHTML(quickActions);
      }
      
      // Scroll to show the message
      setTimeout(() => {
        messageDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }, 100);
    }

    // ‚ö° SPEED: Simulate streaming by showing text progressively
    function streamText(element, text, speed = 5) {
      const formatted = formatText(text);
      let index = 0;
      const chunkSize = 3; // Characters per frame
      
      function showNextChunk() {
        if (index < formatted.length) {
          // Find a good break point (don't break mid-tag)
          let end = Math.min(index + chunkSize, formatted.length);
          
          // Don't break in the middle of an HTML tag
          const remaining = formatted.substring(index);
          const tagStart = remaining.indexOf('<');
          const tagEnd = remaining.indexOf('>');
          
          if (tagStart >= 0 && tagStart < chunkSize && tagEnd > tagStart) {
            end = index + tagEnd + 1;
          }
          
          element.innerHTML = formatted.substring(0, end);
          index = end;
          
          // Scroll to keep up with text
          element.parentElement.parentElement.scrollIntoView({ behavior: 'smooth', block: 'end' });
          
          requestAnimationFrame(showNextChunk);
        }
      }
      
      requestAnimationFrame(showNextChunk);
    }

    // Original addMessage for backwards compatibility
    function addMessageInstant(text, isUser) {
      const container = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `flex ${isUser ? 'justify-end' : 'justify-start'} message-appear`;
      
      messageDiv.innerHTML = `
        <div class="max-w-[90%] rounded-2xl px-4 py-3 ${
          isUser 
            ? 'bg-gradient-to-r from-amber-500 to-orange-500 text-white rounded-br-sm'
            : 'bg-slate-800 text-slate-100 rounded-bl-sm border border-slate-700'
        }">
          ${!isUser ? `
            <div class="flex items-center gap-2 mb-2 pb-2 border-b border-slate-600">
              <div class="w-6 h-6 rounded-full bg-gradient-to-r from-amber-400 to-orange-500 flex items-center justify-center">
                <span class="text-xs">üéØ</span>
              </div>
              <span class="text-xs font-medium text-amber-400">BetAssist AI</span>
              <span class="text-xs text-slate-500">‚Ä¢ Live Data</span>
            </div>
          ` : ''}
          <div class="text-sm whitespace-pre-wrap leading-relaxed">${formatText(text)}</div>
        </div>
      `;
      
      container.appendChild(messageDiv);
      messageDiv.scrollIntoView({ behavior: 'smooth' });
    }

    function formatText(text) {
      return text
        // Bold
        .replace(/\*\*(.*?)\*\*/g, '<strong class="text-amber-300">$1</strong>')
        // Links
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" class="text-amber-400 hover:underline">$1</a>')
        // Line breaks
        .replace(/\n/g, '<br>');
    }

    function addWelcomeMessage() {
      // Get player summary
      const profile = getPlayerSummaryForAI();
      const isReturning = profile.behavior.totalInteractions > 0;
      const hasFavorites = profile.preferences.favoriteLeagues.length > 0;
      const hasHistory = profile.performance.totalBets > 0;

      let welcomeText = `Hey Bwana! üëã ${isReturning ? 'Good to see you again!' : 'Welcome to BetAssist!'}\n\n`;

      // Personalized greeting for returning players
      if (hasFavorites) {
        const favLeagueNames = profile.preferences.favoriteLeagues.map(l => l.name).slice(0, 2).join(' and ');
        welcomeText += `I know you're into **${favLeagueNames}** - got some nice picks today! ‚öΩ\n\n`;
      }

      // Show quick stats if they have history
      if (hasHistory) {
        welcomeText += `Quick check: **${profile.performance.winRate}** win rate`;
        if (profile.performance.currentStreak.count > 0) {
          welcomeText += ` and you're on a **${profile.performance.currentStreak.count}-${profile.performance.currentStreak.type} streak** üî•`;
        }
        welcomeText += `\n\n`;
      }

      // Bonus reminder
      welcomeText += `üéÅ Don't forget to check your **bonuses** before placing bets!\n\n`;

      welcomeText += `What can I help with today? üéØ`;

      // Welcome quick actions
      const welcomeActions = [
        { text: '‚öΩ Sports tips', action: 'give me sports tips for today' },
        { text: 'üé∞ Casino games', action: 'show casino games' },
        { text: 'üìä Betting markets', action: 'explain betting markets' },
        { text: 'üéØ Strategies', action: 'show betting strategies' },
      ];

      addMessage(welcomeText, false, welcomeActions);
    }

    // ============================================
    // INITIALIZATION
    // ============================================

    // Pre-fetched data for instant responses
    let prefetchedData = {
      leagues: {},
      lastFetch: null,
    };

    // Pre-fetch popular leagues in background for instant responses
    async function prefetchPopularData() {
      const popularLeagues = ['eng.1', 'esp.1', 'ger.1', 'ita.1', 'nba', 'nfl'];
      
      console.log('‚ö° Pre-fetching popular league data...');
      
      // Fetch all in parallel for speed
      const promises = popularLeagues.map(async (league) => {
        try {
          const data = await fetchGames(league);
          if (!data.error) {
            prefetchedData.leagues[league] = data;
          }
        } catch (e) {
          // Silently fail - this is just optimization
        }
      });

      // Don't wait - let it run in background
      Promise.all(promises).then(() => {
        prefetchedData.lastFetch = Date.now();
        console.log('‚úÖ Pre-fetch complete:', Object.keys(prefetchedData.leagues).length, 'leagues cached');
      });
    }

    // Initialize the app
    async function initializeApp() {
      // Initialize Supabase first
      await initSupabase();
      
      // Load player data (from Supabase or localStorage)
      playerData = await loadPlayerData();
      console.log('üë§ Player data loaded:', playerData.profile.username || 'Guest');
      
      // Show welcome message
      addWelcomeMessage();
      
      // Pre-fetch popular data in background (non-blocking)
      prefetchPopularData();
      
      // Show connection status
      if (supabaseClient && currentPlayerId) {
        console.log('üóÑÔ∏è Connected to Supabase database');
      } else {
        console.log('üì¶ Running in demo mode (localStorage)');
      }
    }

    window.onload = async function() {
      console.log('üöÄ BetAssist AI Starting...');
      console.log('üîó Using Supabase proxy:', SUPABASE_CONFIG.claudeProxyUrl);
      
      try {
        await initializeApp();
        console.log('üéâ BetAssist AI Ready!');
      } catch (error) {
        console.error('‚ùå Initialization failed:', error);
        document.getElementById('messages').innerHTML = `
          <div class="bg-red-500/20 border border-red-500 rounded-xl p-4 text-red-200">
            <strong>‚ö†Ô∏è Initialization Error</strong><br>
            ${error.message}<br>
            <small>Check browser console for details</small>
          </div>
        `;
      }
    };
  </script>
</body>
</html>
